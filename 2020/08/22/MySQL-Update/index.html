<!DOCTYPE html>
<html lang="en">
<head><meta name="generator" content="Hexo 3.9.0">
    <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">

    <meta name="author" content="Ray Wong">


    <meta name="subtitle" content="Keep coding...">



    <meta name="keywords" content="后端开发 全栈 Python Go">


<title>MySQL是如何执行SQL更新语句的 | Ray的博客</title>



    <link rel="icon" href="/static/blogImg/ray.png">




    <!-- stylesheets list from _config.yml -->
    
    <link rel="stylesheet" href="/css/style.css">
    



    <!-- scripts list from _config.yml -->
    
    <script src="/js/script.js"></script>
    
    <script src="/js/tocbot.min.js"></script>
    



    
    
        
    


</head>
<body>
    <div class="wrapper">
        <header>
    <nav class="navbar">
        <div class="container">
            <div class="navbar-header header-logo"><a href="/">Ray&#39;s Blog</a></div>
            <div class="menu navbar-right">
                
                    <a class="menu-item" href="/archives">Archives</a>
                
                    <a class="menu-item" href="/categories">Categories</a>
                
                    <a class="menu-item" href="/tags">Tags</a>
                
                    <a class="menu-item" href="/2019/09/23/index/">About</a>
                
                <input id="switch_default" type="checkbox" class="switch_default">
                <label for="switch_default" class="toggleBtn"></label>
            </div>
        </div>
    </nav>

    
    <nav class="navbar-mobile" id="nav-mobile">
        <div class="container">
            <div class="navbar-header">
                <div>
                    <a href="/">Ray&#39;s Blog</a><a id="mobile-toggle-theme">·&nbsp;Light</a>
                </div>
                <div class="menu-toggle" onclick="mobileBtn()">&#9776; Menu</div>
            </div>
            <div class="menu" id="mobile-menu">
                
                    <a class="menu-item" href="/archives">Archives</a>
                
                    <a class="menu-item" href="/categories">Categories</a>
                
                    <a class="menu-item" href="/tags">Tags</a>
                
                    <a class="menu-item" href="/2019/09/23/index/">About</a>
                
            </div>
        </div>
    </nav>

</header>
<script>
    var mobileBtn = function f() {
        var toggleMenu = document.getElementsByClassName("menu-toggle")[0];
        var mobileMenu = document.getElementById("mobile-menu");
        if(toggleMenu.classList.contains("active")){
           toggleMenu.classList.remove("active")
            mobileMenu.classList.remove("active")
        }else{
            toggleMenu.classList.add("active")
            mobileMenu.classList.add("active")
        }
    }
</script>
        <div class="main">
            <div class="container">
    
    
        <div class="post-toc">
    <div class="tocbot-list">
    </div>
    <div class="tocbot-list-menu">
        <a class="tocbot-toc-expand" onclick="expand_toc()">Expand all</a>
        <a onclick="go_top()">Back to top</a>
        <a onclick="go_bottom()">Go to bottom</a>
    </div>
</div>

<script>
    document.ready(
        function () {
            tocbot.init({
                tocSelector: '.tocbot-list',
                contentSelector: '.post-content',
                headingSelector: 'h1, h2, h3, h4, h5',
                collapseDepth: 1,
                orderedList: false,
                scrollSmooth: true,
            })
        }
    )

    function expand_toc() {
        var b = document.querySelector(".tocbot-toc-expand");
        tocbot.init({
            tocSelector: '.tocbot-list',
            contentSelector: '.post-content',
            headingSelector: 'h1, h2, h3, h4, h5',
            collapseDepth: 6,
            orderedList: false,
            scrollSmooth: true,
        });
        b.setAttribute("onclick", "collapse_toc()");
        b.innerHTML = "Collapse all"
    }

    function collapse_toc() {
        var b = document.querySelector(".tocbot-toc-expand");
        tocbot.init({
            tocSelector: '.tocbot-list',
            contentSelector: '.post-content',
            headingSelector: 'h1, h2, h3, h4, h5',
            collapseDepth: 1,
            orderedList: false,
            scrollSmooth: true,
        });
        b.setAttribute("onclick", "expand_toc()");
        b.innerHTML = "Expand all"
    }

    function go_top() {
        window.scrollTo(0, 0);
    }

    function go_bottom() {
        window.scrollTo(0, document.body.scrollHeight);
    }

</script>
    

    
    <article class="post-wrap">
        <header class="post-header">
            <h1 class="post-title">MySQL是如何执行SQL更新语句的</h1>
            
                <div class="post-meta">
                    
                        Author: <a itemprop="author" rel="author" href="/">Ray Wong</a>
                    

                    
                        <span class="post-time">
                        Date: <a href="#">August 22, 2020&nbsp;&nbsp;14:27:58</a>
                        </span>
                    
                    
                        <span class="post-category">
                    Category:
                            
                                <a href="/categories/数据库/">数据库</a>
                            
                        </span>
                    
                </div>
            
        </header>

        <div class="post-content">
            <p>用了这么久数据库，却不知道数据库是如何执行我们输入的语句的，经过一番查阅后，记录下执行一条查询和更新SQL语句后，MySQL是如何工作的。</p>
<p>SQL语句基本的执行链路：</p>
<center><img src="/static/mysql/liucheng.png" alt="流程"></center>

<h3 id="1-查询语句是如何执行"><a href="#1-查询语句是如何执行" class="headerlink" title="1 查询语句是如何执行"></a>1 查询语句是如何执行</h3><p>一条查询语句的执行过程一般是经过连接器、分析器、优化器、执行器等功能模块，最后到达存储引擎</p>
<h3 id="2-更新语句是如何执行"><a href="#2-更新语句是如何执行" class="headerlink" title="2 更新语句是如何执行"></a>2 更新语句是如何执行</h3><p>一条更新语句的执行过程和查询的执行过程是一样的：<br>以执行这条SQL语句为例。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; update T set c=c+1 where ID=2;</span><br></pre></td></tr></table></figure></p>
<ol>
<li>连接器：连接数据库。</li>
<li>分析器：分析器通过词法和语法解析知道这是一条更新语句，</li>
<li>优化器：决定使用ID这个索引。</li>
<li>执行器：向存储引擎读取这一行数据，然后更新并写入存储引擎。</li>
</ol>
<h3 id="2-重要的日志模块：redo-log"><a href="#2-重要的日志模块：redo-log" class="headerlink" title="2 重要的日志模块：redo log"></a>2 重要的日志模块：redo log</h3><p>让我们继续以上面一条SQL语句为例，看看<code>redo log</code>是起到了什么作用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; update T set c=c+1 where ID=2;</span><br></pre></td></tr></table></figure></p>
<p>MySQL在执行这条语句时，肯定是先把<code>ID=2</code>这条数据从搜索引擎中拿出来，然后修改<code>c</code>字段，写入存储引擎，最后存储引擎刷入磁盘，这没问题吧？</p>
<p>MySQL的基本存储结构是<code>页</code>，所以MySQL是先把这条记录所在的<code>页</code>找到，然后再把该页的数据加载到内存，在内存中找到对应的数据后修改，再刷回磁盘。</p>
<p><strong>问题1</strong><br>如果在内存把数据修改了，但是还没来得及刷回磁盘数据库却突然岩机了怎么办？很显然数据就丢失了，这和我们预期的不一样。</p>
<p><strong>如何解决</strong><br>也许你会说很简单阿，在事务提交之前写入磁盘就行了。</p>
<p><strong>问题2</strong><br>如果每一次更新操作都需要刷回磁盘，这整个过程<code>IO</code>成本、查找记录成本都很高。一个页有<code>16kb</code>大小，只改一点内容就操作一次磁盘，为了解决这个问题。MySQL引入了<code>WAL</code>这么一个概念（Write-Ahead Logging），先写入日志，再写磁盘，至于什么时候再写入磁盘，会有配置供我们设置。</p>
<p>此时就引入<code>redo log</code>，当数据修改的时候，不仅在内存中操作，还会在<code>redo log</code>中记录这次操作，此时<code>redo log</code>的状态为<code>prepare</code>。当事务提交的时<code>redo log</code>日志将从<code>prepare</code>状态修改为<code>commit</code>，也就是我们所说的<strong>两阶段提交</strong>，然后再根据需要将更新完的数据刷入磁盘。当数据库岩机重启的时候，之前提交的记录都不会丢失，会恢复<code>redo log</code>中的内容到数据库，再根据<code>undo log</code>和<code>binlog</code>决定回滚还是提交数据。这个能力称为<code>crash-safe</code>。</p>
<p><code>redo log</code>记录的是物理变化，即内容修改（在某个数据页上做了什么修改）。它也是需要磁盘的，但它的好处是<code>顺序IO</code>，比<code>随机IO</code>快多了。</p>
<h3 id="3-重要的日志模块：undo-log"><a href="#3-重要的日志模块：undo-log" class="headerlink" title="3 重要的日志模块：undo log"></a>3 重要的日志模块：undo log</h3><p><code>undo log</code>是用来保证事务的原子性，它记录数据被修改前的值，以便在事务失败的时候进行<code>rollback</code>。举个栗子，当事务提交成功后，在将<code>redo log</code>从<code>perpare</code>状态修改成<code>commit</code>时系统异常重启了，那么<code>redo log</code>会根据自身的状态并结合<code>undo log</code>进行回滚。</p>
<h3 id="4-重要的日志模块：binlog"><a href="#4-重要的日志模块：binlog" class="headerlink" title="4 重要的日志模块：binlog"></a>4 重要的日志模块：binlog</h3><p>MySQL 整体来看，其实就有两块：一块是 Server 层，它主要做的是 MySQL 功能层面的事情；还有一块是引擎层，负责存储相关的具体事宜。<code>redo log</code>是<code>InnoDB</code>引擎特有的日志，而 Server 层也有自己的日志，称为 <code>binlog</code>（归档日志）。</p>
<p><code>binlog</code>记录了数据库表结构和表数据变更，比如<code>update/delete/insert/truncate/create</code>。它不会记录<code>select</code>（因为这没有对表没有进行变更）。</p>
<p>我们可以简单理解为：存储着每条变更的SQL语句。</p>
<h4 id="复制和恢复数据"><a href="#复制和恢复数据" class="headerlink" title="复制和恢复数据"></a>复制和恢复数据</h4><p>主要有两个作用：</p>
<ul>
<li>MySQL在公司使用的时候往往都是一主多从结构的，从服务器需要与主服务器的数据保持一致，这就是通过binlog来实现的。</li>
<li>数据库的数据被干掉了，我们可以通过binlog来对数据进行恢复。</li>
</ul>
<p>因为binlog记录了数据库表的变更，所以我们可以复制（主从复制)和恢复数据。</p>
<h4 id="执行流程"><a href="#执行流程" class="headerlink" title="执行流程"></a>执行流程</h4><p>有了对这两个日志的概念性理解，我们再来看执行器和<code>InnoDB</code>引擎在执行上面简单的<code>update</code>语句时的内部流程。</p>
<ol>
<li>执行器先找引擎取 ID=2 这一行。ID 是主键，引擎直接用树搜索找到这一行。如果 ID=2 这一行所在的数据页本来就在内存中，就直接返回给执行器；否则，需要先从磁盘读入内存，然后再返回。</li>
<li>执行器拿到引擎给的行数据，把这个值加上 1，比如原来是 N，现在就是 N+1，得到新的一行数据，再调用引擎接口写入这行新数据。</li>
<li>引擎将这行新数据更新到内存中，同时将这个更新操作记录到 redo log 里面，此时 redo log 处于 prepare 状态。然后告知执行器执行完成了，随时可以提交事务。</li>
<li>执行器生成这个操作的 binlog，并把 binlog 写入磁盘。</li>
<li>执行器调用引擎的提交事务接口，引擎把刚刚写入的 redo log 改成提交（commit）状态，更新完成。</li>
</ol>
<p>update 语句的执行流程图：</p>
<center><img src="/static/mysql/zxliucheng.png" alt="流程"></center>

<h3 id="4-redo-log和binlog的不同"><a href="#4-redo-log和binlog的不同" class="headerlink" title="4 redo log和binlog的不同"></a>4 redo log和binlog的不同</h3><h4 id="4-1-存储上"><a href="#4-1-存储上" class="headerlink" title="4.1 存储上"></a>4.1 存储上</h4><p>redo log 是物理日志，记录的是“在某个数据页上做了什么修改”；binlog 是逻辑日志，记录的是这个语句的原始逻辑，比如“给 ID=2 这一行的 c 字段加 1 ”。</p>
<h4 id="4-2-功能"><a href="#4-2-功能" class="headerlink" title="4.2 功能"></a>4.2 功能</h4><p>redo log的作用是为<strong>持久化</strong>而生的。写完内存，如果数据库挂了，那我们可以通过redo log来恢复内存还没来得及刷到磁盘的数据，将redo log加载到内存里边，那内存就能恢复到挂掉之前的数据了。</p>
<p>binlog的作用是复制和恢复而生的。</p>
<p>主从服务器需要保持数据的一致性，通过binlog来同步数据。<br>如果整个数据库的数据都被删除了，binlog存储着所有的数据变更情况，那么可以通过binlog来对数据进行恢复。</p>
<p>那么如果整个数据库的数据都被删除了，那我可以用redo log的记录来恢复吗？</p>
<p>不能，因为功能的不同，redo log 存储的是物理数据的变更，如果我们内存的数据已经刷到了磁盘了，那redo log的数据就无效了。所以redo log不会存储着历史所有数据的变更，文件的内容会被覆盖的。</p>
<h4 id="4-3-写入细节"><a href="#4-3-写入细节" class="headerlink" title="4.3 写入细节"></a>4.3 写入细节</h4><p>redo log 是 InnoDB 引擎特有的；binlog 是 MySQL 的 Server 层实现的，所有引擎都可以使用。</p>

        </div>

        
            <section class="post-copyright">
                
                
                
                

            </section>
        
        <section class="post-tags">
            <div>
                <span>Tag(s):</span>
                <span class="tag">
                    
                    
                        <a href="/tags/MySQL/"># MySQL</a>
                    
                        
                </span>
            </div>
            <div>
                <a href="javascript:window.history.back();">back</a>
                <span>· </span>
                <a href="/">home</a>
            </div>
        </section>
        <section class="post-nav">
            
            
            <a class="next" rel="next" href="/2020/07/18/MySQL_block/">MySQL事务和锁</a>
            
        </section>


    </article>
</div>

        </div>
        <footer id="footer" class="footer">
    <div class="copyright">
        <span>© Ray Wong | Powered by <a href="https://hexo.io" target="_blank">Hexo</a> & <a href="https://github.com/Siricee/hexo-theme-Chic" target="_blank">Chic</a></span>
    </div>
</footer>

    </div>
</body>
</html>
