<!DOCTYPE html>
<html lang="en">
<head><meta name="generator" content="Hexo 3.9.0">
    <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">

    <meta name="author" content="Ray Wong">


    <meta name="subtitle" content="Keep coding...">



    <meta name="keywords" content="后端开发 全栈 Python Go">


<title>MySQL优化 | Ray的博客</title>



    <link rel="icon" href="/static/blogImg/ray.png">




    <!-- stylesheets list from _config.yml -->
    
    <link rel="stylesheet" href="/css/style.css">
    



    <!-- scripts list from _config.yml -->
    
    <script src="/js/script.js"></script>
    
    <script src="/js/tocbot.min.js"></script>
    



    
    
        
    


</head>
<body>
    <div class="wrapper">
        <header>
    <nav class="navbar">
        <div class="container">
            <div class="navbar-header header-logo"><a href="/">Ray&#39;s Blog</a></div>
            <div class="menu navbar-right">
                
                    <a class="menu-item" href="/archives">Archives</a>
                
                    <a class="menu-item" href="/tags">Tags</a>
                
                    <a class="menu-item" href="/2019/09/23/index/">About</a>
                
                <input id="switch_default" type="checkbox" class="switch_default">
                <label for="switch_default" class="toggleBtn"></label>
            </div>
        </div>
    </nav>

    
    <nav class="navbar-mobile" id="nav-mobile">
        <div class="container">
            <div class="navbar-header">
                <div>
                    <a href="/">Ray&#39;s Blog</a><a id="mobile-toggle-theme">·&nbsp;Light</a>
                </div>
                <div class="menu-toggle" onclick="mobileBtn()">&#9776; Menu</div>
            </div>
            <div class="menu" id="mobile-menu">
                
                    <a class="menu-item" href="/archives">Archives</a>
                
                    <a class="menu-item" href="/tags">Tags</a>
                
                    <a class="menu-item" href="/2019/09/23/index/">About</a>
                
            </div>
        </div>
    </nav>

</header>
<script>
    var mobileBtn = function f() {
        var toggleMenu = document.getElementsByClassName("menu-toggle")[0];
        var mobileMenu = document.getElementById("mobile-menu");
        if(toggleMenu.classList.contains("active")){
           toggleMenu.classList.remove("active")
            mobileMenu.classList.remove("active")
        }else{
            toggleMenu.classList.add("active")
            mobileMenu.classList.add("active")
        }
    }
</script>
        <div class="main">
            <div class="container">
    
    
        <div class="post-toc">
    <div class="tocbot-list">
    </div>
    <div class="tocbot-list-menu">
        <a class="tocbot-toc-expand" onclick="expand_toc()">Expand all</a>
        <a onclick="go_top()">Back to top</a>
        <a onclick="go_bottom()">Go to bottom</a>
    </div>
</div>

<script>
    document.ready(
        function () {
            tocbot.init({
                tocSelector: '.tocbot-list',
                contentSelector: '.post-content',
                headingSelector: 'h1, h2, h3, h4, h5',
                collapseDepth: 1,
                orderedList: false,
                scrollSmooth: true,
            })
        }
    )

    function expand_toc() {
        var b = document.querySelector(".tocbot-toc-expand");
        tocbot.init({
            tocSelector: '.tocbot-list',
            contentSelector: '.post-content',
            headingSelector: 'h1, h2, h3, h4, h5',
            collapseDepth: 6,
            orderedList: false,
            scrollSmooth: true,
        });
        b.setAttribute("onclick", "collapse_toc()");
        b.innerHTML = "Collapse all"
    }

    function collapse_toc() {
        var b = document.querySelector(".tocbot-toc-expand");
        tocbot.init({
            tocSelector: '.tocbot-list',
            contentSelector: '.post-content',
            headingSelector: 'h1, h2, h3, h4, h5',
            collapseDepth: 1,
            orderedList: false,
            scrollSmooth: true,
        });
        b.setAttribute("onclick", "expand_toc()");
        b.innerHTML = "Expand all"
    }

    function go_top() {
        window.scrollTo(0, 0);
    }

    function go_bottom() {
        window.scrollTo(0, document.body.scrollHeight);
    }

</script>
    

    
    <article class="post-wrap">
        <header class="post-header">
            <h1 class="post-title">MySQL优化</h1>
            
                <div class="post-meta">
                    
                        Author: <a itemprop="author" rel="author" href="/">Ray Wong</a>
                    

                    
                        <span class="post-time">
                        Date: <a href="#">May 8, 2020&nbsp;&nbsp;9:30:18</a>
                        </span>
                    
                    
                </div>
            
        </header>

        <div class="post-content">
            <h3 id="1-查询SQL尽量不要使用-select-而是select具体字段。"><a href="#1-查询SQL尽量不要使用-select-而是select具体字段。" class="headerlink" title="1 查询SQL尽量不要使用 select * ,而是select具体字段。"></a>1 查询SQL尽量不要使用 <code>select *</code> ,而是<code>select</code>具体字段。</h3><p>反例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from employee;</span><br></pre></td></tr></table></figure></p>
<p>正例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select id, name from employee;</span><br></pre></td></tr></table></figure></p>
<p>说明:</p>
<ol>
<li>只取需要的字段，节省资源、减少网络开销。</li>
<li>select * 进行查询时，很可能就不会使用到覆盖索引了，就会造成回表查询。</li>
</ol>
<a id="more"></a>
<h3 id="2-如果只查询结果只有一条的数据或者最大、最小一条记录，使用limit"><a href="#2-如果只查询结果只有一条的数据或者最大、最小一条记录，使用limit" class="headerlink" title="2 如果只查询结果只有一条的数据或者最大、最小一条记录，使用limit"></a>2 如果只查询结果只有一条的数据或者最大、最小一条记录，使用limit</h3><p>假如有employee员工表，要找出一个名字叫ray的人<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE  `employee`(</span><br><span class="line">  `id` int (11) NOT NULL,</span><br><span class="line">  `name` varchar(255) DEFAULT NULL,</span><br><span class="line">  `age` int(11) DEFAULT NULL,</span><br><span class="line">  `date` datetime DEFAULT NULL,</span><br><span class="line">  `sex` int (1) DEFAULT NULL,</span><br><span class="line">  PRIMARY KEY (`id`)</span><br><span class="line">) ENGINE=InnoDB DEFAULT CHARSET=utf8;</span><br></pre></td></tr></table></figure></p>
<p>反例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select id, name from employee where name=&apos;ray&apos;</span><br></pre></td></tr></table></figure></p>
<p>正例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select id, name from employee where name=&apos;ray&apos; limit 1;</span><br></pre></td></tr></table></figure></p>
<p>说明：</p>
<ol>
<li>加上limit 1后,只要找到了对应的一条记录,就不会继续向下扫描了,效率将会大大提高。</li>
<li>当然，如果name是唯一索引的话，是不必要加上limit 1了，因为limit的存在主要就是为了防止全表扫描，从而提高性能,如果一个语句本身可以预知不用全表扫描，有没有limit ，性能的差别并不大。</li>
</ol>
<h3 id="3-批量插入"><a href="#3-批量插入" class="headerlink" title="3 批量插入"></a>3 批量插入</h3><p>反例<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">INSERT into person(name,age) values(&apos;A&apos;,24)</span><br><span class="line">INSERT into person(name,age) values(&apos;B&apos;,24)</span><br><span class="line">INSERT into person(name,age) values(&apos;C&apos;,24)</span><br></pre></td></tr></table></figure></p>
<p>正例<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">INSERT into person(name,age) values(&apos;A&apos;,24),(&apos;B&apos;,24),(&apos;C&apos;,24);</span><br></pre></td></tr></table></figure></p>
<p>说明:</p>
<ol>
<li>比较常规，就不多做说明了</li>
</ol>
<h3 id="4-优化like语句"><a href="#4-优化like语句" class="headerlink" title="4 优化like语句"></a>4 优化like语句</h3><p>尽量使用右模糊<code>xxx%</code>代替左模糊或者全模糊</p>
<p>反例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select userId, name from user where user_id like &apos;%123&apos;;</span><br><span class="line">select userId, name from user where user_id like &apos;%123%&apos;;</span><br></pre></td></tr></table></figure></p>
<p>正例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select userId, name from user where user_id like &apos;123%&apos;;</span><br></pre></td></tr></table></figure></p>
<h3 id="5-避免SQL中对where字段进行函数转换或表达式计算"><a href="#5-避免SQL中对where字段进行函数转换或表达式计算" class="headerlink" title="5 避免SQL中对where字段进行函数转换或表达式计算"></a>5 避免SQL中对where字段进行函数转换或表达式计算</h3><p>反例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from employee where user_id + 1 = 15551;</span><br></pre></td></tr></table></figure></p>
<p>正例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from employee where user_id  = 15550;</span><br></pre></td></tr></table></figure></p>
<p>说明：</p>
<ol>
<li>将导致系统放弃使用索引而进行全表扫</li>
<li>其实在知道了有SQL优化器之后，我个人感觉这种普通的表达式转换应该可以提前进行处理再进行查询，这样一来就可以用到索引了，但是问题又来了，如果mysql优化器可以提前计算出结果，那么写sql语句的人也一定可以提前计算出结果，所以矛盾点在这个地方，导致5.7版本以前的此种情况都无法使用索引吧，未来可能会对其进行优化</li>
</ol>
<h3 id="6-超大分页场景解决方案-limit"><a href="#6-超大分页场景解决方案-limit" class="headerlink" title="6 超大分页场景解决方案(limit)"></a>6 超大分页场景解决方案(limit)</h3><p>我们日常做分页需求时，一般会用 limit 实现，但是当偏移量特别大的时候，查询效率就变得低下。</p>
<p>反例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select id, name, age from employee LIMIT 1000000, 10;</span><br></pre></td></tr></table></figure></p>
<p>正例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 方案一：返回上次查询的最大记录（偏移量）</span><br><span class="line">select id, name, age from employee id &gt; 1000000 limit 10;</span><br><span class="line"></span><br><span class="line">// 方案二：先通过索引查询需要的id</span><br><span class="line">select id, name, age from employee a, (select id from employee limit 1000000, 10) b where a.id = b.id;</span><br><span class="line"></span><br><span class="line">// 方案三：order by + 索引</span><br><span class="line">select id, name, age from employee order by id limit 1000000, 10</span><br></pre></td></tr></table></figure></p>
<p>说明：</p>
<ol>
<li>MySQL 并不是跳过 offset 行，而是取 offset+N 行，然后返回放弃前 offset 行，返回 N 行，那当 offset 特别大的时候，效率就非常的低下，要么控制返回的总页数，要么对超过特定阈值的页数进行 SQL 改写</li>
</ol>
<h3 id="7-尽量避免在where子句中使用-或-lt-gt-操作符，否则将引擎放弃使用索引而进行全表扫描。"><a href="#7-尽量避免在where子句中使用-或-lt-gt-操作符，否则将引擎放弃使用索引而进行全表扫描。" class="headerlink" title="7 尽量避免在where子句中使用!=或&lt;&gt;操作符，否则将引擎放弃使用索引而进行全表扫描。"></a>7 尽量避免在where子句中使用!=或&lt;&gt;操作符，否则将引擎放弃使用索引而进行全表扫描。</h3><p>反例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select age, name from user where age &lt;&gt; 18;</span><br></pre></td></tr></table></figure></p>
<p>正例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 可以考虑分开两条sql写</span><br><span class="line">select age, name from user where age &lt; 18;</span><br><span class="line">select age, name from user where age &gt; 18;</span><br></pre></td></tr></table></figure></p>
<p>说明：</p>
<ol>
<li>使用!=和&lt;&gt;很可能会让索引失效</li>
</ol>
<h3 id="8-对查询进行优化，应考虑在where及order-by涉及的列上建立索引，尽量避免全表扫描。"><a href="#8-对查询进行优化，应考虑在where及order-by涉及的列上建立索引，尽量避免全表扫描。" class="headerlink" title="8 对查询进行优化，应考虑在where及order by涉及的列上建立索引，尽量避免全表扫描。"></a>8 对查询进行优化，应考虑在where及order by涉及的列上建立索引，尽量避免全表扫描。</h3><p>对经常使用where和order by的字段加上索引</p>
<h3 id="9-where子句中考虑使用默认值代替null。"><a href="#9-where子句中考虑使用默认值代替null。" class="headerlink" title="9 where子句中考虑使用默认值代替null。"></a>9 where子句中考虑使用默认值代替null。</h3><p>反例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from user where age is not null;</span><br></pre></td></tr></table></figure></p>
<p>正例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 设置默认值为 0 </span><br><span class="line">select * from user where age &gt; 0;</span><br></pre></td></tr></table></figure></p>
<p>说明：</p>
<ol>
<li>并不是说使用了is null 或者 is not null 就会不走索引了，这个跟mysql版本以及查询成本都有关。</li>
<li>如果把null值，换成默认值，很多时候让走索引成为可能，同时，表达意思会相对清晰一点。</li>
</ol>
<h3 id="10-索引不宜太多，一般5个以内"><a href="#10-索引不宜太多，一般5个以内" class="headerlink" title="10 索引不宜太多，一般5个以内"></a>10 索引不宜太多，一般5个以内</h3><p>说明：</p>
<ol>
<li>索引并不是越多越好，索引虽然提高了查询的效率，但是也降低了插入和更新的效率。</li>
<li>insert或update时有可能会重建索引，所以建索引需要慎重考虑，视具体情况来定。</li>
<li>一个表的索引数最好不要超过5个，若太多需要考虑一些索引是否没有存在的必要。</li>
</ol>
<p>###　11 索引不适合建在有大量重复数据的字段上，如性别这类型数据库字段</p>
<p>说明：</p>
<ol>
<li>因为SQL优化器是根据表中数据量来进行查询优化的，如果索引列有大量重复数据，Mysql查询优化器推算发现不走索引的成本更低，很可能就放弃索引了。</li>
</ol>

        </div>

        
            <section class="post-copyright">
                
                    <p class="copyright-item">
                        <span>Author:</span>
                        <span>Ray Wong</span>
                    </p>
                
                
                
                

            </section>
        
        <section class="post-tags">
            <div>
                <span>Tag(s):</span>
                <span class="tag">
                    
                    
                        <a href="/tags/MySQL/"># MySQL</a>
                    
                        
                </span>
            </div>
            <div>
                <a href="javascript:window.history.back();">back</a>
                <span>· </span>
                <a href="/">home</a>
            </div>
        </section>
        <section class="post-nav">
            
                <a class="prev" rel="prev" href="/2020/05/24/Redis/">Redis类型及应用场景</a>
            
            
            <a class="next" rel="next" href="/2020/04/11/Http_WebSocket/">HTTP和WebSocket协议的区别</a>
            
        </section>


    </article>
</div>

        </div>
        <footer id="footer" class="footer">
    <div class="copyright">
        <span>© Ray Wong | Powered by <a href="https://hexo.io" target="_blank">Hexo</a> & <a href="https://github.com/Siricee/hexo-theme-Chic" target="_blank">Chic</a></span>
    </div>
</footer>

    </div>
</body>
</html>
