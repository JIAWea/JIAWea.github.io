<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Ray的博客</title>
  
  <subtitle>Keep coding...</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-10-17T03:17:27.053Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Ray Wong</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>HTTP报文理解</title>
    <link href="http://yoursite.com/2019/10/17/HttpMessages/"/>
    <id>http://yoursite.com/2019/10/17/HttpMessages/</id>
    <published>2019-10-17T02:06:47.000Z</published>
    <updated>2019-10-17T03:17:27.053Z</updated>
    
    <content type="html"><![CDATA[<p>HTTP报文携带着HTTP协议交互的信息，可以理解为它为搬东西的包裹，来搬运交换的信息。<br>其中有两种类型的报文，一是客户端发送的请求到服务器的HTTP报文叫做请求报文，二是服务器响应给客户端的叫响应报文。</p><a id="more"></a><h3 id="请求报文组成部分"><a href="#请求报文组成部分" class="headerlink" title="请求报文组成部分"></a>请求报文组成部分</h3><p><img src="/static/blogImg/HTTP_Messages.png" alt="avatar"></p><p>HTTP 报文大致可分为请求行、请求头、空行、请求主体四部分。</p><ul><li>请求行</li><li>请求头</li><li>空行</li><li>请求数据</li></ul><h3 id="请求报文"><a href="#请求报文" class="headerlink" title="请求报文"></a>请求报文</h3><p><strong>请求行</strong><br>组成：请求方式 + 请求URI + HTTP版本 + CR LF(换行)<br>HTTP请求是客户端发送的用于在服务器上启动操作的消息。它们的起始行包含三个元素，例如，GET /index.html HTTP/1.1。</p><p>HTTP协议的请求方法有GET、POST、HEAD、PUT、DELETE、OPTIONS、TRACE、CONNECT。</p><ul><li>GET: 请求目标通常是URL，或者协议，端口和域的绝对路径通常由请求上下文来表征。此请求目标的格式在不同的HTTP方法之间有所不同。有可能绝对路径，最后跟一个“？”和查询字符串。这是最常见的形式，称为原始形式，并且与GET，POST，HEAD和OPTIONS方法一起使用。如：GET /index.html?id=1 HTTP/1.1</li><li>POST: 对于不适合使用GET方式的情况（比如账号登录），可以使用POST方式，因为使用POST方法可以允许客户端给服务器提供信息较多。POST方法将请求参数封装在HTTP请求数据中，以“键：值”的形式出现，可以传输大量数据，这样POST方式对传送的数据大小没有限制，而且也不会显示在URL中。</li><li>HEAD: HEAD就像GET，只不过服务端接受到HEAD请求后只返回响应头，而不会发送响应内容。当我们只需要查看某个页面的状态的时候，使用HEAD是非常高效的，因为在传输的过程中省去了页面内容。</li></ul><p><strong>请求头部</strong><br><img src="/static/blogImg/HTTP_Request_Headers2.png" alt="avatar"></p><p>请求头部由键值对组成，每行一对，关键字和值用英文冒号“:”分隔。请求头部通知服务器有关于客户端请求的信息，典型的请求头有：</p><ul><li>User-Agent：产生请求的浏览器类型。</li><li>Accept：客户端可识别的内容类型列表。</li><li>Host：请求的主机名，允许多个域名同处一个IP地址，即虚拟主机。</li></ul><p><strong>空行</strong><br>最后一个请求头之后是一个空行，发送回车符和换行符，通知服务器以下不再有请求头。</p><p><strong>请求数据</strong><br>请求数据不在GET方法中使用，而是在POST方法中使用。POST方法适用于需要客户填写表单的场合。与请求数据相关的最常使用的请求头是<code>Content-Type</code>和<code>Content-Length</code>。</p><h3 id="响应报文"><a href="#响应报文" class="headerlink" title="响应报文"></a>响应报文</h3><p><strong>请求行</strong><br>组成：HTTP版本 + 状态码  + 状态码描述 + CR LF(换行)<br>响应报文结构与请求报文结构唯一的区别在于第一行中用状态信息代替了请求信息。状态行（status line）通过提供一个状态码来说明所请求的资源情况。</p><p>HTTP状态码被分为五大类:</p><ol><li>状态代码由服务器发出，以响应客户端对服务器的请求。</li><li>1xx（信息）：收到请求，继续处理</li><li>2xx（成功）：请求已成功接收，理解和接受</li><li>3xx（重定向）：为了完成指定的动作，必须接受进一步处理</li><li>4xx（客户端错误）：请求包含错误的语法或无法满足</li><li>5xx（服务器错误）：服务器不能正确执行一个正确的请求</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;HTTP报文携带着HTTP协议交互的信息，可以理解为它为搬东西的包裹，来搬运交换的信息。&lt;br&gt;其中有两种类型的报文，一是客户端发送的请求到服务器的HTTP报文叫做请求报文，二是服务器响应给客户端的叫响应报文。&lt;/p&gt;
    
    </summary>
    
    
      <category term="HTTP" scheme="http://yoursite.com/tags/HTTP/"/>
    
  </entry>
  
  <entry>
    <title>Python进阶用法</title>
    <link href="http://yoursite.com/2019/10/14/HiddenFeaturesOfPython/"/>
    <id>http://yoursite.com/2019/10/14/HiddenFeaturesOfPython/</id>
    <published>2019-10-14T02:58:14.000Z</published>
    <updated>2019-10-14T06:28:06.931Z</updated>
    
    <content type="html"><![CDATA[<p>使用Python来编写也有很长一段时间了，也想着如何优化自己的代码，随之也搜了一些问题。<br>其中印象比较深刻的就是stackoverflow上的一个问题解答了。</p><a id="more"></a><p>原文：<a href="https://stackoverflow.com/questions/101268/hidden-features-of-python" target="_blank" rel="noopener">Hidden features of Python</a></p><p><strong>Argument Unpacking</strong><br>可以使用 * 和 ** 分别将一个列表和一个字典解包为函数参数<br>如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">def draw_point(x, y):</span><br><span class="line"># do something</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">tuple = (6, 8)</span><br><span class="line">dir = &#123;&apos;x&apos;: 6, &apos;y&apos;: 8&#125;</span><br><span class="line"></span><br><span class="line">draw_point(*tuple)</span><br><span class="line">draw_point(**dir)</span><br></pre></td></tr></table></figure></p><p><strong>Decorators</strong><br>装饰器的作用就是在不需要修改原函数代码的前提下增加新的功能，在调用原函数的时候先执行装饰器，如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">def print_before_func(func):</span><br><span class="line">def wrapper(*args, **kwargs):</span><br><span class="line">print(&quot;print before func&quot;)</span><br><span class="line">return func(*args, **kwargs)</span><br><span class="line">return wrapper</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@print_befor_func</span><br><span class="line">def write(text):</span><br><span class="line">print(text)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">write(Hello world)</span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line">print before func</span><br><span class="line">Hello world</span><br></pre></td></tr></table></figure></p><p><strong>Dictionary default .get value</strong><br>字典中有一个<code>get()</code>方法。如果你使用<code>dict[&#39;key&#39;]</code>的方式而<code>key</code>不存在的话就会出现异常。使用<code>dict.get(&#39;key&#39;)</code>的话如果<code>key</code>不存在则只会返回<code>None</code>。当然<code>get()</code>方法提供了第二个参数，如果返回<code>None</code>则会返回第二个参数的值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">num = dict.get(&apos;num&apos;, 0)</span><br></pre></td></tr></table></figure></p><p><strong>Enumeration</strong><br>使用enumeration包住一个可迭代对象，它会将index和item绑在一起，返回一个enumeration对象，如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">a = [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;]</span><br><span class="line">for index, item in enumeration(a):</span><br><span class="line">print(index, item)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">···</span><br><span class="line">0 a</span><br><span class="line">1 b</span><br><span class="line">2 c</span><br><span class="line">3 d</span><br><span class="line">···</span><br></pre></td></tr></table></figure></p><p>在同时需要索引和值的时候很有用</p><p><strong>For/else</strong><br>语法如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">for i in foo:</span><br><span class="line">if i == 0:</span><br><span class="line">break</span><br><span class="line">else:</span><br><span class="line">print(&quot;it was never 0&quot;)</span><br></pre></td></tr></table></figure></p><p><code>else</code>代码块会在循环正常结束后执行，也就是说没用出现<code>break</code>时才会调用<code>else</code>代码块，上面代码等价于:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">found = False</span><br><span class="line">for i in foo:</span><br><span class="line">if i == 0:</span><br><span class="line">found = True</span><br><span class="line">break</span><br><span class="line"></span><br><span class="line">if not found:</span><br><span class="line">print(&quot;it was never 0&quot;)</span><br></pre></td></tr></table></figure></p><p>这个语法挺容易让人混淆的，所有在使用的时候最好是注释一下，以免被其他小伙伴搞错含义了。</p><p>上面的代码也等价于：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if any(i == 0 for i in foo):</span><br><span class="line">pass</span><br><span class="line">else:</span><br><span class="line">print(&quot;it was never 0&quot;)</span><br></pre></td></tr></table></figure></p><p><strong>Generator expressions</strong><br>假如你这样写：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x = (n for n in foo if bar(n))</span><br></pre></td></tr></table></figure></p><p>你将会得到一个生成器，并可以把它付给一个变量x。现在你可以像下面一样使用生成器：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">for n in x:</span><br><span class="line">print(n)</span><br></pre></td></tr></table></figure></p><p>这样做的好处就是节省内存了。你不需要中间存储，而如果像下面这样的话，则需要：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x = [n for n in foo if bar(n)]</span><br><span class="line"># 列表推导</span><br></pre></td></tr></table></figure></p><p>在某些情况下，这会导致极重要的速度提升。<br>你可以添加许多if语句到生成器的尾端，基本复制for循环嵌套：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; n = ((a,b) for a in range(0,2) for b in range(4,6))</span><br><span class="line">&gt;&gt;&gt; for i in n:</span><br><span class="line">...   print i </span><br><span class="line"></span><br><span class="line">(0, 4)</span><br><span class="line">(0, 5)</span><br><span class="line">(1, 4)</span><br><span class="line">(1, 5)</span><br></pre></td></tr></table></figure></p><p>使用生成器最大的好处就是节省内存了。因为每一个值只有在你需要的时候才会生成，而不像列表推导那样一次性生成所有的结果。</p><p><strong>List stepping</strong><br>切片操作符中的步长(step)参数。例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = [1,2,3,4,5]</span><br><span class="line">&gt;&gt;&gt; a[::2]  # iterate over the whole list in 2-increments</span><br><span class="line">[1,3,5]</span><br></pre></td></tr></table></figure></p><p>特殊例子<code>x[::-1]</code>对‘x反转’来说相当有用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; a[::-1]</span><br><span class="line">[5,4,3,2,1]</span><br></pre></td></tr></table></figure></p><p>当然，你可以使用<code>reversed()</code>函数来实现反转。<br>区别在于，reversed()返回一个迭代器，所以还需要一个额外的步骤来将结果转换成需要的对象类型。<br>这个特性在判断例如回文的时候灰常有用，一句话搞定<br><code>True if someseq == someseq[::-1] else False</code></p><p><strong>Named string formatting</strong><br>%-格式化接收一个字典（也适用于%i%s等）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; print &quot;The %(foo)s is %(bar)i.&quot; % &#123;&apos;foo&apos;: &apos;answer&apos;, &apos;bar&apos;:42&#125;</span><br><span class="line">The answer is 42.</span><br></pre></td></tr></table></figure></p><p><strong>try/except/else</strong><br>else语句块只有当try语句正常执行（也就是说，except语句未执行）的时候，才会执行。<br>finally则无论是否异常都会执行。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">try:</span><br><span class="line">     Normal execution block</span><br><span class="line">except A:</span><br><span class="line">     Exception A handle</span><br><span class="line">except B:</span><br><span class="line">     Exception B handle</span><br><span class="line">except:</span><br><span class="line">     Other exception handle</span><br><span class="line">else:</span><br><span class="line">     if no exception,get here</span><br><span class="line">finally:</span><br><span class="line">     this block will be excuted no matter how it goes above</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;使用Python来编写也有很长一段时间了，也想着如何优化自己的代码，随之也搜了一些问题。&lt;br&gt;其中印象比较深刻的就是stackoverflow上的一个问题解答了。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>告别GOPATH,使用go mod</title>
    <link href="http://yoursite.com/2019/09/25/go_mod/"/>
    <id>http://yoursite.com/2019/09/25/go_mod/</id>
    <published>2019-09-25T01:47:23.000Z</published>
    <updated>2019-10-14T07:18:56.323Z</updated>
    
    <content type="html"><![CDATA[<p>我们都知道在使用Golang时开发程序时都需要在 <code>GOPATH</code> 下面，这就非常不方便。如果你想放在磁盘上的其他地方，那么go mod将是你的“好伙伴”。</p><a id="more"></a><p>关于 go mod 的说明，可以参考：</p><ul><li><a href="https://roberto.selbach.ca/intro-to-go-modules/" target="_blank" rel="noopener">Introduction to Go Modules</a></li><li><a href="https://github.com/golang/go/wiki/Modules" target="_blank" rel="noopener">Go 1.11 Modules 官方说明文档</a></li></ul><h3 id="命令行说明"><a href="#命令行说明" class="headerlink" title="命令行说明"></a>命令行说明</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ go mod</span><br><span class="line">Go mod provides access to operations on modules.</span><br><span class="line">Note that support for modules is built into all the go commands,</span><br><span class="line">not just &apos;go mod&apos;. For example, day-to-day adding, removing, upgrading,</span><br><span class="line">and downgrading of dependencies should be done using &apos;go get&apos;.</span><br><span class="line">See &apos;go help modules&apos; for an overview of module functionality.</span><br><span class="line">Usage:</span><br><span class="line">go mod &lt;command&gt; [arguments]</span><br><span class="line">The commands are:</span><br><span class="line">download    download modules to local cache</span><br><span class="line">edit        edit go.mod from tools or scripts</span><br><span class="line">graph       print module requirement graph</span><br><span class="line">init        initialize new module in current directory</span><br><span class="line">tidy        add missing and remove unused modules </span><br><span class="line">vendor      make vendored copy of dependencies</span><br><span class="line">verify      verify dependencies have expected content  </span><br><span class="line">why         explain why packages or modules are needed </span><br><span class="line">Use &quot;go help mod &lt;command&gt;&quot; for more information about a command.</span><br></pre></td></tr></table></figure><ul><li>go mod download: 下载依赖的 module 到本地 cache</li><li>go mod edit: 编辑 go.mod</li><li>go mod graph: 打印模块依赖图</li><li>go mod init: 在当前目录下初始化 go.mod(就是会新建一个 go.mod 文件)</li><li>go mod tidy: 整理依赖关系，会添加丢失的 module，删除不需要的 module</li><li>go mod vender: 将依赖复制到 vendor 下</li><li>go mod verify: 校验依赖</li><li>go mod why: 解释为什么需要依赖</li></ul><p>执行命令<code>go mod verify</code>命令来检查当前模块的依赖是否全部下载下来，是否下载下来被修改过。如果所有的模块都没有被修改过，那么执行这条命令之后，会打印<code>all modules verified</code>。</p><h3 id="如果在项目中使用"><a href="#如果在项目中使用" class="headerlink" title="如果在项目中使用"></a>如果在项目中使用</h3><ol><li>版本：首先将你的Go版本更新到(&gt;=1.11)，这里将不介绍怎么更新</li><li>设置环境变量(1.12默认)：在你的项目目录下使用<code>set GO111MODULE=ON</code></li><li>执行<code>go mod init</code>在当前目录下生成一个<code>go.mod</code>文件，如果之前有生成过需要删除再初始化</li></ol><p>执行完上面步骤基本就完成了，运行下程序你会发现目录下多了一个<code>go.sum</code>文件，是用来记录所依赖的版本的锁定</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>使用<code>go mod</code>后你会发现在<code>GOPATH</code>下面的<code>pkg</code>目录会有一个<code>mod</code>目录，里面包含了项目需要的依赖包，这也是为什么不需要再<code>GOPATH</code>中开发程序也能使用的原因</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我们都知道在使用Golang时开发程序时都需要在 &lt;code&gt;GOPATH&lt;/code&gt; 下面，这就非常不方便。如果你想放在磁盘上的其他地方，那么go mod将是你的“好伙伴”。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Go" scheme="http://yoursite.com/tags/Go/"/>
    
      <category term="mod" scheme="http://yoursite.com/tags/mod/"/>
    
  </entry>
  
  <entry>
    <title>初识Python asyncio异步编程</title>
    <link href="http://yoursite.com/2019/09/23/asyncio/"/>
    <id>http://yoursite.com/2019/09/23/asyncio/</id>
    <published>2019-09-23T07:58:52.000Z</published>
    <updated>2019-10-14T07:20:09.816Z</updated>
    
    <content type="html"><![CDATA[<p>同步代码(synchrnous code)<br>我们都很熟悉，就是运行完一个步骤再运行下一个。要在同步代码里面实现”同时”运行多个任务，最简单也是最直观地方式就是运行多个 threads 或者多个 processes。<br><a id="more"></a><br>这个层次的『同时运行』多个任务，是操作系统协助完成的。 也就是操作系统的任务调度系统来决定什么时候运行这个任务，什么时候切换任务，你自己，作为一个应用层的程序员，是没办法进行干预的。</p><p>我相信你也已经听说了什么关于 thread 和 process 的抱怨：process 太重，thread 又要牵涉到很多头条的锁问题。尤其是对于一个 Python 开发者来说，由于GIL（全局解释器锁）的存在，多线程无法真正使用多核，如果你用多线程来运行计算型任务，速度会更慢。</p><p>异步编程与之不同的是，值使用一个进程，不使用 threads，但是也能实现”同时”运行多个任务（这里的任务其实就是函数）。</p><p>这些函数有一个非常 nice 的 feature：必要的可以暂停，把运行的权利交给其他函数。等到时机恰当，又可以恢复之前的状态继续运行。这听上去是不是有点像进程呢？可以暂停，可以恢复运行。只不过进程的调度是操作系统完成的，这些函数的调度是进程自己（或者说程序员你自己）完成的。这也就意味着这将省去了很多计算机的资源，因为进程的调度必然需要大量 syscall，而 syscall 是很昂贵的。</p><h3 id="一-定义一个简单的协程："><a href="#一-定义一个简单的协程：" class="headerlink" title="一 定义一个简单的协程："></a>一 定义一个简单的协程：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">import asyncio</span><br><span class="line">  </span><br><span class="line">async def execute(x):</span><br><span class="line">    print(&apos;Number:&apos;, x)</span><br><span class="line">    return x</span><br><span class="line">  </span><br><span class="line">coroutine = execute(1)</span><br><span class="line">print(&apos;Coroutine:&apos;, coroutine)</span><br><span class="line">print(&apos;After calling execute&apos;)</span><br><span class="line">  </span><br><span class="line">loop = asyncio.get_event_loop()</span><br><span class="line">task = loop.create_task(coroutine)</span><br><span class="line">print(&apos;Task:&apos;, task)</span><br><span class="line">loop.run_until_complete(task)</span><br><span class="line">print(&apos;Task:&apos;, task)</span><br><span class="line">print(&apos;After calling loop&apos;)</span><br></pre></td></tr></table></figure><p>print(‘Task Result:’, task.result())  这样也能查看task执行的结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Coroutine: &lt;coroutine object execute at 0x10e0f7830&gt;</span><br><span class="line">After calling execute</span><br><span class="line">Task: &lt;Task pending coro=&lt;execute() running at demo.py:4&gt;&gt;</span><br><span class="line">Number: 1</span><br><span class="line">Task: &lt;Task finished coro=&lt;execute() done, defined at demo.py:4&gt; result=1&gt;</span><br><span class="line">After calling loop</span><br></pre></td></tr></table></figure><p>我们使用 async 定义了一个 execute() 方法，方法接收一个数字参数，方法执行之后会打印这个数字。<br>随后我们直接调用了这个方法，然而这个方法并没有执行，而是返回了一个 coroutine 协程对象。</p><p>随后我们使用 get_event_loop() 方法创建了一个事件循环 loop，并调用了 loop 对象的 run_until_complete() 方法将协程注册到事件循环 loop 中，然后启动。最后我们才看到了 execute() 方法打印了输出结果。可见，async 定义的方法就会变成一个无法直接执行的 coroutine 对象，必须将其注册到事件循环中才可以执行。</p><p>我们也可以不使用task来运行，它里面相比 coroutine 对象多了运行状态，比如 running、finished 等，我们可以用这些状态来获取协程对象的执行情况。将 coroutine 对象传递给 run_until_complete() 方法的时候，实际上它进行了一个操作就是将 coroutine 封装成了 task 对象，如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">import asyncio</span><br><span class="line"></span><br><span class="line">async def execute(x):</span><br><span class="line">    print(&apos;Number:&apos;, x)</span><br><span class="line"></span><br><span class="line">coroutine = execute(1)</span><br><span class="line">print(&apos;Coroutine:&apos;, coroutine)</span><br><span class="line">print(&apos;After calling execute&apos;)</span><br><span class="line"></span><br><span class="line">loop = asyncio.get_event_loop()</span><br><span class="line">loop.run_until_complete(coroutine)</span><br><span class="line">print(&apos;After calling loop&apos;)</span><br></pre></td></tr></table></figure><p>查看了源码，正好可以验证上面这一观点：</p><p>run_until_complete()这个方法位于源码中的base_events.py，函数有句注释：<br>Run until the Future is done.If the argument is a coroutine, it is wrapped in a Task.</p><h3 id="二-发送网络请求结合aiohttp实现异步："><a href="#二-发送网络请求结合aiohttp实现异步：" class="headerlink" title="二 发送网络请求结合aiohttp实现异步："></a>二 发送网络请求结合aiohttp实现异步：</h3><p>我们用一个网络请求作为示例，这就是一个耗时等待的操作，因为我们请求网页之后需要等待页面响应并返回结果。耗时等待的操作一般都是 IO 操作，比如文件读取、网络请求等等。协程对于处理这种操作是有很大优势的，当遇到需要等待的情况的时候，程序可以暂时挂起，转而去执行其他的操作，从而避免一直等待一个程序而耗费过多的时间，充分利用资源。为了测试，我自己先通过flask 创建一个实验环境：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">from flask import Flask</span><br><span class="line">import time</span><br><span class="line">  </span><br><span class="line">app = Flask(__name__)</span><br><span class="line">  </span><br><span class="line">@app.route(&apos;/&apos;)</span><br><span class="line">def index():</span><br><span class="line">    time.sleep(3)</span><br><span class="line">    return &apos;Hello!&apos;</span><br><span class="line">  </span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    app.run(threaded=True)</span><br></pre></td></tr></table></figure></p><p>开始测试…<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">import asyncio</span><br><span class="line">import aiohttp</span><br><span class="line">import time</span><br><span class="line">  </span><br><span class="line">start = time.time()</span><br><span class="line">  </span><br><span class="line">async def get(url):</span><br><span class="line">    session = aiohttp.ClientSession()</span><br><span class="line">    response = await session.get(url)</span><br><span class="line">    result = await response.text()</span><br><span class="line">    session.close()</span><br><span class="line">    return result</span><br><span class="line">  </span><br><span class="line">async def request():</span><br><span class="line">    url = &apos;http://127.0.0.1:5000&apos;          # 访问flask搭建的服务器（睡眠3秒），模仿IO阻塞</span><br><span class="line">    print(&apos;Waiting for&apos;, url)</span><br><span class="line">    result = await get(url)</span><br><span class="line">    print(&apos;Get response from&apos;, url, &apos;Result:&apos;, result)</span><br><span class="line">  </span><br><span class="line">tasks = [asyncio.ensure_future(request()) for _ in range(5)]</span><br><span class="line">loop = asyncio.get_event_loop()</span><br><span class="line">loop.run_until_complete(asyncio.wait(tasks))</span><br><span class="line">  </span><br><span class="line">end = time.time()</span><br><span class="line">print(&apos;Cost time:&apos;, end - start)</span><br></pre></td></tr></table></figure></p><p>运行结果…<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Waiting for http://127.0.0.1:5000</span><br><span class="line">Waiting for http://127.0.0.1:5000</span><br><span class="line">Waiting for http://127.0.0.1:5000</span><br><span class="line">Waiting for http://127.0.0.1:5000</span><br><span class="line">Waiting for http://127.0.0.1:5000</span><br><span class="line">Get response from http://127.0.0.1:5000 Result: Hello!</span><br><span class="line">Get response from http://127.0.0.1:5000 Result: Hello!</span><br><span class="line">Get response from http://127.0.0.1:5000 Result: Hello!</span><br><span class="line">Get response from http://127.0.0.1:5000 Result: Hello!</span><br><span class="line">Get response from http://127.0.0.1:5000 Result: Hello!</span><br><span class="line">Cost time: 3.0199508666992188</span><br></pre></td></tr></table></figure></p><p>我们发现这次请求的耗时由 15 秒变成了 3 秒，耗时直接变成了原来的 1/5。</p><p>代码里面我们使用了 await，后面跟了 get() 方法，在执行这五个协程的时候，如果遇到了 await，那么就会将当前协程挂起，转而去执行其他的协程，直到其他的协程也挂起或执行完毕，再进行下一个协程的执行。</p><h2 id="二-总结"><a href="#二-总结" class="headerlink" title="二 总结"></a>二 总结</h2><p>协程”同时”运行多个任务的基础是函数可以暂停（await实际就是用到了yield）。上面的代码中使用到了 asyncio的 event_loop，它做的事情，本质上来说就是当函数暂停时，切换到下一个任务，当时机恰当（这个例子中是请求完成了）恢复函数让他继续运行（这有点像操作系统了）。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;同步代码(synchrnous code)&lt;br&gt;我们都很熟悉，就是运行完一个步骤再运行下一个。要在同步代码里面实现”同时”运行多个任务，最简单也是最直观地方式就是运行多个 threads 或者多个 processes。&lt;br&gt;
    
    </summary>
    
      <category term="Python" scheme="http://yoursite.com/categories/Python/"/>
    
    
      <category term="异步" scheme="http://yoursite.com/tags/%E5%BC%82%E6%AD%A5/"/>
    
      <category term="asyncio" scheme="http://yoursite.com/tags/asyncio/"/>
    
  </entry>
  
  <entry>
    <title>关于我</title>
    <link href="http://yoursite.com/2019/09/23/index/"/>
    <id>http://yoursite.com/2019/09/23/index/</id>
    <published>2019-09-23T01:47:23.000Z</published>
    <updated>2019-09-23T03:53:51.679Z</updated>
    
    <content type="html"><![CDATA[<p>记录学习的点点滴滴…</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;记录学习的点点滴滴…&lt;/p&gt;

      
    
    </summary>
    
    
      <category term="介绍" scheme="http://yoursite.com/tags/%E4%BB%8B%E7%BB%8D/"/>
    
  </entry>
  
</feed>
