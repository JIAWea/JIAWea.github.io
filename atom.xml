<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Ray的博客</title>
  
  <subtitle>Keep coding...</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-01-20T09:41:49.252Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Ray Wong</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>算法之链表</title>
    <link href="http://yoursite.com/2019/12/10/Algorithm-linked-list/"/>
    <id>http://yoursite.com/2019/12/10/Algorithm-linked-list/</id>
    <published>2019-12-10T04:01:36.000Z</published>
    <updated>2020-01-20T09:41:49.252Z</updated>
    
    <content type="html"><![CDATA[<h2 id="单向链表"><a href="#单向链表" class="headerlink" title="单向链表"></a>单向链表</h2><p>单向链表也叫单链表，是链表中最简单的一种形式，它的每个节点包含两个域，一个信息域（元素域）和一个链接域。这个链接指向链表中的下一个节点，而最后一个节点的链接域则指向一个空值。<br><a id="more"></a><br><img src="https://img-blog.csdnimg.cn/20191111093914440.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0pJQVdFQQ==,size_16,color_FFFFFF,t_70" alt="单向链表"></p><ul><li>表元素域elem用来存放具体的数据。</li><li>链接域next用来存放下一个节点的位置（python中的标识）</li><li>变量p指向链表的头节点（首节点）的位置，从p出发能找到表中的任意节点。</li></ul><p><strong>下面引用算法图解一书中的链表：</strong><br>链表中的元素可存储在内存的任何地方。<br><img src="https://img-blog.csdnimg.cn/20191111094236680.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0pJQVdFQQ==,size_16,color_FFFFFF,t_70" alt="链表在内存"><br>链表的每个元素都存储了下一个元素的地址，从而使一系列随机的内存地址串在一起。<br><img src="https://img-blog.csdnimg.cn/20191111094413665.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0pJQVdFQQ==,size_16,color_FFFFFF,t_70" alt="串在一起的链表"><br>这犹如寻宝游戏。你前往第一个地址，那里有一张纸条写着“下一个元素的地址为123”。因此，你前往地址123，那里又有一张纸条写着“下一个元素的地址为668”。在链表中添加元素很容易：只需将其放入内存，并将其地址存储到前一个元素中。</p><h2 id="链表与顺序表的对比"><a href="#链表与顺序表的对比" class="headerlink" title="链表与顺序表的对比"></a>链表与顺序表的对比</h2><p>链表失去了顺序表随机读取的优点，同时链表由于增加了结点的指针域，空间开销比较大，但对存储空间的使用要相对灵活。</p><p>链表与顺序表的各种操作复杂度如下所示：<br>操作| 链表|  顺序表<br>-|-|-<br>访问元素| O(n) | O(1) |<br>在头部插入/删除|  O(1)  | O(n) |<br>在尾部插入/删除| O(n) |  O(1)  |<br>在中间插入/删除| O(n) | O(n) |</p><p>注意虽然表面看起来复杂度都是 O(n)，但是链表和顺序表在插入和删除时进行的是完全不同的操作。链表的主要耗时操作是遍历查找，删除和插入操作本身的复杂度是O(1)。顺序表查找很快，主要耗时的操作是拷贝覆盖。因为除了目标元素在尾部的特殊情况，顺序表进行插入和删除时需要对操作点之后的所有元素进行前后移位操作，只能通过拷贝和覆盖的方法进行。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;单向链表&quot;&gt;&lt;a href=&quot;#单向链表&quot; class=&quot;headerlink&quot; title=&quot;单向链表&quot;&gt;&lt;/a&gt;单向链表&lt;/h2&gt;&lt;p&gt;单向链表也叫单链表，是链表中最简单的一种形式，它的每个节点包含两个域，一个信息域（元素域）和一个链接域。这个链接指向链表中的下一个节点，而最后一个节点的链接域则指向一个空值。&lt;br&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="链表" scheme="http://yoursite.com/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>Docker之数据卷volume</title>
    <link href="http://yoursite.com/2019/12/10/Docker-volume/"/>
    <id>http://yoursite.com/2019/12/10/Docker-volume/</id>
    <published>2019-12-10T03:48:02.000Z</published>
    <updated>2019-12-10T03:50:06.536Z</updated>
    
    <content type="html"><![CDATA[<p><strong>数据卷</strong><br>默认情况下，在容器内创建的所有文件都存储在可写容器层上。这意味着：</p><ul><li>当该容器不再存在时，数据将不会持久保存，并且如果另一个进程需要它，则可能很难从容器中取出数据。</li><li>容器的可写层与运行容器的主机紧密耦合。您不能轻易地将数据移动到其他地方。<a id="more"></a></li><li>写入容器的可写层需要 存储驱动程序来管理文件系统。存储驱动程序使用Linux内核提供联合文件系统。与使用直接写入主机文件系统的数据卷相比，这种额外的抽象降低了性能 。</li></ul><p>Docker为容器提供了两个选项来将文件存储在主机中，以便即使容器停止后文件也可以持久存储：</p><ul><li>bind mount（绑定安装）</li><li>volume（数据卷）</li></ul><h3 id="volume："><a href="#volume：" class="headerlink" title="volume："></a>volume：</h3><p>是一个可供一个或多个容器使用的特殊目录，它绕过 UFS，可以提供很多有用的特性：</p><ul><li>数据卷 可以在容器之间共享和重用</li><li>对 数据卷 的修改会立马生效</li><li>对 数据卷 的更新，不会影响镜像</li><li>数据卷 默认会一直存在，即使容器被删除</li></ul><h3 id="bind-mount："><a href="#bind-mount：" class="headerlink" title="bind mount："></a>bind mount：</h3><ul><li>文件或目录由主机上的完整路径引用。</li><li>该文件或目录不需要在Docker主机上已经存在。如果尚不存在，则按需创建。</li><li>性能非常好，但是它们依赖于具有特定目录结构的主机文件系统。</li></ul><p><strong>注意：可以通过容器中运行的进程来更改主机文件系统 ，包括创建，修改或删除重要的系统文件或目录，存在安全隐患</strong></p><h2 id="创建数据卷"><a href="#创建数据卷" class="headerlink" title="创建数据卷"></a>创建数据卷</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker volume create my-vol</span><br></pre></td></tr></table></figure><p>查看所有的 数据卷<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker volume ls</span><br><span class="line">local               my-vol</span><br></pre></td></tr></table></figure></p><p>在主机里使用以下命令可以查看指定 数据卷 的信息<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ docker volume inspect my-vol</span><br><span class="line"></span><br><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;Driver&quot;: &quot;local&quot;,</span><br><span class="line">        &quot;Labels&quot;: &#123;&#125;,</span><br><span class="line">        &quot;Mountpoint&quot;: &quot;/var/lib/docker/volumes/my-vol/_data&quot;,</span><br><span class="line">        &quot;Name&quot;: &quot;my-vol&quot;,</span><br><span class="line">        &quot;Options&quot;: &#123;&#125;,</span><br><span class="line">        &quot;Scope&quot;: &quot;local&quot;</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p><h3 id="查看数据卷的具体信息"><a href="#查看数据卷的具体信息" class="headerlink" title="查看数据卷的具体信息"></a>查看数据卷的具体信息</h3><p>在主机里使用以下命令可以查看 web 容器的信息<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">$ docker inspect web</span><br><span class="line">数据卷 信息在 &quot;Mounts&quot; Key 下面</span><br><span class="line"></span><br><span class="line">&quot;Mounts&quot;: [</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;Type&quot;: &quot;volume&quot;,</span><br><span class="line">        &quot;Name&quot;: &quot;my-vol&quot;,</span><br><span class="line">        &quot;Source&quot;: &quot;/var/lib/docker/volumes/my-vol/_data&quot;,</span><br><span class="line">        &quot;Destination&quot;: &quot;/app&quot;,</span><br><span class="line">        &quot;Driver&quot;: &quot;local&quot;,</span><br><span class="line">        &quot;Mode&quot;: &quot;&quot;,</span><br><span class="line">        &quot;RW&quot;: true,</span><br><span class="line">        &quot;Propagation&quot;: &quot;&quot;</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p><h3 id="启动一个挂载数据卷的容器"><a href="#启动一个挂载数据卷的容器" class="headerlink" title="启动一个挂载数据卷的容器"></a>启动一个挂载数据卷的容器</h3><p>在用 docker run 命令的时候，使用 <code>--mount</code> 标记或者直接使用<code>-v</code>来将 数据卷 挂载到容器里。在一次 docker run 中可以挂载多个 数据卷。</p><p>下面创建一个名为 web 的容器，并加载一个 数据卷 到容器的 /webapp 目录。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -d -P \</span><br><span class="line">    --name web \</span><br><span class="line">    # -v my-vol:/wepapp \</span><br><span class="line">    --mount source=my-vol,target=/webapp \</span><br><span class="line">    training/webapp \</span><br><span class="line">    python app.py</span><br></pre></td></tr></table></figure></p><h3 id="删除数据卷"><a href="#删除数据卷" class="headerlink" title="删除数据卷"></a>删除数据卷</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker volume rm my-vol</span><br></pre></td></tr></table></figure><p>数据卷 是被设计用来持久化数据的，它的生命周期独立于容器，Docker 不会在容器被删除后自动删除 数据卷，并且也不存在垃圾回收这样的机制来处理没有任何容器引用的 数据卷。如果需要在删除容器的同时移除数据卷。可以在删除容器的时候使用<code>docker rm -v</code> 这个命令。</p><p>无主的数据卷可能会占据很多空间，要清理请使用以下命令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker volume prune</span><br></pre></td></tr></table></figure></p><p>在删除容器的时候也可使用<code>-v</code>来删除数据卷或者在启动容器是加上<code>--rm</code>，如：</p><ul><li><code>docker rm -v 容器</code></li><li><code>docker run --rm</code></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;数据卷&lt;/strong&gt;&lt;br&gt;默认情况下，在容器内创建的所有文件都存储在可写容器层上。这意味着：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;当该容器不再存在时，数据将不会持久保存，并且如果另一个进程需要它，则可能很难从容器中取出数据。&lt;/li&gt;
&lt;li&gt;容器的可写层与运行容器的主机紧密耦合。您不能轻易地将数据移动到其他地方。
    
    </summary>
    
    
      <category term="Docker" scheme="http://yoursite.com/tags/Docker/"/>
    
      <category term="volume" scheme="http://yoursite.com/tags/volume/"/>
    
  </entry>
  
  <entry>
    <title>算法之顺序表</title>
    <link href="http://yoursite.com/2019/11/08/Algorithm-SeqList/"/>
    <id>http://yoursite.com/2019/11/08/Algorithm-SeqList/</id>
    <published>2019-11-08T02:49:50.000Z</published>
    <updated>2019-11-08T02:59:10.555Z</updated>
    
    <content type="html"><![CDATA[<h2 id="顺序表"><a href="#顺序表" class="headerlink" title="顺序表"></a>顺序表</h2><p>在程序中，经常需要将一组（通常是同为某个类型的）数据元素作为整体管理和使用，需要创建这种元素组，用变量记录它们，传进传出函数等。一组数据中包含的元素个数可能发生变化（可以增加或删除元素）。</p><p>对于这种需求，最简单的解决方案便是将这样一组元素看成一个序列，用元素在序列里的位置和顺序，表示实际应用中的某种有意义的信息，或者表示数据之间的某种关系。</p><a id="more"></a><p>这样的一组序列元素的组织形式，我们可以将其抽象为线性表。一个线性表是某类元素的一个集合，还记录着元素之间的一种顺序关系。线性表是最基本的数据结构之一，在实际程序中应用非常广泛，它还经常被用作更复杂的数据结构的实现基础。</p><p>根据线性表的实际存储方式，分为两种实现模型：</p><ul><li><strong>顺序表</strong>，将元素顺序地存放在一块连续的存储区里，元素间的顺序关系由它们的存储顺序自然表示。</li><li><strong>链表</strong>，将元素存放在通过链接构造起来的一系列存储块中。</li></ul><h2 id="顺序表的基本形式"><a href="#顺序表的基本形式" class="headerlink" title="顺序表的基本形式"></a>顺序表的基本形式</h2><p><img src="https://img-blog.csdnimg.cn/20191108094130855.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0pJQVdFQQ==,size_16,color_FFFFFF,t_70" alt="顺序表基本形式"><br>图a表示的是顺序表的基本形式，数据元素本身连续存储，每个元素所占的存储单元大小固定相同，元素的下标是其逻辑地址，而元素存储的物理地址（实际内存地址）可以通过存储区的起始地址Loc (e0)加上逻辑地址（第i个元素）与存储单元大小（c）的乘积计算而得，即：</p><p><strong>Loc(ei) = Loc(e0) + c*i</strong></p><p>故，访问指定元素时无需从头遍历，通过计算便可获得对应地址，其时间复杂度为<strong>O(1)</strong>。<br>如果元素的大小不统一（如Python中的一个列表中有多种数据类型：[1, “a”, 1.001]等），则须采用图b的元素外置的形式，将实际数据元素另行存储，而顺序表中各单元位置保存对应元素的地址信息（即链接）。由于每个链接所需的存储量相同，通过上述公式，可以计算出元素链接的存储位置，而后顺着链接找到实际存储的数据元素。<strong>注意，图b中的c不再是数据元素的大小，而是存储一个链接地址所需的存储量，这个量通常很小。</strong><br>图b这样的顺序表也被称为对实际数据的索引，这是最简单的索引结构。</p><h2 id="顺序表的结构与实现"><a href="#顺序表的结构与实现" class="headerlink" title="顺序表的结构与实现"></a>顺序表的结构与实现</h2><p><strong>顺序表的结构</strong><br><img src="https://img-blog.csdnimg.cn/20191108094457522.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0pJQVdFQQ==,size_16,color_FFFFFF,t_70" alt="顺序表的结构"><br>一个顺序表的完整信息包括两部分：</p><ul><li>一部分是表中的元素集合</li><li>另一部分是为实现正确操作而需记录的信息，即有关表的整体情况的信息，这部分信息主要包括元素存储区的容量和当前表中已有的元素个数两项。</li></ul><p><strong>顺序表的两种基本实现方式</strong><br><img src="https://img-blog.csdnimg.cn/2019110809464595.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0pJQVdFQQ==,size_16,color_FFFFFF,t_70" alt="顺序表两种基本实现方式"><br>图a为一体式结构，存储表信息的单元与元素存储区以连续的方式安排在一块存储区里，两部分数据的整体形成一个完整的顺序表对象。</p><p>一体式结构整体性强，易于管理。但是由于数据元素存储区域是表对象的一部分，顺序表创建后，元素存储区就固定了。</p><p>图b为分离式结构，表对象里只保存与整个表有关的信息（即容量和元素个数），实际数据元素存放在另一个独立的元素存储区里，通过链接与基本表对象关联。</p><p><strong>元素存储区替换</strong><br>一体式结构由于顺序表信息区与数据区连续存储在一起，所以若想更换数据区，则只能整体搬迁，即整个顺序表对象（指存储顺序表的结构信息的区域）改变了。</p><p>分离式结构若想更换数据区，只需将表信息区中的数据区链接地址更新即可，而该顺序表对象不变。</p><p><strong>元素存储区扩充</strong><br>采用分离式结构的顺序表，若将数据区更换为存储空间更大的区域，则可以在不改变表对象的前提下对其数据存储区进行了扩充，所有使用这个表的地方都不必修改。只要程序的运行环境（计算机系统）还有空闲存储，这种表结构就不会因为满了而导致操作无法进行。人们把采用这种技术实现的顺序表称为动态顺序表，因为其容量可以在使用中动态变化。</p><p>扩充的两种策略：</p><ul><li><p>每次扩充增加固定数目的存储位置，如每次扩充增加10个元素位置，这种策略可称为线性增长。<strong>特点：节省空间，但是扩充操作频繁，操作次数多。</strong></p></li><li><p>每次扩充容量加倍，如每次扩充增加一倍存储空间。<strong>特点：减少了扩充操作的执行次数，但可能会浪费空间资源。以空间换时间，推荐的方式。</strong></p></li></ul><h2 id="顺序表的操作"><a href="#顺序表的操作" class="headerlink" title="顺序表的操作"></a>顺序表的操作</h2><p><strong>增加元素</strong></p><ul><li><p>尾端加入元素，时间复杂度为O(1)</p></li><li><p>非保序的加入元素（不常见），时间复杂度为O(1)</p></li><li><p>保序的元素加入，时间复杂度为O(n)</p></li></ul><p><strong>删除元素</strong></p><ul><li><p>删除表尾元素，时间复杂度为O(1)</p></li><li><p>非保序的元素删除（不常见），时间复杂度为O(1)</p></li><li><p>保序的元素删除，时间复杂度为O(n)</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;顺序表&quot;&gt;&lt;a href=&quot;#顺序表&quot; class=&quot;headerlink&quot; title=&quot;顺序表&quot;&gt;&lt;/a&gt;顺序表&lt;/h2&gt;&lt;p&gt;在程序中，经常需要将一组（通常是同为某个类型的）数据元素作为整体管理和使用，需要创建这种元素组，用变量记录它们，传进传出函数等。一组数据中包含的元素个数可能发生变化（可以增加或删除元素）。&lt;/p&gt;
&lt;p&gt;对于这种需求，最简单的解决方案便是将这样一组元素看成一个序列，用元素在序列里的位置和顺序，表示实际应用中的某种有意义的信息，或者表示数据之间的某种关系。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="顺序表" scheme="http://yoursite.com/tags/%E9%A1%BA%E5%BA%8F%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>算法之时间复杂度</title>
    <link href="http://yoursite.com/2019/11/06/Algorithm-O/"/>
    <id>http://yoursite.com/2019/11/06/Algorithm-O/</id>
    <published>2019-11-06T02:25:36.000Z</published>
    <updated>2019-11-06T02:35:46.813Z</updated>
    
    <content type="html"><![CDATA[<h2 id="在了解时间复杂度之前，让我们来了解一下什么是算法？"><a href="#在了解时间复杂度之前，让我们来了解一下什么是算法？" class="headerlink" title="在了解时间复杂度之前，让我们来了解一下什么是算法？"></a>在了解时间复杂度之前，让我们来了解一下什么是算法？</h2><p>算法（Algorithm）是指解题方案的准确而完整的描述，是一系列解决问题的清晰指令（我的理解是一系列解决问题的步骤），算法代表着用系统的方法描述解决问题的策略机制。也就是说，能够对一定规范的输入，在有限时间内获得所要求的输出。不同的算法可能用不同的时间、空间或效率来完成同样的任务。</p><p>一个算法的优劣可以用空间复杂度与时间复杂度来衡量。</p><a id="more"></a><h3 id="算法的五大特性："><a href="#算法的五大特性：" class="headerlink" title="算法的五大特性："></a>算法的五大特性：</h3><p>输入：算法具有0个或多个输入<br>输出: 算法至少有1个或多个输出<br>有穷性: 算法在有限的步骤之后会自动结束而不会无限循环，并且每一个步骤可以在可接受的时间内完成<br>确定性：算法中的每一步都有确定的含义，不会出现二义性<br>可行性：算法的每一步都是可行的，也就是说每一步都能够执行有限的次数完成</p><p>不同的算法对执行程序的结果也许是一样的，但是执行时间和效率却有着很大的区别，下面让我们来看个例子：</p><p>问题：a + b + c = 100, a^2  + b^2 = c^2,请计算出所有符合的a, b, c结果。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">import time</span><br><span class="line"> </span><br><span class="line">start_time = time.time()</span><br><span class="line"> </span><br><span class="line"># 注意是三重循环</span><br><span class="line">for a in range(0, 1001):</span><br><span class="line">    for b in range(0, 1001):</span><br><span class="line">        for c in range(0, 1001):</span><br><span class="line">            if a**2 + b**2 == c**2 and a+b+c == 1000:</span><br><span class="line">                print(&quot;a, b, c: %d, %d, %d&quot; % (a, b, c))</span><br><span class="line"> </span><br><span class="line">end_time = time.time()</span><br><span class="line">print(&quot;time: %f&quot; % (end_time - start_time))</span><br><span class="line">print(&quot;finished!&quot;)</span><br></pre></td></tr></table></figure></p><p>结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a, b, c: 0, 500, 500</span><br><span class="line">a, b, c: 200, 375, 425</span><br><span class="line">a, b, c: 375, 200, 425</span><br><span class="line">a, b, c: 500, 0, 500</span><br><span class="line">time: 214.583347</span><br><span class="line">finished!</span><br></pre></td></tr></table></figure></p><p>程序执行完总共花费了214秒。我们再来看一个例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">import time</span><br><span class="line"> </span><br><span class="line">start_time = time.time()</span><br><span class="line"> </span><br><span class="line"># 注意是两重循环</span><br><span class="line">for a in range(0, 1001):</span><br><span class="line">    for b in range(0, 1001-a):</span><br><span class="line">        c = 1000 - a - b</span><br><span class="line">        if a**2 + b**2 == c**2:</span><br><span class="line">            print(&quot;a, b, c: %d, %d, %d&quot; % (a, b, c))</span><br><span class="line"> </span><br><span class="line">end_time = time.time()</span><br><span class="line">print(&quot;time: %f&quot; % (end_time - start_time))</span><br><span class="line">print(&quot;finished!&quot;)</span><br></pre></td></tr></table></figure></p><p>结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a, b, c: 0, 500, 500</span><br><span class="line">a, b, c: 200, 375, 425</span><br><span class="line">a, b, c: 375, 200, 425</span><br><span class="line">a, b, c: 500, 0, 500</span><br><span class="line">time: 0.182897</span><br><span class="line">finished!</span><br></pre></td></tr></table></figure></p><p>程序执行完总共花费了0.18秒，这对于第一种方法来说，无疑是一种很大的提升。所以说，算法的好坏对于程序来说是非常重要的。</p><p><strong>因此，我们可以得出一个结论：实现算法程序的执行时间可以反应出算法的效率，即算法的优劣。</strong></p><h2 id="单靠时间值绝对可信吗？"><a href="#单靠时间值绝对可信吗？" class="headerlink" title="单靠时间值绝对可信吗？"></a>单靠时间值绝对可信吗？</h2><p>假设我们将第二次尝试的算法程序运行在一台配置古老性能低下的计算机中，情况会如何？很可能运行的时间并不会比在我们的电脑中运行算法一的214.583347秒快多少。</p><p>单纯依靠运行的时间来比较算法的优劣并不一定是客观准确的！</p><p>程序的运行离不开计算机环境（包括硬件和操作系统），这些客观原因会影响程序运行的速度并反应在程序的执行时间上。那么如何才能客观的评判一个算法的优劣呢？</p><h2 id="时间复杂度与“大O记法”"><a href="#时间复杂度与“大O记法”" class="headerlink" title="时间复杂度与“大O记法”"></a>时间复杂度与“大O记法”</h2><p>我们假定计算机执行算法每一个基本操作的时间是固定的一个时间单位，那么有多少个基本操作就代表会花费多少时间单位。算然对于不同的机器环境而言，确切的单位时间是不同的，但是对于算法进行多少个基本操作（即花费多少时间单位）在规模数量级上却是相同的，由此可以忽略机器环境的影响而客观的反应算法的时间效率。</p><p>对于算法的时间效率，我们可以用“大O记法”来表示。</p><p>“大O记法”：对于单调的整数函数f，如果存在一个整数函数g和实常数c&gt;0，使得对于充分大的n总有f(n)&lt;=c*g(n)，就说函数g是f的一个渐近函数（忽略常数），记为f(n)=O(g(n))。也就是说，在趋向无穷的极限意义下，函数f的增长速度受到函数g的约束，亦即函数f与函数g的特征相似。</p><p><strong>时间复杂度：假设存在函数g，使得算法A处理规模为n的问题示例所用时间为T(n)=O(g(n))，则称O(g(n))为算法A的渐近时间复杂度，简称时间复杂度，记为T(n)</strong></p><h2 id="最坏时间复杂度"><a href="#最坏时间复杂度" class="headerlink" title="最坏时间复杂度"></a>最坏时间复杂度</h2><p>分析算法时，存在几种可能的考虑：</p><p>算法完成工作最少需要多少基本操作，即最优时间复杂度<br>算法完成工作最多需要多少基本操作，即最坏时间复杂度<br>算法完成工作平均需要多少基本操作，即平均时间复杂度<br>对于最优时间复杂度，其价值不大，因为它没有提供什么有用信息，其反映的只是最乐观最理想的情况，没有参考价值。</p><p>对于最坏时间复杂度，提供了一种保证，表明算法在此种程度的基本操作中一定能完成工作。</p><p>对于平均时间复杂度，是对算法的一个全面评价，因此它完整全面的反映了这个算法的性质。但另一方面，这种衡量并没有保证，不是每个计算都能在这个基本操作内完成。而且，对于平均情况的计算，也会因为应用算法的实例分布可能并不均匀而难以计算。</p><p>因此，我们主要关注算法的最坏情况，亦即最坏时间复杂度。</p><h2 id="算法分析"><a href="#算法分析" class="headerlink" title="算法分析"></a>算法分析</h2><p>1）上面第一个列子核心部分：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">for a in range(0, 1001):</span><br><span class="line">    for b in range(0, 1001):</span><br><span class="line">        for c in range(0, 1001):</span><br><span class="line">            if a**2 + b**2 == c**2 and a+b+c == 1000:</span><br><span class="line">                print(&quot;a, b, c: %d, %d, %d&quot; % (a, b, c))</span><br></pre></td></tr></table></figure></p><p>时间复杂度：<br><code>T(n) = O(n*n*n) = O(n3)</code></p><p>2）第二个例子核心部分：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">for a in range(0, 1001):</span><br><span class="line">    for b in range(0, 1001-a):</span><br><span class="line">        c = 1000 - a - b</span><br><span class="line">        if a**2 + b**2 == c**2:</span><br><span class="line">            print(&quot;a, b, c: %d, %d, %d&quot; % (a, b, c))</span><br></pre></td></tr></table></figure></p><p>时间复杂度：<br><code>T(n) = O(n*n*(1+1)) = O(n*n) = O(n2)</code></p><p>由此可见，我们尝试的第二种算法要比第一种算法的时间复杂度好多的。</p><h3 id="常见时间复杂度"><a href="#常见时间复杂度" class="headerlink" title="常见时间复杂度"></a>常见时间复杂度</h3><table><thead><tr><th style="text-align:center">执行次数函数举例</th><th style="text-align:center">阶</th><th style="text-align:center">非正式术语</th></tr></thead><tbody><tr><td style="text-align:center">12</td><td style="text-align:center">O(1)</td><td style="text-align:center">常数阶</td></tr><tr><td style="text-align:center">2n+3</td><td style="text-align:center">O(n)</td><td style="text-align:center">线性阶</td></tr><tr><td style="text-align:center">3n^2+2n+1</td><td style="text-align:center">O(n^2)</td><td style="text-align:center">平方阶</td></tr><tr><td style="text-align:center">5log2n+20</td><td style="text-align:center">O(logn)</td><td style="text-align:center">对数阶</td></tr><tr><td style="text-align:center">2n+3nlog2n+19</td><td style="text-align:center">O(nlogn)</td><td style="text-align:center">nlogn阶</td></tr><tr><td style="text-align:center">6n^3+2n^2+3n+4</td><td style="text-align:center">O(n^3)</td><td style="text-align:center">立方阶</td></tr><tr><td style="text-align:center">2^n    O(2n)</td><td style="text-align:center">O(2^n)</td><td style="text-align:center">指数阶</td></tr></tbody></table><h3 id="常见时间复杂度的关系"><a href="#常见时间复杂度的关系" class="headerlink" title="常见时间复杂度的关系"></a>常见时间复杂度的关系</h3><p><img src="/static/blogImg/algorithm_1.png" alt="avatar"></p><p>所消耗的时间从小到大<br>O(1) &lt; O(logn) &lt; O(n) &lt; O(nlogn) &lt; O(n2) &lt; O(n3) &lt; O(2n) &lt; O(n!) &lt; O(nn)</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;在了解时间复杂度之前，让我们来了解一下什么是算法？&quot;&gt;&lt;a href=&quot;#在了解时间复杂度之前，让我们来了解一下什么是算法？&quot; class=&quot;headerlink&quot; title=&quot;在了解时间复杂度之前，让我们来了解一下什么是算法？&quot;&gt;&lt;/a&gt;在了解时间复杂度之前，让我们来了解一下什么是算法？&lt;/h2&gt;&lt;p&gt;算法（Algorithm）是指解题方案的准确而完整的描述，是一系列解决问题的清晰指令（我的理解是一系列解决问题的步骤），算法代表着用系统的方法描述解决问题的策略机制。也就是说，能够对一定规范的输入，在有限时间内获得所要求的输出。不同的算法可能用不同的时间、空间或效率来完成同样的任务。&lt;/p&gt;
&lt;p&gt;一个算法的优劣可以用空间复杂度与时间复杂度来衡量。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="时间复杂度" scheme="http://yoursite.com/tags/%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/"/>
    
  </entry>
  
  <entry>
    <title>HTTP报文理解</title>
    <link href="http://yoursite.com/2019/10/17/HttpMessages/"/>
    <id>http://yoursite.com/2019/10/17/HttpMessages/</id>
    <published>2019-10-17T02:06:47.000Z</published>
    <updated>2019-10-17T03:17:27.053Z</updated>
    
    <content type="html"><![CDATA[<p>HTTP报文携带着HTTP协议交互的信息，可以理解为它为搬东西的包裹，来搬运交换的信息。<br>其中有两种类型的报文，一是客户端发送的请求到服务器的HTTP报文叫做请求报文，二是服务器响应给客户端的叫响应报文。</p><a id="more"></a><h3 id="请求报文组成部分"><a href="#请求报文组成部分" class="headerlink" title="请求报文组成部分"></a>请求报文组成部分</h3><p><img src="/static/blogImg/HTTP_Messages.png" alt="avatar"></p><p>HTTP 报文大致可分为请求行、请求头、空行、请求主体四部分。</p><ul><li>请求行</li><li>请求头</li><li>空行</li><li>请求数据</li></ul><h3 id="请求报文"><a href="#请求报文" class="headerlink" title="请求报文"></a>请求报文</h3><p><strong>请求行</strong><br>组成：请求方式 + 请求URI + HTTP版本 + CR LF(换行)<br>HTTP请求是客户端发送的用于在服务器上启动操作的消息。它们的起始行包含三个元素，例如，GET /index.html HTTP/1.1。</p><p>HTTP协议的请求方法有GET、POST、HEAD、PUT、DELETE、OPTIONS、TRACE、CONNECT。</p><ul><li>GET: 请求目标通常是URL，或者协议，端口和域的绝对路径通常由请求上下文来表征。此请求目标的格式在不同的HTTP方法之间有所不同。有可能绝对路径，最后跟一个“？”和查询字符串。这是最常见的形式，称为原始形式，并且与GET，POST，HEAD和OPTIONS方法一起使用。如：GET /index.html?id=1 HTTP/1.1</li><li>POST: 对于不适合使用GET方式的情况（比如账号登录），可以使用POST方式，因为使用POST方法可以允许客户端给服务器提供信息较多。POST方法将请求参数封装在HTTP请求数据中，以“键：值”的形式出现，可以传输大量数据，这样POST方式对传送的数据大小没有限制，而且也不会显示在URL中。</li><li>HEAD: HEAD就像GET，只不过服务端接受到HEAD请求后只返回响应头，而不会发送响应内容。当我们只需要查看某个页面的状态的时候，使用HEAD是非常高效的，因为在传输的过程中省去了页面内容。</li></ul><p><strong>请求头部</strong><br><img src="/static/blogImg/HTTP_Request_Headers2.png" alt="avatar"></p><p>请求头部由键值对组成，每行一对，关键字和值用英文冒号“:”分隔。请求头部通知服务器有关于客户端请求的信息，典型的请求头有：</p><ul><li>User-Agent：产生请求的浏览器类型。</li><li>Accept：客户端可识别的内容类型列表。</li><li>Host：请求的主机名，允许多个域名同处一个IP地址，即虚拟主机。</li></ul><p><strong>空行</strong><br>最后一个请求头之后是一个空行，发送回车符和换行符，通知服务器以下不再有请求头。</p><p><strong>请求数据</strong><br>请求数据不在GET方法中使用，而是在POST方法中使用。POST方法适用于需要客户填写表单的场合。与请求数据相关的最常使用的请求头是<code>Content-Type</code>和<code>Content-Length</code>。</p><h3 id="响应报文"><a href="#响应报文" class="headerlink" title="响应报文"></a>响应报文</h3><p><strong>请求行</strong><br>组成：HTTP版本 + 状态码  + 状态码描述 + CR LF(换行)<br>响应报文结构与请求报文结构唯一的区别在于第一行中用状态信息代替了请求信息。状态行（status line）通过提供一个状态码来说明所请求的资源情况。</p><p>HTTP状态码被分为五大类:</p><ol><li>状态代码由服务器发出，以响应客户端对服务器的请求。</li><li>1xx（信息）：收到请求，继续处理</li><li>2xx（成功）：请求已成功接收，理解和接受</li><li>3xx（重定向）：为了完成指定的动作，必须接受进一步处理</li><li>4xx（客户端错误）：请求包含错误的语法或无法满足</li><li>5xx（服务器错误）：服务器不能正确执行一个正确的请求</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;HTTP报文携带着HTTP协议交互的信息，可以理解为它为搬东西的包裹，来搬运交换的信息。&lt;br&gt;其中有两种类型的报文，一是客户端发送的请求到服务器的HTTP报文叫做请求报文，二是服务器响应给客户端的叫响应报文。&lt;/p&gt;
    
    </summary>
    
    
      <category term="HTTP" scheme="http://yoursite.com/tags/HTTP/"/>
    
  </entry>
  
  <entry>
    <title>Python进阶用法</title>
    <link href="http://yoursite.com/2019/10/14/HiddenFeaturesOfPython/"/>
    <id>http://yoursite.com/2019/10/14/HiddenFeaturesOfPython/</id>
    <published>2019-10-14T02:58:14.000Z</published>
    <updated>2019-10-14T06:28:06.931Z</updated>
    
    <content type="html"><![CDATA[<p>使用Python来编写也有很长一段时间了，也想着如何优化自己的代码，随之也搜了一些问题。<br>其中印象比较深刻的就是stackoverflow上的一个问题解答了。</p><a id="more"></a><p>原文：<a href="https://stackoverflow.com/questions/101268/hidden-features-of-python" target="_blank" rel="noopener">Hidden features of Python</a></p><p><strong>Argument Unpacking</strong><br>可以使用 * 和 ** 分别将一个列表和一个字典解包为函数参数<br>如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">def draw_point(x, y):</span><br><span class="line"># do something</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">tuple = (6, 8)</span><br><span class="line">dir = &#123;&apos;x&apos;: 6, &apos;y&apos;: 8&#125;</span><br><span class="line"></span><br><span class="line">draw_point(*tuple)</span><br><span class="line">draw_point(**dir)</span><br></pre></td></tr></table></figure></p><p><strong>Decorators</strong><br>装饰器的作用就是在不需要修改原函数代码的前提下增加新的功能，在调用原函数的时候先执行装饰器，如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">def print_before_func(func):</span><br><span class="line">def wrapper(*args, **kwargs):</span><br><span class="line">print(&quot;print before func&quot;)</span><br><span class="line">return func(*args, **kwargs)</span><br><span class="line">return wrapper</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@print_befor_func</span><br><span class="line">def write(text):</span><br><span class="line">print(text)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">write(Hello world)</span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line">print before func</span><br><span class="line">Hello world</span><br></pre></td></tr></table></figure></p><p><strong>Dictionary default .get value</strong><br>字典中有一个<code>get()</code>方法。如果你使用<code>dict[&#39;key&#39;]</code>的方式而<code>key</code>不存在的话就会出现异常。使用<code>dict.get(&#39;key&#39;)</code>的话如果<code>key</code>不存在则只会返回<code>None</code>。当然<code>get()</code>方法提供了第二个参数，如果返回<code>None</code>则会返回第二个参数的值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">num = dict.get(&apos;num&apos;, 0)</span><br></pre></td></tr></table></figure></p><p><strong>Enumeration</strong><br>使用enumeration包住一个可迭代对象，它会将index和item绑在一起，返回一个enumeration对象，如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">a = [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;]</span><br><span class="line">for index, item in enumeration(a):</span><br><span class="line">print(index, item)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">···</span><br><span class="line">0 a</span><br><span class="line">1 b</span><br><span class="line">2 c</span><br><span class="line">3 d</span><br><span class="line">···</span><br></pre></td></tr></table></figure></p><p>在同时需要索引和值的时候很有用</p><p><strong>For/else</strong><br>语法如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">for i in foo:</span><br><span class="line">if i == 0:</span><br><span class="line">break</span><br><span class="line">else:</span><br><span class="line">print(&quot;it was never 0&quot;)</span><br></pre></td></tr></table></figure></p><p><code>else</code>代码块会在循环正常结束后执行，也就是说没用出现<code>break</code>时才会调用<code>else</code>代码块，上面代码等价于:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">found = False</span><br><span class="line">for i in foo:</span><br><span class="line">if i == 0:</span><br><span class="line">found = True</span><br><span class="line">break</span><br><span class="line"></span><br><span class="line">if not found:</span><br><span class="line">print(&quot;it was never 0&quot;)</span><br></pre></td></tr></table></figure></p><p>这个语法挺容易让人混淆的，所有在使用的时候最好是注释一下，以免被其他小伙伴搞错含义了。</p><p>上面的代码也等价于：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if any(i == 0 for i in foo):</span><br><span class="line">pass</span><br><span class="line">else:</span><br><span class="line">print(&quot;it was never 0&quot;)</span><br></pre></td></tr></table></figure></p><p><strong>Generator expressions</strong><br>假如你这样写：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x = (n for n in foo if bar(n))</span><br></pre></td></tr></table></figure></p><p>你将会得到一个生成器，并可以把它付给一个变量x。现在你可以像下面一样使用生成器：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">for n in x:</span><br><span class="line">print(n)</span><br></pre></td></tr></table></figure></p><p>这样做的好处就是节省内存了。你不需要中间存储，而如果像下面这样的话，则需要：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x = [n for n in foo if bar(n)]</span><br><span class="line"># 列表推导</span><br></pre></td></tr></table></figure></p><p>在某些情况下，这会导致极重要的速度提升。<br>你可以添加许多if语句到生成器的尾端，基本复制for循环嵌套：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; n = ((a,b) for a in range(0,2) for b in range(4,6))</span><br><span class="line">&gt;&gt;&gt; for i in n:</span><br><span class="line">...   print i </span><br><span class="line"></span><br><span class="line">(0, 4)</span><br><span class="line">(0, 5)</span><br><span class="line">(1, 4)</span><br><span class="line">(1, 5)</span><br></pre></td></tr></table></figure></p><p>使用生成器最大的好处就是节省内存了。因为每一个值只有在你需要的时候才会生成，而不像列表推导那样一次性生成所有的结果。</p><p><strong>List stepping</strong><br>切片操作符中的步长(step)参数。例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = [1,2,3,4,5]</span><br><span class="line">&gt;&gt;&gt; a[::2]  # iterate over the whole list in 2-increments</span><br><span class="line">[1,3,5]</span><br></pre></td></tr></table></figure></p><p>特殊例子<code>x[::-1]</code>对‘x反转’来说相当有用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; a[::-1]</span><br><span class="line">[5,4,3,2,1]</span><br></pre></td></tr></table></figure></p><p>当然，你可以使用<code>reversed()</code>函数来实现反转。<br>区别在于，reversed()返回一个迭代器，所以还需要一个额外的步骤来将结果转换成需要的对象类型。<br>这个特性在判断例如回文的时候灰常有用，一句话搞定<br><code>True if someseq == someseq[::-1] else False</code></p><p><strong>Named string formatting</strong><br>%-格式化接收一个字典（也适用于%i%s等）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; print &quot;The %(foo)s is %(bar)i.&quot; % &#123;&apos;foo&apos;: &apos;answer&apos;, &apos;bar&apos;:42&#125;</span><br><span class="line">The answer is 42.</span><br></pre></td></tr></table></figure></p><p><strong>try/except/else</strong><br>else语句块只有当try语句正常执行（也就是说，except语句未执行）的时候，才会执行。<br>finally则无论是否异常都会执行。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">try:</span><br><span class="line">     Normal execution block</span><br><span class="line">except A:</span><br><span class="line">     Exception A handle</span><br><span class="line">except B:</span><br><span class="line">     Exception B handle</span><br><span class="line">except:</span><br><span class="line">     Other exception handle</span><br><span class="line">else:</span><br><span class="line">     if no exception,get here</span><br><span class="line">finally:</span><br><span class="line">     this block will be excuted no matter how it goes above</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;使用Python来编写也有很长一段时间了，也想着如何优化自己的代码，随之也搜了一些问题。&lt;br&gt;其中印象比较深刻的就是stackoverflow上的一个问题解答了。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>告别GOPATH,使用go mod</title>
    <link href="http://yoursite.com/2019/09/25/go_mod/"/>
    <id>http://yoursite.com/2019/09/25/go_mod/</id>
    <published>2019-09-25T01:47:23.000Z</published>
    <updated>2019-10-14T07:18:56.323Z</updated>
    
    <content type="html"><![CDATA[<p>我们都知道在使用Golang时开发程序时都需要在 <code>GOPATH</code> 下面，这就非常不方便。如果你想放在磁盘上的其他地方，那么go mod将是你的“好伙伴”。</p><a id="more"></a><p>关于 go mod 的说明，可以参考：</p><ul><li><a href="https://roberto.selbach.ca/intro-to-go-modules/" target="_blank" rel="noopener">Introduction to Go Modules</a></li><li><a href="https://github.com/golang/go/wiki/Modules" target="_blank" rel="noopener">Go 1.11 Modules 官方说明文档</a></li></ul><h3 id="命令行说明"><a href="#命令行说明" class="headerlink" title="命令行说明"></a>命令行说明</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ go mod</span><br><span class="line">Go mod provides access to operations on modules.</span><br><span class="line">Note that support for modules is built into all the go commands,</span><br><span class="line">not just &apos;go mod&apos;. For example, day-to-day adding, removing, upgrading,</span><br><span class="line">and downgrading of dependencies should be done using &apos;go get&apos;.</span><br><span class="line">See &apos;go help modules&apos; for an overview of module functionality.</span><br><span class="line">Usage:</span><br><span class="line">go mod &lt;command&gt; [arguments]</span><br><span class="line">The commands are:</span><br><span class="line">download    download modules to local cache</span><br><span class="line">edit        edit go.mod from tools or scripts</span><br><span class="line">graph       print module requirement graph</span><br><span class="line">init        initialize new module in current directory</span><br><span class="line">tidy        add missing and remove unused modules </span><br><span class="line">vendor      make vendored copy of dependencies</span><br><span class="line">verify      verify dependencies have expected content  </span><br><span class="line">why         explain why packages or modules are needed </span><br><span class="line">Use &quot;go help mod &lt;command&gt;&quot; for more information about a command.</span><br></pre></td></tr></table></figure><ul><li>go mod download: 下载依赖的 module 到本地 cache</li><li>go mod edit: 编辑 go.mod</li><li>go mod graph: 打印模块依赖图</li><li>go mod init: 在当前目录下初始化 go.mod(就是会新建一个 go.mod 文件)</li><li>go mod tidy: 整理依赖关系，会添加丢失的 module，删除不需要的 module</li><li>go mod vender: 将依赖复制到 vendor 下</li><li>go mod verify: 校验依赖</li><li>go mod why: 解释为什么需要依赖</li></ul><p>执行命令<code>go mod verify</code>命令来检查当前模块的依赖是否全部下载下来，是否下载下来被修改过。如果所有的模块都没有被修改过，那么执行这条命令之后，会打印<code>all modules verified</code>。</p><h3 id="如果在项目中使用"><a href="#如果在项目中使用" class="headerlink" title="如果在项目中使用"></a>如果在项目中使用</h3><ol><li>版本：首先将你的Go版本更新到(&gt;=1.11)，这里将不介绍怎么更新</li><li>设置环境变量(1.12默认)：在你的项目目录下使用<code>set GO111MODULE=ON</code></li><li>执行<code>go mod init</code>在当前目录下生成一个<code>go.mod</code>文件，如果之前有生成过需要删除再初始化</li></ol><p>执行完上面步骤基本就完成了，运行下程序你会发现目录下多了一个<code>go.sum</code>文件，是用来记录所依赖的版本的锁定</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>使用<code>go mod</code>后你会发现在<code>GOPATH</code>下面的<code>pkg</code>目录会有一个<code>mod</code>目录，里面包含了项目需要的依赖包，这也是为什么不需要再<code>GOPATH</code>中开发程序也能使用的原因</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我们都知道在使用Golang时开发程序时都需要在 &lt;code&gt;GOPATH&lt;/code&gt; 下面，这就非常不方便。如果你想放在磁盘上的其他地方，那么go mod将是你的“好伙伴”。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Go" scheme="http://yoursite.com/tags/Go/"/>
    
      <category term="mod" scheme="http://yoursite.com/tags/mod/"/>
    
  </entry>
  
  <entry>
    <title>初识Python asyncio异步编程</title>
    <link href="http://yoursite.com/2019/09/23/asyncio/"/>
    <id>http://yoursite.com/2019/09/23/asyncio/</id>
    <published>2019-09-23T07:58:52.000Z</published>
    <updated>2019-10-14T07:20:09.816Z</updated>
    
    <content type="html"><![CDATA[<p>同步代码(synchrnous code)<br>我们都很熟悉，就是运行完一个步骤再运行下一个。要在同步代码里面实现”同时”运行多个任务，最简单也是最直观地方式就是运行多个 threads 或者多个 processes。<br><a id="more"></a><br>这个层次的『同时运行』多个任务，是操作系统协助完成的。 也就是操作系统的任务调度系统来决定什么时候运行这个任务，什么时候切换任务，你自己，作为一个应用层的程序员，是没办法进行干预的。</p><p>我相信你也已经听说了什么关于 thread 和 process 的抱怨：process 太重，thread 又要牵涉到很多头条的锁问题。尤其是对于一个 Python 开发者来说，由于GIL（全局解释器锁）的存在，多线程无法真正使用多核，如果你用多线程来运行计算型任务，速度会更慢。</p><p>异步编程与之不同的是，值使用一个进程，不使用 threads，但是也能实现”同时”运行多个任务（这里的任务其实就是函数）。</p><p>这些函数有一个非常 nice 的 feature：必要的可以暂停，把运行的权利交给其他函数。等到时机恰当，又可以恢复之前的状态继续运行。这听上去是不是有点像进程呢？可以暂停，可以恢复运行。只不过进程的调度是操作系统完成的，这些函数的调度是进程自己（或者说程序员你自己）完成的。这也就意味着这将省去了很多计算机的资源，因为进程的调度必然需要大量 syscall，而 syscall 是很昂贵的。</p><h3 id="一-定义一个简单的协程："><a href="#一-定义一个简单的协程：" class="headerlink" title="一 定义一个简单的协程："></a>一 定义一个简单的协程：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">import asyncio</span><br><span class="line">  </span><br><span class="line">async def execute(x):</span><br><span class="line">    print(&apos;Number:&apos;, x)</span><br><span class="line">    return x</span><br><span class="line">  </span><br><span class="line">coroutine = execute(1)</span><br><span class="line">print(&apos;Coroutine:&apos;, coroutine)</span><br><span class="line">print(&apos;After calling execute&apos;)</span><br><span class="line">  </span><br><span class="line">loop = asyncio.get_event_loop()</span><br><span class="line">task = loop.create_task(coroutine)</span><br><span class="line">print(&apos;Task:&apos;, task)</span><br><span class="line">loop.run_until_complete(task)</span><br><span class="line">print(&apos;Task:&apos;, task)</span><br><span class="line">print(&apos;After calling loop&apos;)</span><br></pre></td></tr></table></figure><p>print(‘Task Result:’, task.result())  这样也能查看task执行的结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Coroutine: &lt;coroutine object execute at 0x10e0f7830&gt;</span><br><span class="line">After calling execute</span><br><span class="line">Task: &lt;Task pending coro=&lt;execute() running at demo.py:4&gt;&gt;</span><br><span class="line">Number: 1</span><br><span class="line">Task: &lt;Task finished coro=&lt;execute() done, defined at demo.py:4&gt; result=1&gt;</span><br><span class="line">After calling loop</span><br></pre></td></tr></table></figure><p>我们使用 async 定义了一个 execute() 方法，方法接收一个数字参数，方法执行之后会打印这个数字。<br>随后我们直接调用了这个方法，然而这个方法并没有执行，而是返回了一个 coroutine 协程对象。</p><p>随后我们使用 get_event_loop() 方法创建了一个事件循环 loop，并调用了 loop 对象的 run_until_complete() 方法将协程注册到事件循环 loop 中，然后启动。最后我们才看到了 execute() 方法打印了输出结果。可见，async 定义的方法就会变成一个无法直接执行的 coroutine 对象，必须将其注册到事件循环中才可以执行。</p><p>我们也可以不使用task来运行，它里面相比 coroutine 对象多了运行状态，比如 running、finished 等，我们可以用这些状态来获取协程对象的执行情况。将 coroutine 对象传递给 run_until_complete() 方法的时候，实际上它进行了一个操作就是将 coroutine 封装成了 task 对象，如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">import asyncio</span><br><span class="line"></span><br><span class="line">async def execute(x):</span><br><span class="line">    print(&apos;Number:&apos;, x)</span><br><span class="line"></span><br><span class="line">coroutine = execute(1)</span><br><span class="line">print(&apos;Coroutine:&apos;, coroutine)</span><br><span class="line">print(&apos;After calling execute&apos;)</span><br><span class="line"></span><br><span class="line">loop = asyncio.get_event_loop()</span><br><span class="line">loop.run_until_complete(coroutine)</span><br><span class="line">print(&apos;After calling loop&apos;)</span><br></pre></td></tr></table></figure><p>查看了源码，正好可以验证上面这一观点：</p><p>run_until_complete()这个方法位于源码中的base_events.py，函数有句注释：<br>Run until the Future is done.If the argument is a coroutine, it is wrapped in a Task.</p><h3 id="二-发送网络请求结合aiohttp实现异步："><a href="#二-发送网络请求结合aiohttp实现异步：" class="headerlink" title="二 发送网络请求结合aiohttp实现异步："></a>二 发送网络请求结合aiohttp实现异步：</h3><p>我们用一个网络请求作为示例，这就是一个耗时等待的操作，因为我们请求网页之后需要等待页面响应并返回结果。耗时等待的操作一般都是 IO 操作，比如文件读取、网络请求等等。协程对于处理这种操作是有很大优势的，当遇到需要等待的情况的时候，程序可以暂时挂起，转而去执行其他的操作，从而避免一直等待一个程序而耗费过多的时间，充分利用资源。为了测试，我自己先通过flask 创建一个实验环境：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">from flask import Flask</span><br><span class="line">import time</span><br><span class="line">  </span><br><span class="line">app = Flask(__name__)</span><br><span class="line">  </span><br><span class="line">@app.route(&apos;/&apos;)</span><br><span class="line">def index():</span><br><span class="line">    time.sleep(3)</span><br><span class="line">    return &apos;Hello!&apos;</span><br><span class="line">  </span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    app.run(threaded=True)</span><br></pre></td></tr></table></figure></p><p>开始测试…<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">import asyncio</span><br><span class="line">import aiohttp</span><br><span class="line">import time</span><br><span class="line">  </span><br><span class="line">start = time.time()</span><br><span class="line">  </span><br><span class="line">async def get(url):</span><br><span class="line">    session = aiohttp.ClientSession()</span><br><span class="line">    response = await session.get(url)</span><br><span class="line">    result = await response.text()</span><br><span class="line">    session.close()</span><br><span class="line">    return result</span><br><span class="line">  </span><br><span class="line">async def request():</span><br><span class="line">    url = &apos;http://127.0.0.1:5000&apos;          # 访问flask搭建的服务器（睡眠3秒），模仿IO阻塞</span><br><span class="line">    print(&apos;Waiting for&apos;, url)</span><br><span class="line">    result = await get(url)</span><br><span class="line">    print(&apos;Get response from&apos;, url, &apos;Result:&apos;, result)</span><br><span class="line">  </span><br><span class="line">tasks = [asyncio.ensure_future(request()) for _ in range(5)]</span><br><span class="line">loop = asyncio.get_event_loop()</span><br><span class="line">loop.run_until_complete(asyncio.wait(tasks))</span><br><span class="line">  </span><br><span class="line">end = time.time()</span><br><span class="line">print(&apos;Cost time:&apos;, end - start)</span><br></pre></td></tr></table></figure></p><p>运行结果…<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Waiting for http://127.0.0.1:5000</span><br><span class="line">Waiting for http://127.0.0.1:5000</span><br><span class="line">Waiting for http://127.0.0.1:5000</span><br><span class="line">Waiting for http://127.0.0.1:5000</span><br><span class="line">Waiting for http://127.0.0.1:5000</span><br><span class="line">Get response from http://127.0.0.1:5000 Result: Hello!</span><br><span class="line">Get response from http://127.0.0.1:5000 Result: Hello!</span><br><span class="line">Get response from http://127.0.0.1:5000 Result: Hello!</span><br><span class="line">Get response from http://127.0.0.1:5000 Result: Hello!</span><br><span class="line">Get response from http://127.0.0.1:5000 Result: Hello!</span><br><span class="line">Cost time: 3.0199508666992188</span><br></pre></td></tr></table></figure></p><p>我们发现这次请求的耗时由 15 秒变成了 3 秒，耗时直接变成了原来的 1/5。</p><p>代码里面我们使用了 await，后面跟了 get() 方法，在执行这五个协程的时候，如果遇到了 await，那么就会将当前协程挂起，转而去执行其他的协程，直到其他的协程也挂起或执行完毕，再进行下一个协程的执行。</p><h2 id="二-总结"><a href="#二-总结" class="headerlink" title="二 总结"></a>二 总结</h2><p>协程”同时”运行多个任务的基础是函数可以暂停（await实际就是用到了yield）。上面的代码中使用到了 asyncio的 event_loop，它做的事情，本质上来说就是当函数暂停时，切换到下一个任务，当时机恰当（这个例子中是请求完成了）恢复函数让他继续运行（这有点像操作系统了）。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;同步代码(synchrnous code)&lt;br&gt;我们都很熟悉，就是运行完一个步骤再运行下一个。要在同步代码里面实现”同时”运行多个任务，最简单也是最直观地方式就是运行多个 threads 或者多个 processes。&lt;br&gt;
    
    </summary>
    
      <category term="Python" scheme="http://yoursite.com/categories/Python/"/>
    
    
      <category term="异步" scheme="http://yoursite.com/tags/%E5%BC%82%E6%AD%A5/"/>
    
      <category term="asyncio" scheme="http://yoursite.com/tags/asyncio/"/>
    
  </entry>
  
  <entry>
    <title>关于我</title>
    <link href="http://yoursite.com/2019/09/23/index/"/>
    <id>http://yoursite.com/2019/09/23/index/</id>
    <published>2019-09-23T01:47:23.000Z</published>
    <updated>2020-01-15T01:36:24.292Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;2018年毕业于惠州经济职业技术学院，计算机网络专业。喜欢学习新事物，挑战自己。<br><a id="more"></a><br>&emsp;&emsp;总结在大学的时光还是挺不错了，虽然是一个专科学校，身边的朋友都说以你的分数在报考志愿的时候应该选更好的学校，但我并不觉得因此感到失望。担任过班级学习委员，进入校青年志愿者，拿了两年的国家励志奖学金，自学拿到了软考的网络管理员，CET-4等等。因为在学校也算是经历了很多东西，学习专业知识，参加各种活动，上台演讲等,总的来说还是比较充实。</p><p>&emsp;&emsp;17年9月实习到现在是担任Python全栈开发的工作，回头看看当时从小白到现在对技术上的认知（虽然现在也是菜鸡..），还是学习到了不少东西。今年3月份换了新的公司，在工作几个月后，接触到了Golang，在Github上面看文档动手用Golang做了一个博客。领导知道我会用Golang了以后，让我把公司的一个云盘的服务用Golang重构了。对学技术的人来说这也是好事，毕竟能把自己学到的知识用在了工作上，也算是加深对该知识的了解。</p><p>&emsp;&emsp;关于写博客的原因是想记录一下自己学习历程，踩过的一些坑，不断地提升自己的知识，做一个Geek。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;2018年毕业于惠州经济职业技术学院，计算机网络专业。喜欢学习新事物，挑战自己。&lt;br&gt;
    
    </summary>
    
    
      <category term="介绍" scheme="http://yoursite.com/tags/%E4%BB%8B%E7%BB%8D/"/>
    
  </entry>
  
</feed>
