<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Ray的博客</title>
  
  <subtitle>Keep coding...</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-09-27T02:18:02.977Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Ray Wong</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>告别GOPATH,使用go mod</title>
    <link href="http://yoursite.com/2019/09/25/go_mod/"/>
    <id>http://yoursite.com/2019/09/25/go_mod/</id>
    <published>2019-09-25T01:47:23.000Z</published>
    <updated>2019-09-27T02:18:02.977Z</updated>
    
    <content type="html"><![CDATA[<p>我们都知道在使用Golang时开发程序时都需要在 <code>GOPATH</code> 下面，这就非常不方便。如果你想放在磁盘上的其他地方，那么go mod将是你的“好伙伴”。</p><p>关于 go mod 的说明，可以参考：</p><ul><li><a href="https://roberto.selbach.ca/intro-to-go-modules/" target="_blank" rel="noopener">Introduction to Go Modules</a></li><li><a href="https://github.com/golang/go/wiki/Modules" target="_blank" rel="noopener">Go 1.11 Modules 官方说明文档</a></li></ul><a id="more"></a><h3 id="命令行说明"><a href="#命令行说明" class="headerlink" title="命令行说明"></a>命令行说明</h3><p><code>➜  ~ go modGo mod provides access to operations on modules.Note that support for modules is built into all the go commands,not just &#39;go mod&#39;. For example, day-to-day adding, removing, upgrading,and downgrading of dependencies should be done using &#39;go get&#39;.See &#39;go help modules&#39; for an overview of module functionality.Usage:    go mod &lt;command&gt; [arguments]The commands are:    download    download modules to local cache                    下载依赖的 module 到本地 cache    edit        edit go.mod from tools or scripts                编辑 go.mod    graph       print module requirement graph                    打印模块依赖图    init        initialize new module in current directory        在当前目录下初始化 go.mod(就是会新建一个 go.mod 文件)    tidy        add missing and remove unused modules             整理依赖关系，会添加丢失的 module，删除不需要的 module    vendor      make vendored copy of dependencies                将依赖复制到 vendor 下    verify      verify dependencies have expected content       校验依赖    why         explain why packages or modules are needed      解释为什么需要依赖Use &quot;go help mod &lt;command&gt;&quot; for more information about a command.</code></p><h3 id="如果在项目中使用"><a href="#如果在项目中使用" class="headerlink" title="如果在项目中使用"></a>如果在项目中使用</h3><ol><li>版本：首先将你的Go版本更新到(&gt;=1.11)，这里将不介绍怎么更新</li><li>设置环境变量(1.12默认)：在你的项目目录下使用<code>set GO111MODULE=ON</code></li><li>执行<code>go mod init</code>在当前目录下生成一个<code>go.mod</code>文件，如果之前有生成过需要删除再初始化</li></ol><p>执行完上面步骤基本就完成了，运行下程序你会发现目录下多了一个<code>go.sum</code>文件，是用来记录所依赖的版本的锁定</p><p>执行命令<code>go mod verify</code>命令来检查当前模块的依赖是否全部下载下来，是否下载下来被修改过。如果所有的模块都没有被修改过，那么执行这条命令之后，会打印<code>all modules verified</code>。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>使用<code>go mod</code>后你会发现在<code>GOPATH</code>下面的<code>pkg</code>目录会有一个<code>mod</code>目录，里面包含了项目需要的依赖包，这也是为什么不需要再<code>GOPATH</code>中开发程序也能使用的原因</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我们都知道在使用Golang时开发程序时都需要在 &lt;code&gt;GOPATH&lt;/code&gt; 下面，这就非常不方便。如果你想放在磁盘上的其他地方，那么go mod将是你的“好伙伴”。&lt;/p&gt;
&lt;p&gt;关于 go mod 的说明，可以参考：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://roberto.selbach.ca/intro-to-go-modules/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Introduction to Go Modules&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/golang/go/wiki/Modules&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Go 1.11 Modules 官方说明文档&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="Go" scheme="http://yoursite.com/tags/Go/"/>
    
      <category term="mod" scheme="http://yoursite.com/tags/mod/"/>
    
  </entry>
  
  <entry>
    <title>初识Python asyncio异步编程</title>
    <link href="http://yoursite.com/2019/09/23/asyncio/"/>
    <id>http://yoursite.com/2019/09/23/asyncio/</id>
    <published>2019-09-23T07:58:52.000Z</published>
    <updated>2019-09-23T08:10:15.170Z</updated>
    
    <content type="html"><![CDATA[<h3 id="什么是异步编程？"><a href="#什么是异步编程？" class="headerlink" title="什么是异步编程？"></a>什么是异步编程？</h3><p>同步代码(synchrnous code)我们都很熟悉，就是运行完一个步骤再运行下一个。要在同步代码里面实现”同时”运行多个任务，最简单也是最直观地方式就是运行多个 threads 或者多个 processes。这个层次的『同时运行』多个任务，是操作系统协助完成的。 也就是操作系统的任务调度系统来决定什么时候运行这个任务，什么时候切换任务，你自己，作为一个应用层的程序员，是没办法进行干预的。</p><a id="more"></a><p>我相信你也已经听说了什么关于 thread 和 process 的抱怨：process 太重，thread 又要牵涉到很多头条的锁问题。尤其是对于一个 Python 开发者来说，由于GIL（全局解释器锁）的存在，多线程无法真正使用多核，如果你用多线程来运行计算型任务，速度会更慢。</p><p>异步编程与之不同的是，值使用一个进程，不使用 threads，但是也能实现”同时”运行多个任务（这里的任务其实就是函数）。</p><p>这些函数有一个非常 nice 的 feature：必要的可以暂停，把运行的权利交给其他函数。等到时机恰当，又可以恢复之前的状态继续运行。这听上去是不是有点像进程呢？可以暂停，可以恢复运行。只不过进程的调度是操作系统完成的，这些函数的调度是进程自己（或者说程序员你自己）完成的。这也就意味着这将省去了很多计算机的资源，因为进程的调度必然需要大量 syscall，而 syscall 是很昂贵的。</p><h3 id="一-定义一个简单的协程："><a href="#一-定义一个简单的协程：" class="headerlink" title="一 定义一个简单的协程："></a>一 定义一个简单的协程：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">import asyncio</span><br><span class="line">  </span><br><span class="line">async def execute(x):</span><br><span class="line">    print(&apos;Number:&apos;, x)</span><br><span class="line">    return x</span><br><span class="line">  </span><br><span class="line">coroutine = execute(1)</span><br><span class="line">print(&apos;Coroutine:&apos;, coroutine)</span><br><span class="line">print(&apos;After calling execute&apos;)</span><br><span class="line">  </span><br><span class="line">loop = asyncio.get_event_loop()</span><br><span class="line">task = loop.create_task(coroutine)</span><br><span class="line">print(&apos;Task:&apos;, task)</span><br><span class="line">loop.run_until_complete(task)</span><br><span class="line">print(&apos;Task:&apos;, task)</span><br><span class="line">print(&apos;After calling loop&apos;)</span><br></pre></td></tr></table></figure><p>print(‘Task Result:’, task.result())  这样也能查看task执行的结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Coroutine: &lt;coroutine object execute at 0x10e0f7830&gt;</span><br><span class="line">After calling execute</span><br><span class="line">Task: &lt;Task pending coro=&lt;execute() running at demo.py:4&gt;&gt;</span><br><span class="line">Number: 1</span><br><span class="line">Task: &lt;Task finished coro=&lt;execute() done, defined at demo.py:4&gt; result=1&gt;</span><br><span class="line">After calling loop</span><br></pre></td></tr></table></figure><p>我们使用 async 定义了一个 execute() 方法，方法接收一个数字参数，方法执行之后会打印这个数字。<br>随后我们直接调用了这个方法，然而这个方法并没有执行，而是返回了一个 coroutine 协程对象。</p><p>随后我们使用 get_event_loop() 方法创建了一个事件循环 loop，并调用了 loop 对象的 run_until_complete() 方法将协程注册到事件循环 loop 中，然后启动。最后我们才看到了 execute() 方法打印了输出结果。可见，async 定义的方法就会变成一个无法直接执行的 coroutine 对象，必须将其注册到事件循环中才可以执行。</p><p>我们也可以不使用task来运行，它里面相比 coroutine 对象多了运行状态，比如 running、finished 等，我们可以用这些状态来获取协程对象的执行情况。将 coroutine 对象传递给 run_until_complete() 方法的时候，实际上它进行了一个操作就是将 coroutine 封装成了 task 对象，如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">import asyncio</span><br><span class="line"></span><br><span class="line">async def execute(x):</span><br><span class="line">    print(&apos;Number:&apos;, x)</span><br><span class="line"></span><br><span class="line">coroutine = execute(1)</span><br><span class="line">print(&apos;Coroutine:&apos;, coroutine)</span><br><span class="line">print(&apos;After calling execute&apos;)</span><br><span class="line"></span><br><span class="line">loop = asyncio.get_event_loop()</span><br><span class="line">loop.run_until_complete(coroutine)</span><br><span class="line">print(&apos;After calling loop&apos;)</span><br></pre></td></tr></table></figure><p>查看了源码，正好可以验证上面这一观点：</p><p>run_until_complete()这个方法位于源码中的base_events.py，函数有句注释：<br>Run until the Future is done.If the argument is a coroutine, it is wrapped in a Task.</p><h3 id="二-发送网络请求结合aiohttp实现异步："><a href="#二-发送网络请求结合aiohttp实现异步：" class="headerlink" title="二 发送网络请求结合aiohttp实现异步："></a>二 发送网络请求结合aiohttp实现异步：</h3><p>我们用一个网络请求作为示例，这就是一个耗时等待的操作，因为我们请求网页之后需要等待页面响应并返回结果。耗时等待的操作一般都是 IO 操作，比如文件读取、网络请求等等。协程对于处理这种操作是有很大优势的，当遇到需要等待的情况的时候，程序可以暂时挂起，转而去执行其他的操作，从而避免一直等待一个程序而耗费过多的时间，充分利用资源。为了测试，我自己先通过flask 创建一个实验环境：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">from flask import Flask</span><br><span class="line">import time</span><br><span class="line">  </span><br><span class="line">app = Flask(__name__)</span><br><span class="line">  </span><br><span class="line">@app.route(&apos;/&apos;)</span><br><span class="line">def index():</span><br><span class="line">    time.sleep(3)</span><br><span class="line">    return &apos;Hello!&apos;</span><br><span class="line">  </span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    app.run(threaded=True)</span><br></pre></td></tr></table></figure></p><p>开始测试…<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">import asyncio</span><br><span class="line">import aiohttp</span><br><span class="line">import time</span><br><span class="line">  </span><br><span class="line">start = time.time()</span><br><span class="line">  </span><br><span class="line">async def get(url):</span><br><span class="line">    session = aiohttp.ClientSession()</span><br><span class="line">    response = await session.get(url)</span><br><span class="line">    result = await response.text()</span><br><span class="line">    session.close()</span><br><span class="line">    return result</span><br><span class="line">  </span><br><span class="line">async def request():</span><br><span class="line">    url = &apos;http://127.0.0.1:5000&apos;          # 访问flask搭建的服务器（睡眠3秒），模仿IO阻塞</span><br><span class="line">    print(&apos;Waiting for&apos;, url)</span><br><span class="line">    result = await get(url)</span><br><span class="line">    print(&apos;Get response from&apos;, url, &apos;Result:&apos;, result)</span><br><span class="line">  </span><br><span class="line">tasks = [asyncio.ensure_future(request()) for _ in range(5)]</span><br><span class="line">loop = asyncio.get_event_loop()</span><br><span class="line">loop.run_until_complete(asyncio.wait(tasks))</span><br><span class="line">  </span><br><span class="line">end = time.time()</span><br><span class="line">print(&apos;Cost time:&apos;, end - start)</span><br></pre></td></tr></table></figure></p><p>运行结果…<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Waiting for http://127.0.0.1:5000</span><br><span class="line">Waiting for http://127.0.0.1:5000</span><br><span class="line">Waiting for http://127.0.0.1:5000</span><br><span class="line">Waiting for http://127.0.0.1:5000</span><br><span class="line">Waiting for http://127.0.0.1:5000</span><br><span class="line">Get response from http://127.0.0.1:5000 Result: Hello!</span><br><span class="line">Get response from http://127.0.0.1:5000 Result: Hello!</span><br><span class="line">Get response from http://127.0.0.1:5000 Result: Hello!</span><br><span class="line">Get response from http://127.0.0.1:5000 Result: Hello!</span><br><span class="line">Get response from http://127.0.0.1:5000 Result: Hello!</span><br><span class="line">Cost time: 3.0199508666992188</span><br></pre></td></tr></table></figure></p><p>我们发现这次请求的耗时由 15 秒变成了 3 秒，耗时直接变成了原来的 1/5。</p><p>代码里面我们使用了 await，后面跟了 get() 方法，在执行这五个协程的时候，如果遇到了 await，那么就会将当前协程挂起，转而去执行其他的协程，直到其他的协程也挂起或执行完毕，再进行下一个协程的执行。</p><h2 id="二-总结"><a href="#二-总结" class="headerlink" title="二 总结"></a>二 总结</h2><p>协程”同时”运行多个任务的基础是函数可以暂停（await实际就是用到了yield）。上面的代码中使用到了 asyncio的 event_loop，它做的事情，本质上来说就是当函数暂停时，切换到下一个任务，当时机恰当（这个例子中是请求完成了）恢复函数让他继续运行（这有点像操作系统了）。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;什么是异步编程？&quot;&gt;&lt;a href=&quot;#什么是异步编程？&quot; class=&quot;headerlink&quot; title=&quot;什么是异步编程？&quot;&gt;&lt;/a&gt;什么是异步编程？&lt;/h3&gt;&lt;p&gt;同步代码(synchrnous code)我们都很熟悉，就是运行完一个步骤再运行下一个。要在同步代码里面实现”同时”运行多个任务，最简单也是最直观地方式就是运行多个 threads 或者多个 processes。这个层次的『同时运行』多个任务，是操作系统协助完成的。 也就是操作系统的任务调度系统来决定什么时候运行这个任务，什么时候切换任务，你自己，作为一个应用层的程序员，是没办法进行干预的。&lt;/p&gt;
    
    </summary>
    
      <category term="Python" scheme="http://yoursite.com/categories/Python/"/>
    
    
      <category term="异步" scheme="http://yoursite.com/tags/%E5%BC%82%E6%AD%A5/"/>
    
      <category term="asyncio" scheme="http://yoursite.com/tags/asyncio/"/>
    
  </entry>
  
  <entry>
    <title>关于我</title>
    <link href="http://yoursite.com/2019/09/23/index/"/>
    <id>http://yoursite.com/2019/09/23/index/</id>
    <published>2019-09-23T01:47:23.000Z</published>
    <updated>2019-09-23T03:53:51.679Z</updated>
    
    <content type="html"><![CDATA[<p>记录学习的点点滴滴…</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;记录学习的点点滴滴…&lt;/p&gt;

      
    
    </summary>
    
    
      <category term="介绍" scheme="http://yoursite.com/tags/%E4%BB%8B%E7%BB%8D/"/>
    
  </entry>
  
</feed>
