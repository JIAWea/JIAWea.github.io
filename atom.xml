<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Ray的博客</title>
  
  <subtitle>Keep coding...</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-10-14T06:28:06.931Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Ray Wong</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Python进阶用法</title>
    <link href="http://yoursite.com/2019/10/14/HiddenFeaturesOfPython/"/>
    <id>http://yoursite.com/2019/10/14/HiddenFeaturesOfPython/</id>
    <published>2019-10-14T02:58:14.000Z</published>
    <updated>2019-10-14T06:28:06.931Z</updated>
    
    <content type="html"><![CDATA[<p>使用Python来编写也有很长一段时间了，也想着如何优化自己的代码，随之也搜了一些问题。<br>其中印象比较深刻的就是stackoverflow上的一个问题解答了。</p><a id="more"></a><p>原文：<a href="https://stackoverflow.com/questions/101268/hidden-features-of-python" target="_blank" rel="noopener">Hidden features of Python</a></p><p><strong>Argument Unpacking</strong><br>可以使用 * 和 ** 分别将一个列表和一个字典解包为函数参数<br>如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">def draw_point(x, y):</span><br><span class="line"># do something</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">tuple = (6, 8)</span><br><span class="line">dir = &#123;&apos;x&apos;: 6, &apos;y&apos;: 8&#125;</span><br><span class="line"></span><br><span class="line">draw_point(*tuple)</span><br><span class="line">draw_point(**dir)</span><br></pre></td></tr></table></figure></p><p><strong>Decorators</strong><br>装饰器的作用就是在不需要修改原函数代码的前提下增加新的功能，在调用原函数的时候先执行装饰器，如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">def print_before_func(func):</span><br><span class="line">def wrapper(*args, **kwargs):</span><br><span class="line">print(&quot;print before func&quot;)</span><br><span class="line">return func(*args, **kwargs)</span><br><span class="line">return wrapper</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@print_befor_func</span><br><span class="line">def write(text):</span><br><span class="line">print(text)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">write(Hello world)</span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line">print before func</span><br><span class="line">Hello world</span><br></pre></td></tr></table></figure></p><p><strong>Dictionary default .get value</strong><br>字典中有一个<code>get()</code>方法。如果你使用<code>dict[&#39;key&#39;]</code>的方式而<code>key</code>不存在的话就会出现异常。使用<code>dict.get(&#39;key&#39;)</code>的话如果<code>key</code>不存在则只会返回<code>None</code>。当然<code>get()</code>方法提供了第二个参数，如果返回<code>None</code>则会返回第二个参数的值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">num = dict.get(&apos;num&apos;, 0)</span><br></pre></td></tr></table></figure></p><p><strong>Enumeration</strong><br>使用enumeration包住一个可迭代对象，它会将index和item绑在一起，返回一个enumeration对象，如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">a = [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;]</span><br><span class="line">for index, item in enumeration(a):</span><br><span class="line">print(index, item)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">···</span><br><span class="line">0 a</span><br><span class="line">1 b</span><br><span class="line">2 c</span><br><span class="line">3 d</span><br><span class="line">···</span><br></pre></td></tr></table></figure></p><p>在同时需要索引和值的时候很有用</p><p><strong>For/else</strong><br>语法如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">for i in foo:</span><br><span class="line">if i == 0:</span><br><span class="line">break</span><br><span class="line">else:</span><br><span class="line">print(&quot;it was never 0&quot;)</span><br></pre></td></tr></table></figure></p><p><code>else</code>代码块会在循环正常结束后执行，也就是说没用出现<code>break</code>时才会调用<code>else</code>代码块，上面代码等价于:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">found = False</span><br><span class="line">for i in foo:</span><br><span class="line">if i == 0:</span><br><span class="line">found = True</span><br><span class="line">break</span><br><span class="line"></span><br><span class="line">if not found:</span><br><span class="line">print(&quot;it was never 0&quot;)</span><br></pre></td></tr></table></figure></p><p>这个语法挺容易让人混淆的，所有在使用的时候最好是注释一下，以免被其他小伙伴搞错含义了。</p><p>上面的代码也等价于：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if any(i == 0 for i in foo):</span><br><span class="line">pass</span><br><span class="line">else:</span><br><span class="line">print(&quot;it was never 0&quot;)</span><br></pre></td></tr></table></figure></p><p><strong>Generator expressions</strong><br>假如你这样写：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x = (n for n in foo if bar(n))</span><br></pre></td></tr></table></figure></p><p>你将会得到一个生成器，并可以把它付给一个变量x。现在你可以像下面一样使用生成器：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">for n in x:</span><br><span class="line">print(n)</span><br></pre></td></tr></table></figure></p><p>这样做的好处就是节省内存了。你不需要中间存储，而如果像下面这样的话，则需要：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x = [n for n in foo if bar(n)]</span><br><span class="line"># 列表推导</span><br></pre></td></tr></table></figure></p><p>在某些情况下，这会导致极重要的速度提升。<br>你可以添加许多if语句到生成器的尾端，基本复制for循环嵌套：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; n = ((a,b) for a in range(0,2) for b in range(4,6))</span><br><span class="line">&gt;&gt;&gt; for i in n:</span><br><span class="line">...   print i </span><br><span class="line"></span><br><span class="line">(0, 4)</span><br><span class="line">(0, 5)</span><br><span class="line">(1, 4)</span><br><span class="line">(1, 5)</span><br></pre></td></tr></table></figure></p><p>使用生成器最大的好处就是节省内存了。因为每一个值只有在你需要的时候才会生成，而不像列表推导那样一次性生成所有的结果。</p><p><strong>List stepping</strong><br>切片操作符中的步长(step)参数。例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = [1,2,3,4,5]</span><br><span class="line">&gt;&gt;&gt; a[::2]  # iterate over the whole list in 2-increments</span><br><span class="line">[1,3,5]</span><br></pre></td></tr></table></figure></p><p>特殊例子<code>x[::-1]</code>对‘x反转’来说相当有用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; a[::-1]</span><br><span class="line">[5,4,3,2,1]</span><br></pre></td></tr></table></figure></p><p>当然，你可以使用<code>reversed()</code>函数来实现反转。<br>区别在于，reversed()返回一个迭代器，所以还需要一个额外的步骤来将结果转换成需要的对象类型。<br>这个特性在判断例如回文的时候灰常有用，一句话搞定<br><code>True if someseq == someseq[::-1] else False</code></p><p><strong>Named string formatting</strong><br>%-格式化接收一个字典（也适用于%i%s等）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; print &quot;The %(foo)s is %(bar)i.&quot; % &#123;&apos;foo&apos;: &apos;answer&apos;, &apos;bar&apos;:42&#125;</span><br><span class="line">The answer is 42.</span><br></pre></td></tr></table></figure></p><p><strong>try/except/else</strong><br>else语句块只有当try语句正常执行（也就是说，except语句未执行）的时候，才会执行。<br>finally则无论是否异常都会执行。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">try:</span><br><span class="line">     Normal execution block</span><br><span class="line">except A:</span><br><span class="line">     Exception A handle</span><br><span class="line">except B:</span><br><span class="line">     Exception B handle</span><br><span class="line">except:</span><br><span class="line">     Other exception handle</span><br><span class="line">else:</span><br><span class="line">     if no exception,get here</span><br><span class="line">finally:</span><br><span class="line">     this block will be excuted no matter how it goes above</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;使用Python来编写也有很长一段时间了，也想着如何优化自己的代码，随之也搜了一些问题。&lt;br&gt;其中印象比较深刻的就是stackoverflow上的一个问题解答了。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>告别GOPATH,使用go mod</title>
    <link href="http://yoursite.com/2019/09/25/go_mod/"/>
    <id>http://yoursite.com/2019/09/25/go_mod/</id>
    <published>2019-09-25T01:47:23.000Z</published>
    <updated>2019-09-27T02:22:45.047Z</updated>
    
    <content type="html"><![CDATA[<p>我们都知道在使用Golang时开发程序时都需要在 <code>GOPATH</code> 下面，这就非常不方便。如果你想放在磁盘上的其他地方，那么go mod将是你的“好伙伴”。</p><p>关于 go mod 的说明，可以参考：</p><ul><li><a href="https://roberto.selbach.ca/intro-to-go-modules/" target="_blank" rel="noopener">Introduction to Go Modules</a></li><li><a href="https://github.com/golang/go/wiki/Modules" target="_blank" rel="noopener">Go 1.11 Modules 官方说明文档</a></li></ul><a id="more"></a><h3 id="命令行说明"><a href="#命令行说明" class="headerlink" title="命令行说明"></a>命令行说明</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ go mod</span><br><span class="line">Go mod provides access to operations on modules.</span><br><span class="line">Note that support for modules is built into all the go commands,</span><br><span class="line">not just &apos;go mod&apos;. For example, day-to-day adding, removing, upgrading,</span><br><span class="line">and downgrading of dependencies should be done using &apos;go get&apos;.</span><br><span class="line">See &apos;go help modules&apos; for an overview of module functionality.</span><br><span class="line">Usage:</span><br><span class="line">go mod &lt;command&gt; [arguments]</span><br><span class="line">The commands are:</span><br><span class="line">download    download modules to local cache</span><br><span class="line">edit        edit go.mod from tools or scripts</span><br><span class="line">graph       print module requirement graph</span><br><span class="line">init        initialize new module in current directory</span><br><span class="line">tidy        add missing and remove unused modules </span><br><span class="line">vendor      make vendored copy of dependencies</span><br><span class="line">verify      verify dependencies have expected content  </span><br><span class="line">why         explain why packages or modules are needed </span><br><span class="line">Use &quot;go help mod &lt;command&gt;&quot; for more information about a command.</span><br></pre></td></tr></table></figure><ul><li>go mod download: 下载依赖的 module 到本地 cache</li><li>go mod edit: 编辑 go.mod</li><li>go mod graph: 打印模块依赖图</li><li>go mod init: 在当前目录下初始化 go.mod(就是会新建一个 go.mod 文件)</li><li>go mod tidy: 整理依赖关系，会添加丢失的 module，删除不需要的 module</li><li>go mod vender: 将依赖复制到 vendor 下</li><li>go mod verify: 校验依赖</li><li>go mod why: 解释为什么需要依赖</li></ul><p>执行命令<code>go mod verify</code>命令来检查当前模块的依赖是否全部下载下来，是否下载下来被修改过。如果所有的模块都没有被修改过，那么执行这条命令之后，会打印<code>all modules verified</code>。</p><h3 id="如果在项目中使用"><a href="#如果在项目中使用" class="headerlink" title="如果在项目中使用"></a>如果在项目中使用</h3><ol><li>版本：首先将你的Go版本更新到(&gt;=1.11)，这里将不介绍怎么更新</li><li>设置环境变量(1.12默认)：在你的项目目录下使用<code>set GO111MODULE=ON</code></li><li>执行<code>go mod init</code>在当前目录下生成一个<code>go.mod</code>文件，如果之前有生成过需要删除再初始化</li></ol><p>执行完上面步骤基本就完成了，运行下程序你会发现目录下多了一个<code>go.sum</code>文件，是用来记录所依赖的版本的锁定</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>使用<code>go mod</code>后你会发现在<code>GOPATH</code>下面的<code>pkg</code>目录会有一个<code>mod</code>目录，里面包含了项目需要的依赖包，这也是为什么不需要再<code>GOPATH</code>中开发程序也能使用的原因</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我们都知道在使用Golang时开发程序时都需要在 &lt;code&gt;GOPATH&lt;/code&gt; 下面，这就非常不方便。如果你想放在磁盘上的其他地方，那么go mod将是你的“好伙伴”。&lt;/p&gt;
&lt;p&gt;关于 go mod 的说明，可以参考：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://roberto.selbach.ca/intro-to-go-modules/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Introduction to Go Modules&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/golang/go/wiki/Modules&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Go 1.11 Modules 官方说明文档&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="Go" scheme="http://yoursite.com/tags/Go/"/>
    
      <category term="mod" scheme="http://yoursite.com/tags/mod/"/>
    
  </entry>
  
  <entry>
    <title>初识Python asyncio异步编程</title>
    <link href="http://yoursite.com/2019/09/23/asyncio/"/>
    <id>http://yoursite.com/2019/09/23/asyncio/</id>
    <published>2019-09-23T07:58:52.000Z</published>
    <updated>2019-09-23T08:10:15.170Z</updated>
    
    <content type="html"><![CDATA[<h3 id="什么是异步编程？"><a href="#什么是异步编程？" class="headerlink" title="什么是异步编程？"></a>什么是异步编程？</h3><p>同步代码(synchrnous code)我们都很熟悉，就是运行完一个步骤再运行下一个。要在同步代码里面实现”同时”运行多个任务，最简单也是最直观地方式就是运行多个 threads 或者多个 processes。这个层次的『同时运行』多个任务，是操作系统协助完成的。 也就是操作系统的任务调度系统来决定什么时候运行这个任务，什么时候切换任务，你自己，作为一个应用层的程序员，是没办法进行干预的。</p><a id="more"></a><p>我相信你也已经听说了什么关于 thread 和 process 的抱怨：process 太重，thread 又要牵涉到很多头条的锁问题。尤其是对于一个 Python 开发者来说，由于GIL（全局解释器锁）的存在，多线程无法真正使用多核，如果你用多线程来运行计算型任务，速度会更慢。</p><p>异步编程与之不同的是，值使用一个进程，不使用 threads，但是也能实现”同时”运行多个任务（这里的任务其实就是函数）。</p><p>这些函数有一个非常 nice 的 feature：必要的可以暂停，把运行的权利交给其他函数。等到时机恰当，又可以恢复之前的状态继续运行。这听上去是不是有点像进程呢？可以暂停，可以恢复运行。只不过进程的调度是操作系统完成的，这些函数的调度是进程自己（或者说程序员你自己）完成的。这也就意味着这将省去了很多计算机的资源，因为进程的调度必然需要大量 syscall，而 syscall 是很昂贵的。</p><h3 id="一-定义一个简单的协程："><a href="#一-定义一个简单的协程：" class="headerlink" title="一 定义一个简单的协程："></a>一 定义一个简单的协程：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">import asyncio</span><br><span class="line">  </span><br><span class="line">async def execute(x):</span><br><span class="line">    print(&apos;Number:&apos;, x)</span><br><span class="line">    return x</span><br><span class="line">  </span><br><span class="line">coroutine = execute(1)</span><br><span class="line">print(&apos;Coroutine:&apos;, coroutine)</span><br><span class="line">print(&apos;After calling execute&apos;)</span><br><span class="line">  </span><br><span class="line">loop = asyncio.get_event_loop()</span><br><span class="line">task = loop.create_task(coroutine)</span><br><span class="line">print(&apos;Task:&apos;, task)</span><br><span class="line">loop.run_until_complete(task)</span><br><span class="line">print(&apos;Task:&apos;, task)</span><br><span class="line">print(&apos;After calling loop&apos;)</span><br></pre></td></tr></table></figure><p>print(‘Task Result:’, task.result())  这样也能查看task执行的结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Coroutine: &lt;coroutine object execute at 0x10e0f7830&gt;</span><br><span class="line">After calling execute</span><br><span class="line">Task: &lt;Task pending coro=&lt;execute() running at demo.py:4&gt;&gt;</span><br><span class="line">Number: 1</span><br><span class="line">Task: &lt;Task finished coro=&lt;execute() done, defined at demo.py:4&gt; result=1&gt;</span><br><span class="line">After calling loop</span><br></pre></td></tr></table></figure><p>我们使用 async 定义了一个 execute() 方法，方法接收一个数字参数，方法执行之后会打印这个数字。<br>随后我们直接调用了这个方法，然而这个方法并没有执行，而是返回了一个 coroutine 协程对象。</p><p>随后我们使用 get_event_loop() 方法创建了一个事件循环 loop，并调用了 loop 对象的 run_until_complete() 方法将协程注册到事件循环 loop 中，然后启动。最后我们才看到了 execute() 方法打印了输出结果。可见，async 定义的方法就会变成一个无法直接执行的 coroutine 对象，必须将其注册到事件循环中才可以执行。</p><p>我们也可以不使用task来运行，它里面相比 coroutine 对象多了运行状态，比如 running、finished 等，我们可以用这些状态来获取协程对象的执行情况。将 coroutine 对象传递给 run_until_complete() 方法的时候，实际上它进行了一个操作就是将 coroutine 封装成了 task 对象，如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">import asyncio</span><br><span class="line"></span><br><span class="line">async def execute(x):</span><br><span class="line">    print(&apos;Number:&apos;, x)</span><br><span class="line"></span><br><span class="line">coroutine = execute(1)</span><br><span class="line">print(&apos;Coroutine:&apos;, coroutine)</span><br><span class="line">print(&apos;After calling execute&apos;)</span><br><span class="line"></span><br><span class="line">loop = asyncio.get_event_loop()</span><br><span class="line">loop.run_until_complete(coroutine)</span><br><span class="line">print(&apos;After calling loop&apos;)</span><br></pre></td></tr></table></figure><p>查看了源码，正好可以验证上面这一观点：</p><p>run_until_complete()这个方法位于源码中的base_events.py，函数有句注释：<br>Run until the Future is done.If the argument is a coroutine, it is wrapped in a Task.</p><h3 id="二-发送网络请求结合aiohttp实现异步："><a href="#二-发送网络请求结合aiohttp实现异步：" class="headerlink" title="二 发送网络请求结合aiohttp实现异步："></a>二 发送网络请求结合aiohttp实现异步：</h3><p>我们用一个网络请求作为示例，这就是一个耗时等待的操作，因为我们请求网页之后需要等待页面响应并返回结果。耗时等待的操作一般都是 IO 操作，比如文件读取、网络请求等等。协程对于处理这种操作是有很大优势的，当遇到需要等待的情况的时候，程序可以暂时挂起，转而去执行其他的操作，从而避免一直等待一个程序而耗费过多的时间，充分利用资源。为了测试，我自己先通过flask 创建一个实验环境：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">from flask import Flask</span><br><span class="line">import time</span><br><span class="line">  </span><br><span class="line">app = Flask(__name__)</span><br><span class="line">  </span><br><span class="line">@app.route(&apos;/&apos;)</span><br><span class="line">def index():</span><br><span class="line">    time.sleep(3)</span><br><span class="line">    return &apos;Hello!&apos;</span><br><span class="line">  </span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    app.run(threaded=True)</span><br></pre></td></tr></table></figure></p><p>开始测试…<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">import asyncio</span><br><span class="line">import aiohttp</span><br><span class="line">import time</span><br><span class="line">  </span><br><span class="line">start = time.time()</span><br><span class="line">  </span><br><span class="line">async def get(url):</span><br><span class="line">    session = aiohttp.ClientSession()</span><br><span class="line">    response = await session.get(url)</span><br><span class="line">    result = await response.text()</span><br><span class="line">    session.close()</span><br><span class="line">    return result</span><br><span class="line">  </span><br><span class="line">async def request():</span><br><span class="line">    url = &apos;http://127.0.0.1:5000&apos;          # 访问flask搭建的服务器（睡眠3秒），模仿IO阻塞</span><br><span class="line">    print(&apos;Waiting for&apos;, url)</span><br><span class="line">    result = await get(url)</span><br><span class="line">    print(&apos;Get response from&apos;, url, &apos;Result:&apos;, result)</span><br><span class="line">  </span><br><span class="line">tasks = [asyncio.ensure_future(request()) for _ in range(5)]</span><br><span class="line">loop = asyncio.get_event_loop()</span><br><span class="line">loop.run_until_complete(asyncio.wait(tasks))</span><br><span class="line">  </span><br><span class="line">end = time.time()</span><br><span class="line">print(&apos;Cost time:&apos;, end - start)</span><br></pre></td></tr></table></figure></p><p>运行结果…<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Waiting for http://127.0.0.1:5000</span><br><span class="line">Waiting for http://127.0.0.1:5000</span><br><span class="line">Waiting for http://127.0.0.1:5000</span><br><span class="line">Waiting for http://127.0.0.1:5000</span><br><span class="line">Waiting for http://127.0.0.1:5000</span><br><span class="line">Get response from http://127.0.0.1:5000 Result: Hello!</span><br><span class="line">Get response from http://127.0.0.1:5000 Result: Hello!</span><br><span class="line">Get response from http://127.0.0.1:5000 Result: Hello!</span><br><span class="line">Get response from http://127.0.0.1:5000 Result: Hello!</span><br><span class="line">Get response from http://127.0.0.1:5000 Result: Hello!</span><br><span class="line">Cost time: 3.0199508666992188</span><br></pre></td></tr></table></figure></p><p>我们发现这次请求的耗时由 15 秒变成了 3 秒，耗时直接变成了原来的 1/5。</p><p>代码里面我们使用了 await，后面跟了 get() 方法，在执行这五个协程的时候，如果遇到了 await，那么就会将当前协程挂起，转而去执行其他的协程，直到其他的协程也挂起或执行完毕，再进行下一个协程的执行。</p><h2 id="二-总结"><a href="#二-总结" class="headerlink" title="二 总结"></a>二 总结</h2><p>协程”同时”运行多个任务的基础是函数可以暂停（await实际就是用到了yield）。上面的代码中使用到了 asyncio的 event_loop，它做的事情，本质上来说就是当函数暂停时，切换到下一个任务，当时机恰当（这个例子中是请求完成了）恢复函数让他继续运行（这有点像操作系统了）。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;什么是异步编程？&quot;&gt;&lt;a href=&quot;#什么是异步编程？&quot; class=&quot;headerlink&quot; title=&quot;什么是异步编程？&quot;&gt;&lt;/a&gt;什么是异步编程？&lt;/h3&gt;&lt;p&gt;同步代码(synchrnous code)我们都很熟悉，就是运行完一个步骤再运行下一个。要在同步代码里面实现”同时”运行多个任务，最简单也是最直观地方式就是运行多个 threads 或者多个 processes。这个层次的『同时运行』多个任务，是操作系统协助完成的。 也就是操作系统的任务调度系统来决定什么时候运行这个任务，什么时候切换任务，你自己，作为一个应用层的程序员，是没办法进行干预的。&lt;/p&gt;
    
    </summary>
    
      <category term="Python" scheme="http://yoursite.com/categories/Python/"/>
    
    
      <category term="异步" scheme="http://yoursite.com/tags/%E5%BC%82%E6%AD%A5/"/>
    
      <category term="asyncio" scheme="http://yoursite.com/tags/asyncio/"/>
    
  </entry>
  
  <entry>
    <title>关于我</title>
    <link href="http://yoursite.com/2019/09/23/index/"/>
    <id>http://yoursite.com/2019/09/23/index/</id>
    <published>2019-09-23T01:47:23.000Z</published>
    <updated>2019-09-23T03:53:51.679Z</updated>
    
    <content type="html"><![CDATA[<p>记录学习的点点滴滴…</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;记录学习的点点滴滴…&lt;/p&gt;

      
    
    </summary>
    
    
      <category term="介绍" scheme="http://yoursite.com/tags/%E4%BB%8B%E7%BB%8D/"/>
    
  </entry>
  
</feed>
