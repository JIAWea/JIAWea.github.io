<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Ray的博客</title>
  
  <subtitle>Keep coding...</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://jiawea.github.io/"/>
  <updated>2020-11-18T02:42:46.553Z</updated>
  <id>https://jiawea.github.io/</id>
  
  <author>
    <name>Ray Wong</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>MySQL是如何执行SQL更新语句的</title>
    <link href="https://jiawea.github.io/2020/08/22/MySQL-Update/"/>
    <id>https://jiawea.github.io/2020/08/22/MySQL-Update/</id>
    <published>2020-08-22T06:27:58.000Z</published>
    <updated>2020-11-18T02:42:46.553Z</updated>
    
    <content type="html"><![CDATA[<p>用了这么久数据库，却不知道数据库是如何执行我们输入的语句的，经过一番查阅后，记录下执行一条查询和更新SQL语句后，MySQL是如何工作的。</p><p>SQL语句基本的执行链路：</p><center><img src="/static/mysql/liucheng.png" alt="流程"></center><h3 id="1-查询语句是如何执行"><a href="#1-查询语句是如何执行" class="headerlink" title="1 查询语句是如何执行"></a>1 查询语句是如何执行</h3><p>一条查询语句的执行过程一般是经过连接器、分析器、优化器、执行器等功能模块，最后到达存储引擎</p><h3 id="2-更新语句是如何执行"><a href="#2-更新语句是如何执行" class="headerlink" title="2 更新语句是如何执行"></a>2 更新语句是如何执行</h3><p>一条更新语句的执行过程和查询的执行过程是一样的：<br>以执行这条SQL语句为例。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; update T set c=c+1 where ID=2;</span><br></pre></td></tr></table></figure></p><ol><li>连接器：连接数据库。</li><li>分析器：分析器通过词法和语法解析知道这是一条更新语句，</li><li>优化器：决定使用ID这个索引。</li><li>执行器：向存储引擎读取这一行数据，然后更新并写入存储引擎。</li></ol><h3 id="2-重要的日志模块"><a href="#2-重要的日志模块" class="headerlink" title="2 重要的日志模块"></a>2 重要的日志模块</h3><h4 id="redo-log"><a href="#redo-log" class="headerlink" title="redo log"></a>redo log</h4><p>让我们继续以上面一条SQL语句为例，看看<code>redo log</code>是起到了什么作用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; update T set c=c+1 where ID=2;</span><br></pre></td></tr></table></figure></p><p>MySQL在执行这条语句时，肯定是先把<code>ID=2</code>这条数据从搜索引擎中拿出来，然后修改<code>c</code>字段，写入存储引擎，最后存储引擎刷入磁盘，这没问题吧？</p><p>MySQL的基本存储结构是<code>页</code>，所以MySQL是先把这条记录所在的<code>页</code>找到，然后再把该页的数据加载到内存，在内存中找到对应的数据后修改，再刷回磁盘。</p><p><strong>问题1</strong><br>如果在内存把数据修改了，但是还没来得及刷回磁盘数据库却突然岩机了怎么办？很显然数据就丢失了，这和我们预期的不一样。</p><p><strong>如何解决</strong><br>也许你会说很简单阿，在事务提交之前写入磁盘就行了。</p><p><strong>问题2</strong><br>如果每一次更新操作都需要刷回磁盘，这整个过程<code>IO</code>成本、查找记录成本都很高。一个页有<code>16kb</code>大小，只改一点内容就操作一次磁盘，为了解决这个问题。MySQL引入了<code>WAL</code>这么一个概念（Write-Ahead Logging），先写入日志，再写磁盘，至于什么时候再写入磁盘，会有配置供我们设置。</p><p>此时就引入<code>redo log</code>，当数据修改的时候，不仅在内存中操作，还会在<code>redo log</code>中记录这次操作，此时<code>redo log</code>的状态为<code>prepare</code>。当事务提交的时<code>redo log</code>日志将从<code>prepare</code>状态修改为<code>commit</code>，也就是我们所说的<strong>两阶段提交</strong>，然后再根据需要将更新完的数据刷入磁盘。当数据库岩机重启的时候，之前提交的记录都不会丢失，会恢复<code>redo log</code>中的内容到数据库，再根据<code>undo log</code>和<code>binlog</code>决定回滚还是提交数据。这个能力称为<code>crash-safe</code>。</p><p><code>redo log</code>记录的是物理变化，即内容修改（在某个数据页上做了什么修改）。它也是需要磁盘的，但它的好处是<code>顺序IO</code>，比<code>随机IO</code>快多了。</p><h4 id="undo-log"><a href="#undo-log" class="headerlink" title="undo log"></a>undo log</h4><p><code>undo log</code>是用来保证事务的原子性，它记录数据被修改前的值，以便在事务失败的时候进行<code>rollback</code>。举个栗子，当事务提交成功后，在将<code>redo log</code>从<code>perpare</code>状态修改成<code>commit</code>时系统异常重启了，那么<code>redo log</code>会根据自身的状态并结合<code>undo log</code>进行回滚。</p><h4 id="binlog"><a href="#binlog" class="headerlink" title="binlog"></a>binlog</h4><p>MySQL 整体来看，其实就有两块：一块是 Server 层，它主要做的是 MySQL 功能层面的事情；还有一块是引擎层，负责存储相关的具体事宜。<code>redo log</code>是<code>InnoDB</code>引擎特有的日志，而 Server 层也有自己的日志，称为 <code>binlog</code>（归档日志）。</p><p><code>binlog</code>记录了数据库表结构和表数据变更，比如<code>update/delete/insert/truncate/create</code>。它不会记录<code>select</code>（因为这没有对表没有进行变更）。</p><p>我们可以简单理解为：存储着每条变更的SQL语句。</p><h4 id="复制和恢复数据"><a href="#复制和恢复数据" class="headerlink" title="复制和恢复数据"></a>复制和恢复数据</h4><p>主要有两个作用：</p><ul><li>MySQL在公司使用的时候往往都是一主多从结构的，从服务器需要与主服务器的数据保持一致，这就是通过binlog来实现的。</li><li>数据库的数据被干掉了，我们可以通过binlog来对数据进行恢复。</li></ul><p>因为binlog记录了数据库表的变更，所以我们可以复制（主从复制)和恢复数据。</p><h4 id="执行流程"><a href="#执行流程" class="headerlink" title="执行流程"></a>执行流程</h4><p>有了对这两个日志的概念性理解，我们再来看执行器和<code>InnoDB</code>引擎在执行上面简单的<code>update</code>语句时的内部流程。</p><ol><li>执行器先找引擎取 ID=2 这一行。ID 是主键，引擎直接用树搜索找到这一行。如果 ID=2 这一行所在的数据页本来就在内存中，就直接返回给执行器；否则，需要先从磁盘读入内存，然后再返回。</li><li>执行器拿到引擎给的行数据，把这个值加上 1，比如原来是 N，现在就是 N+1，得到新的一行数据，再调用引擎接口写入这行新数据。</li><li>引擎将这行新数据更新到内存中，同时将这个更新操作记录到 redo log 里面，此时 redo log 处于 prepare 状态。然后告知执行器执行完成了，随时可以提交事务。</li><li>执行器生成这个操作的 binlog，并把 binlog 写入磁盘。</li><li>执行器调用引擎的提交事务接口，引擎把刚刚写入的 redo log 改成提交（commit）状态，更新完成。</li></ol><p>update 语句的执行流程图：</p><center><img src="/static/mysql/zxliucheng.png" alt="流程"></center><h3 id="3-redo-log和binlog的不同"><a href="#3-redo-log和binlog的不同" class="headerlink" title="3 redo log和binlog的不同"></a>3 redo log和binlog的不同</h3><h4 id="3-1-存储上"><a href="#3-1-存储上" class="headerlink" title="3.1 存储上"></a>3.1 存储上</h4><p>redo log 是物理日志，记录的是“在某个数据页上做了什么修改”；binlog 是逻辑日志，记录的是这个语句的原始逻辑，比如“给 ID=2 这一行的 c 字段加 1 ”。</p><h4 id="3-2-功能"><a href="#3-2-功能" class="headerlink" title="3.2 功能"></a>3.2 功能</h4><p>redo log的作用是为<strong>持久化</strong>而生的。写完内存，如果数据库挂了，那我们可以通过redo log来恢复内存还没来得及刷到磁盘的数据，将redo log加载到内存里边，那内存就能恢复到挂掉之前的数据了。</p><p>binlog的作用是复制和恢复而生的。</p><p>主从服务器需要保持数据的一致性，通过binlog来同步数据。<br>如果整个数据库的数据都被删除了，binlog存储着所有的数据变更情况，那么可以通过binlog来对数据进行恢复。</p><p>那么如果整个数据库的数据都被删除了，那我可以用redo log的记录来恢复吗？</p><p>不能，因为功能的不同，redo log 存储的是物理数据的变更，如果我们内存的数据已经刷到了磁盘了，那redo log的数据就无效了。所以redo log不会存储着历史所有数据的变更，文件的内容会被覆盖的。</p><h4 id="3-3-写入细节"><a href="#3-3-写入细节" class="headerlink" title="3.3 写入细节"></a>3.3 写入细节</h4><p>redo log 是 InnoDB 引擎特有的；binlog 是 MySQL 的 Server 层实现的，所有引擎都可以使用。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;用了这么久数据库，却不知道数据库是如何执行我们输入的语句的，经过一番查阅后，记录下执行一条查询和更新SQL语句后，MySQL是如何工作的。&lt;/p&gt;
&lt;p&gt;SQL语句基本的执行链路：&lt;/p&gt;
&lt;center&gt;&lt;img src=&quot;/static/mysql/liucheng.p
      
    
    </summary>
    
      <category term="数据库" scheme="https://jiawea.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="MySQL" scheme="https://jiawea.github.io/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>MySQL事务和锁</title>
    <link href="https://jiawea.github.io/2020/07/18/MySQL_block/"/>
    <id>https://jiawea.github.io/2020/07/18/MySQL_block/</id>
    <published>2020-07-18T02:30:18.000Z</published>
    <updated>2020-11-18T03:47:15.190Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-事务"><a href="#1-事务" class="headerlink" title="1.事务"></a>1.事务</h3><h4 id="1-1-事务的概念"><a href="#1-1-事务的概念" class="headerlink" title="1.1 事务的概念"></a>1.1 事务的概念</h4><p>事务是一组连续的操作集合，MySQL中默认<code>AUTOCOMMIT</code>是为<code>1</code>，也就是说每一次请求都是一个独立的事务，即改请求会被立即执行。以<code>START TRANSACTION</code>;或<code>BEGIN</code>开始一个事务,以<code>COMMIT</code>或者<code>ROLLBACK</code>结束一次事务。</p><h4 id="1-2-事务的特性ACID"><a href="#1-2-事务的特性ACID" class="headerlink" title="1.2 事务的特性ACID"></a>1.2 事务的特性ACID</h4><p><strong>A 原子性</strong></p><p>一个事务必须保证其中的操作要么全部执行，要么全部回滚，不可能存在只执行了一部分这种情况出现。</p><p><strong>C 一致性</strong><br>数据必须保证从一种一致性的状态转换为另一种一致性状态。<br>比如上一个事务中执行了第二步时系统崩溃了，数据也不会出现bill的账户少了100块，但是tim的账户没变的情况。要么维持原装（全部回滚），要么bill少了100块同时tim多了100块，只有这两种一致性状态的。</p><p><strong>I 隔离性</strong><br>在一个事务未执行完毕时，通常会保证其他事务无法看到这个事务的执行结果。</p><p><strong>D 持久性</strong><br>事务一旦commit，则数据就会保存下来，即使提交完之后系统崩溃，数据也不会丢失。</p><h3 id="2-隔离级别"><a href="#2-隔离级别" class="headerlink" title="2.隔离级别"></a>2.隔离级别</h3><h4 id="2-1-读未提交"><a href="#2-1-读未提交" class="headerlink" title="2.1 读未提交"></a>2.1 读未提交</h4><p>会出现脏读。一事务未提交的中间状态的更新数据被其他会话读取到。</p><h4 id="2-2-读已提交"><a href="#2-2-读已提交" class="headerlink" title="2.2 读已提交"></a>2.2 读已提交</h4><p>解决脏读，会出现幻读。会话A事务中执行一次查询，然后会话A新插入一行满足A事务查询条件的记录，此时A事务重新查询时，导致A事务两次读取的数据不一致。</p><h4 id="2-3-可重复读"><a href="#2-3-可重复读" class="headerlink" title="2.3 可重复读"></a>2.3 可重复读</h4><p>解决幻读。</p><h4 id="2-4-串行化"><a href="#2-4-串行化" class="headerlink" title="2.4 串行化"></a>2.4 串行化</h4><p>最强的隔离级别，通过给事务中每次读取的行加锁，写加写锁，可能会导致大量超时以及锁争用问题。</p><h3 id="3-锁"><a href="#3-锁" class="headerlink" title="3.锁"></a>3.锁</h3><h5 id="3-1-共享锁（S）"><a href="#3-1-共享锁（S）" class="headerlink" title="3.1 共享锁（S）"></a>3.1 共享锁（S）</h5><p>共享锁也称为读锁，读锁允许多个连接可以同一时刻并发的读取同一资源,互不干扰</p><h5 id="3-2-排它锁（X）"><a href="#3-2-排它锁（X）" class="headerlink" title="3.2 排它锁（X）"></a>3.2 排它锁（X）</h5><p>排他锁也称为写锁，一个写锁会阻塞其他的写锁或读锁，保证同一时刻只有一个连接可以写入数据，同时防止其他用户对这个数据的读写。</p><h3 id="4-避免死锁"><a href="#4-避免死锁" class="headerlink" title="4.避免死锁"></a>4.避免死锁</h3><p>如何避免使用行锁<code>FOR UPDATE</code>时导致死锁问题：</p><ol><li>以固定的顺序访问数据，例如两个更新数据的事务，事务A更新数据的顺序为1，2；事务B更新数据的顺序为2，1。这样更可能会造成死锁。</li><li>在同一个事务中，尽可能做到一次锁定所需要的所有资源，减少死锁概率。</li><li>为表添加合理的索引。可以看到如果不走索引将会为表的每一行记录添加上锁，死锁的概率大大增大。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-事务&quot;&gt;&lt;a href=&quot;#1-事务&quot; class=&quot;headerlink&quot; title=&quot;1.事务&quot;&gt;&lt;/a&gt;1.事务&lt;/h3&gt;&lt;h4 id=&quot;1-1-事务的概念&quot;&gt;&lt;a href=&quot;#1-1-事务的概念&quot; class=&quot;headerlink&quot; title=
      
    
    </summary>
    
      <category term="数据库" scheme="https://jiawea.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="MySQL" scheme="https://jiawea.github.io/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>TCP/IP协议</title>
    <link href="https://jiawea.github.io/2020/06/26/TCP-IP/"/>
    <id>https://jiawea.github.io/2020/06/26/TCP-IP/</id>
    <published>2020-06-26T12:28:06.000Z</published>
    <updated>2020-06-29T02:30:21.415Z</updated>
    
    <content type="html"><![CDATA[<p>最近重新学习了网络原理这一门课，趁着这机会，也对TCP/IP做一下总结吧。</p><center><img src="/static/network/hh.png" alt="avatar"></center><h3 id="一、-计算机网络体系结构分层"><a href="#一、-计算机网络体系结构分层" class="headerlink" title="一、 计算机网络体系结构分层"></a>一、 计算机网络体系结构分层</h3><center><img src="/static/network/tx1.png" alt="avatar"></center><p>OSI模型和TCP/IP模型上有一些区别，每一层都是处理自己的事情，然后交给下一层处理。</p><h3 id="二、-TCP-IP协议"><a href="#二、-TCP-IP协议" class="headerlink" title="二、 TCP/IP协议"></a>二、 TCP/IP协议</h3><p>互联网协议套件（Internet Protocol Suite，IPS）是一个网络通讯模型，以及整个网络传输协议家族，为网际网络的基础通讯架构。它通常被称为<code>TCP/IP</code>协议族（TCP/IP Protocols），简称<code>TCP/IP</code>。</p><p><code>TCP</code>（传输控制协议）和<code>IP</code>（网际协议）是最先定义的两个核心协议，所以才统称为<code>TCP/IP</code>协议族</p><h3 id="三、-分层"><a href="#三、-分层" class="headerlink" title="三、 分层"></a>三、 分层</h3><p>TCP/IP协议族中有一个很重要一点就是分层管理，依次为以下四层，应用层，传输层，网络层，数据链路层（也有叫网络接口层/网际层）。应用层和传输层是计算机处理的，而下面两层则是通讯设备负责。</p><center><img src="/static/network/model.png" alt="avatar"></center><p>TCP/IP分层管理是有好处的，假如互联网只有一个协议统筹，某一个地方改变设计时，就需要把所有部分都替换掉，而分层只需要把变动的层替换掉即可。</p><h3 id="四、-应用层"><a href="#四、-应用层" class="headerlink" title="四、 应用层"></a>四、 应用层</h3><p>应用层是网络相关的程序为了通过网络与其他程序通信所使用的层。这个层的处理过程是应用特有的；数据从网络相关的程序以这种应用内部使用的格式进行传送，然后被编码成标准协议的格式。<br>例如我们所熟悉的：</p><ul><li>HTTP（万维网服务）</li><li>FTP（文件传输）</li><li>SMTP（电子邮件）</li><li>SSH（安全远程登陆）</li><li>DNS（名称<-> IP地址寻找,域名系统）</-></li></ul><p>应用层将数据编码成一个标准的应用层协议，然后将它传送到下一层（传输层）</p><h3 id="五、-传输层"><a href="#五、-传输层" class="headerlink" title="五、 传输层"></a>五、 传输层</h3><p>TCP/IP 中有两个具有代表性的传输层协议，分别是 TCP 和 UDP。</p><table><thead><tr><th style="text-align:center">特点</th><th style="text-align:center">TCP</th><th style="text-align:center">UDP</th></tr></thead><tbody><tr><td style="text-align:center">是否连接</td><td style="text-align:center">面向连接</td><td style="text-align:center">无连接</td></tr><tr><td style="text-align:center">是否可靠</td><td style="text-align:center">可靠传输，使用流量控制和拥塞控制</td><td style="text-align:center">不可靠传输，不使用流量控制和拥塞控制</td></tr><tr><td style="text-align:center">传输方式</td><td style="text-align:center">面向字节流</td><td style="text-align:center">面向报文</td></tr><tr><td style="text-align:center">首部开销</td><td style="text-align:center">首部最小20字节，最大60字节</td><td style="text-align:center">首部开销小，仅8字节</td></tr><tr><td style="text-align:center">场景</td><td style="text-align:center">适用于要求可靠传输的应用，例如文件传输</td><td style="text-align:center">适用于实时应用（IP电话、视频会议、直播等）</td></tr></tbody></table><h4 id="1-端口号"><a href="#1-端口号" class="headerlink" title="1.端口号"></a>1.端口号</h4><p>数据链路和 IP 中的地址，分别指的是 MAC 地址和 IP 地址。前者用来识别同一链路中不同的计算机，后者用来识别 TCP/IP  网络中互连的主机和路由器。在传输层也有这种类似于地址的概念，那就是端口号。端口号用来识别同一台计算机中进行通信的不同应用程序。因此，它也被称为程序地址。</p><p><strong>根据端口号识别应用程序</strong><br>一台计算机上同时可以运行多个程序。传输层协议正是利用这些端口号识别本机中正在进行通信的应用程序，并准确地将数据传输。</p><center><img src="/static/network/port.png" alt="avatar"></center><p><strong>根据IP 地址、端口号、协议号进行通信识别</strong><br>仅凭目标端口号识别某一个通信是远远不够的，所有还需要IP地址等，如：</p><center><img src="/static/network/ip-port1.png" alt="avatar"></center><br><center><img src="/static/network/ip-port2.png" alt="avatar"></center><h4 id="2-端口号的确认"><a href="#2-端口号的确认" class="headerlink" title="2.端口号的确认"></a>2.端口号的确认</h4><p>传输层端口号为16位整数。</p><ul><li>熟知端口号： <code>0~1023</code></li><li>登记端口号： <code>1024~49151</code></li><li>客户端口号/短暂端口号： <code>49152~65535</code></li></ul><h4 id="3-UDP"><a href="#3-UDP" class="headerlink" title="3.UDP"></a>3.UDP</h4><p>UDP是无连接服务，在数据传输之前无需与对端进行任何信息交换（握手），直接构造传输层报文段并向接收端发送。类似于邮政系统的信件通信，邮寄信件之前无需跟收件人交换任何信息，写好信件后直接交给投递员就好了。</p><h4 id="4-TCP"><a href="#4-TCP" class="headerlink" title="4.TCP"></a>4.TCP</h4><p>TCP是面向连接服务，在数据传输之前需要双方交换一些控制信息，建立逻辑连接，然后再传输数据，数据传输结束后还需要再拆除连接。类似于电话通讯，必须首先拨号，建立电话连接，对方接起电话后，才可以进行语音交互通信，通信结束后还需要挂断电话拆除连接。</p><h4 id="5-复用与分解"><a href="#5-复用与分解" class="headerlink" title="5.复用与分解"></a>5.复用与分解</h4><p>众多应用程序公用一个传输层协议，并能够实现将接收到的数据准确交互给不同的应用进程，要实现这一基本功能，称为<span style="border-bottom:2px dashed red;">传输层的多路复用和多路分解。</span></p><p>一个网络应用程序通过一个或多个套接字，实现与传输层之间的数据传递。因此，在接收主机中的传输层实际上并没有直接将数据交付给进程，而是先将数据交付给了与接收进程相关联的一个中间套接字，每个套接字都必须有唯一的标识符。这样传输层协议才能将数据交付给正确的套接字。</p><p>下面是UDP和TCP套接字的区别：</p><center><img src="/static/network/udp.png" alt="avatar"></center><br><center><img src="/static/network/tcp.png" alt="avatar"></center><h4 id="6-TCP报文结构"><a href="#6-TCP报文结构" class="headerlink" title="6.TCP报文结构"></a>6.TCP报文结构</h4><p><code>TCP</code>报文段由首部字段和一个数据字段组成，而报文是有限制大小的，当TCP发送一个大文件时，通常会把该文件划分为长度为<code>MSS</code>(最大报文长度，Maximum Segment Size)的若干块，每个数据封装了一个<code>TCP报文</code>分别发送，报文结构如下：</p><center><img src="/static/network/baowen.png" alt="avatar"></center><p><strong>序列号<code>SEQ</code>和确认号<code>ACK</code></strong><br><span style="border-bottom:2px dashed red;">TCP网络中，为了保障每个连接提供有保证和有序的字节传递，使用了<code>Sequence Number</code> (,序列号)和 <code>Acknowledgment Number</code>(确认号)，即<code>seq</code>和<code>ack</code>。</span></p><ul><li><code>seq</code>表示每次传输中字节的偏移量。</li><li><code>ack</code>表示期望下一次接收的<code>seq</code>是多少。</li></ul><p><strong>同步序列号<code>SYN</code></strong><br>当<code>SYN=1</code>时，表示该<code>TCP</code>报文段是一个建立新连接请求控制段或者是同意建立新连接的确认段（此时<code>ACK=1</code>）。</p><p><strong><code>FIN</code></strong><br><code>FIN</code>用来释放一个<code>TCP</code>连接，当<code>FIN=1</code>时，表明改<code>TCP</code>报文段的发送端数据已发送完毕，并请求释放连接。</p><h4 id="7-TCP三次握手"><a href="#7-TCP三次握手" class="headerlink" title="7.TCP三次握手"></a>7.TCP三次握手</h4><center><img src="/static/network/3.png" alt="avatar"></center><h4 id="8-TCP四次挥手"><a href="#8-TCP四次挥手" class="headerlink" title="8.TCP四次挥手"></a>8.TCP四次挥手</h4><center><img src="/static/network/4.png" alt="avatar"></center>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近重新学习了网络原理这一门课，趁着这机会，也对TCP/IP做一下总结吧。&lt;/p&gt;
&lt;center&gt;&lt;img src=&quot;/static/network/hh.png&quot; alt=&quot;avatar&quot;&gt;&lt;/center&gt;

&lt;h3 id=&quot;一、-计算机网络体系结构分层&quot;&gt;&lt;a hr
      
    
    </summary>
    
      <category term="网络" scheme="https://jiawea.github.io/categories/%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="tcp/ip" scheme="https://jiawea.github.io/tags/tcp-ip/"/>
    
  </entry>
  
  <entry>
    <title>Golang的值类型和引用类型</title>
    <link href="https://jiawea.github.io/2020/05/27/Go_variable/"/>
    <id>https://jiawea.github.io/2020/05/27/Go_variable/</id>
    <published>2020-05-27T01:00:26.000Z</published>
    <updated>2020-06-10T01:13:55.507Z</updated>
    
    <content type="html"><![CDATA[<h3 id="值类型和引用类型"><a href="#值类型和引用类型" class="headerlink" title="值类型和引用类型"></a>值类型和引用类型</h3><ul><li>值类型：变量直接存储，内存通常在栈中分配。</li><li>引用类型：变量存储的是一个地址，这个地址存储最终的值。内存通常在堆上分配。通过GC回收</li></ul><p>PS : 通常在函数中转入指针效率比较高，因为方法中的参数是需要进行拷贝的，拷贝指针的效率比较高，要是一个大的接口体的话拷贝的效率就比较低</p><h3 id="GoLang中的值类型和引用类型"><a href="#GoLang中的值类型和引用类型" class="headerlink" title="GoLang中的值类型和引用类型"></a>GoLang中的值类型和引用类型</h3><ol><li>值类型 ： 基本数据类型int、float、bool、string以及数组和struct。</li><li>引用类型：指针、slice、map、chan等都是引用类型</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;值类型和引用类型&quot;&gt;&lt;a href=&quot;#值类型和引用类型&quot; class=&quot;headerlink&quot; title=&quot;值类型和引用类型&quot;&gt;&lt;/a&gt;值类型和引用类型&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;值类型：变量直接存储，内存通常在栈中分配。&lt;/li&gt;
&lt;li&gt;引用类型：变量存储
      
    
    </summary>
    
      <category term="后端" scheme="https://jiawea.github.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
      <category term="Golang" scheme="https://jiawea.github.io/tags/Golang/"/>
    
      <category term="值类型" scheme="https://jiawea.github.io/tags/%E5%80%BC%E7%B1%BB%E5%9E%8B/"/>
    
      <category term="引用类型" scheme="https://jiawea.github.io/tags/%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>Redis类型及应用场景</title>
    <link href="https://jiawea.github.io/2020/05/24/Redis/"/>
    <id>https://jiawea.github.io/2020/05/24/Redis/</id>
    <published>2020-05-24T04:26:00.000Z</published>
    <updated>2020-06-10T01:12:56.119Z</updated>
    
    <content type="html"><![CDATA[<p>NoSQL非关系型数据库。<br>Redis支持5种数据类型：string(字符串), hash(哈希), list(双向列表), set(无序集合), zset(有序集合)</p><h3 id="1、string"><a href="#1、string" class="headerlink" title="1、string"></a>1、string</h3><p><strong>介绍</strong><br>string数据类型是最常用的、简单的key-value类型，普通的key/value存储都可以归为此类。value也可以是数字。因为是二进制安全的，所有可以将一个图片文件的内容作为string来存储。redis的string完全实现目前<code>memcached</code>的功能，并且效率更高。除了提供与memcached一样的<code>get</code>,<code>set</code>,<code>incr</code>,<code>decr</code>等操作外，还提供了下面的操作：</p><ol><li>获取字符串长度</li><li>往字符串append内容</li><li>设置和获取字符串的某一段内容</li><li>设置和获取字符串的某一位(bit)</li><li>批量设置一系列字符串的内容</li></ol><a id="more"></a><p><strong>应用场景</strong></p><ol><li>应用memcached和ckv的所有场景。字符串和数字之间存取。结构化数据需要先序列化，再set到value，取出时也需要反序列化。</li><li>可以利用INCR, INCRBY, DECR, DECRBY等指令来实现原子计数的效果。即可用来实现业务上的统计计数需求。</li><li>存放session key，实现一个分布式session系统。Redis的key可以方便地设置过期时间，用于实现session key的自动过期。验证skey时先根据uid路由到对应的redis，如取不到skey，则表示skey已过期，需要重新登录；如取到skey且校验通过则升级此skey的过期时间即可。</li><li>Set nx或SetNx，仅当key不存在时才Set。可以用来选举Master或实现分布式锁：所有Client不断尝试使用SetNx master myName抢注Master，成功的那位不断使用Expire刷新它的过期时间。如果Master挂掉了key就会失效，剩下的节点又会发生新一轮抢夺。</li><li>借助redis2.6开始支持的lua脚本，可以实现更安全的2种分布式锁：一种适用于各进程竞争但总是单个进程获取锁并处理的场景。除非原处理进程挂掉因而锁过期才会被其它进程获取到锁。无须主动解锁。通过get、expire/pexpire、setnx ex| px的lua脚本实现；一种适用于各进程竞争获取锁并处理的场景。通过set nx ex| px获取锁，用完需要通过先get判断再del释放锁，否则在锁过期之前不能获取到锁。</li><li>GetSet， 设置新值，返回旧值。比如实现一个计数器，可以用GetSet获取计数并重置为0。</li><li>GetBit/SetBit/BitOp/BitCount， BitMap的玩法，比如统计今天的独立访问用户数时，每个注册用户都有一个offset，他今天进来的话就把他那个位设为1，用BitCount就可以得出今天的总人数。</li><li>Append/SetRange/GetRange/StrLen，对文本进行扩展、替换、截取和求长度，对特定数据格式非常有用。</li></ol><p><strong>实现方式</strong><br>String在redis内部存储默认就是一个字符串，被redisObject所引用，当遇到incr,decr等操作时会转成数值型进行计算，此时<code>redisObject</code>的encoding字段为<code>int</code>。</p><h3 id="2-Hash"><a href="#2-Hash" class="headerlink" title="2. Hash"></a>2. Hash</h3><p><strong>介绍</strong><br>Hash存的是字符串和字符串值之间的映射。Hash将对象的各个属性存入Map里，可以只读取/更新对象的某些属性。</p><p>常用命令: <code>hget</code>, <code>hset</code>, <code>hgetall</code>等。</p><p><strong>应用场景</strong></p><ol><li>存放结构化数据，比如用户信息。如果存放string的方式的话，修改用户信息中某一项时，需要取出后反序列化后修改完，再序列化回去。这样不仅增大了开销，也不适用于一些可能并发操作的场合。</li><li>需要注意的是，Redis提供的<code>hgetall</code>可以直接取到全部的属性数据，但是数据过多的话，那么涉及到遍历整个内部的map操作，由于Redis是<code>单线程</code>模型，这个操作可能会比较耗时，而对其他客户端的请求完全不响应。</li></ol><p><strong>实现方式</strong><br>Hash对应的value内部实际就是一个<code>HashMap</code>，这里会有2种不同实现，这个Hash的成员比较少时Redis为了节省内存会采用类似一堆数组的方式来紧凑存储，而不会采用真正的HashMap结构，对应的<code>value redisObject</code>的encoding为<code>zipmap</code>，当成员数量增大时会自动转成真正的HashMap，此时的encoding为<code>ht</code>。</p><h3 id="3-List"><a href="#3-List" class="headerlink" title="3. List"></a>3. List</h3><p><strong>介绍</strong><br>List是一个双向链表，支持双向的pop、push，一般是FIFO(First In First Out)。<code>Blocking</code>版本的BLPop/BRPop，客户端可以阻塞在那里直到有消息到来。</p><p>按值的操作：LRem(按值删除元素)、Linsert(在某个元素插入)，复杂度是O(N)，因为List的值不唯一，所以要遍历全部元素，而Set只要O(log(N))。</p><p>按下标操作：LSet、LIndex、LRange，LTrim可限制长度，比如只保留最新N条消息。复杂度O(N),因为List是链表而不是数组，所以按下标访问其实要遍历链表，除非下标刚好是队头和队尾。</p><p>常用命令：<code>lpush</code>, <code>rpush</code>, <code>lpop</code>, <code>lrange</code>等。 </p><p><strong>应用场景</strong></p><ol><li>各自列表。比如twitter的关注列表、粉丝列表等，最新消息排行、每篇文章的评论等也可以用List结构实现。</li><li>消息队列，将任务push到List中，然后工作线程再用pop操作把任务取走。这里的消息队列并没有<code>ACK</code>机制，如果消费者把任务pop走了没处理完就死机了怎么办？解决方法之一就是多加一个<code>sorted set</code>，分发的时候同时发到<code>List</code>与<code>sorted set</code>，以分发时间为<code>score</code>，消费者把任务做完之后通过<code>ZREM</code>删除<code>sorted set</code>里的job，并且定时取出超时未完成的任务，重新放回<code>List</code>。</li><li>利用LRange可以方便的实现List内容分页的功能。</li></ol><p><strong>实现方式</strong><br>List是一个双向链表，即可以支持方向查找和遍历等操作，不过带来了部分额外的内存开销，Redis内部的很多实现，包括发送缓冲队列等也是用这个数据结构。</p><h3 id="4-Set"><a href="#4-Set" class="headerlink" title="4. Set"></a>4. Set</h3><p><strong>介绍</strong><br>Set是一种无序的集合，集合中的元素没有先后顺序，不重复。将重复的元素放入Set会自动去重。</p><p><strong>应用场景</strong></p><ol><li>某些需要去重的列表，并且set提供了判断某个元素是否存在一个set集合内的接口</li><li>存储一些集合性的数据，比如在微博中，可以将一个用户的所有关注人存在一个集合中，并将所有粉丝也存入一个集合中。Redis还提供了集合求交集、并集、差集操作。可以非常方便的实现如共同关注、共同喜好。</li></ol><p><strong>实现方式</strong><br>set的内部实现是一个value用户为<code>null</code>的HashMap，实际就是通过计算hash的方式来快速排重，这也是set能提供判断一个成员是否在这个集合内的原因。</p><h3 id="5-Sorted-Set"><a href="#5-Sorted-Set" class="headerlink" title="5. Sorted Set"></a>5. Sorted Set</h3><p><strong>介绍</strong><br>有序集合，相比Set，元素放入集合时还要提供该元素的分数，可根据分数自动排序。</p><p><strong>应用场景</strong></p><ol><li>存放一个有序的并且不重复的集合列表，比如twitter的pubilc timeline可以以发表时间作为score来存储，这样获取时就是自动按时间排好序的。</li><li>可以做带权重的队列，比如普通消息的<code>score</code>为1，重要消息的score为2，然后工作线程可以按score的倒序来获取工作任务，然重要的先执行。</li></ol><p><strong>实现方式</strong><br>sorted set的内部使用HashMap和跳跃表(SkipList)来保证数据的存储和有序，HashMap里放的是成员到score的映射，而跳跃表里存放的是所有的成员，排序依据是HashMap里存的score，使用跳跃表的结构可以获取比较高的查找效率。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;NoSQL非关系型数据库。&lt;br&gt;Redis支持5种数据类型：string(字符串), hash(哈希), list(双向列表), set(无序集合), zset(有序集合)&lt;/p&gt;
&lt;h3 id=&quot;1、string&quot;&gt;&lt;a href=&quot;#1、string&quot; class=&quot;headerlink&quot; title=&quot;1、string&quot;&gt;&lt;/a&gt;1、string&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;介绍&lt;/strong&gt;&lt;br&gt;string数据类型是最常用的、简单的key-value类型，普通的key/value存储都可以归为此类。value也可以是数字。因为是二进制安全的，所有可以将一个图片文件的内容作为string来存储。redis的string完全实现目前&lt;code&gt;memcached&lt;/code&gt;的功能，并且效率更高。除了提供与memcached一样的&lt;code&gt;get&lt;/code&gt;,&lt;code&gt;set&lt;/code&gt;,&lt;code&gt;incr&lt;/code&gt;,&lt;code&gt;decr&lt;/code&gt;等操作外，还提供了下面的操作：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;获取字符串长度&lt;/li&gt;
&lt;li&gt;往字符串append内容&lt;/li&gt;
&lt;li&gt;设置和获取字符串的某一段内容&lt;/li&gt;
&lt;li&gt;设置和获取字符串的某一位(bit)&lt;/li&gt;
&lt;li&gt;批量设置一系列字符串的内容&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="数据库" scheme="https://jiawea.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="redis" scheme="https://jiawea.github.io/tags/redis/"/>
    
      <category term="NoSQL" scheme="https://jiawea.github.io/tags/NoSQL/"/>
    
  </entry>
  
  <entry>
    <title>MySQL性能调优</title>
    <link href="https://jiawea.github.io/2020/05/08/MySQLPerformance/"/>
    <id>https://jiawea.github.io/2020/05/08/MySQLPerformance/</id>
    <published>2020-05-08T01:30:18.000Z</published>
    <updated>2020-11-13T03:26:10.329Z</updated>
    
    <content type="html"><![CDATA[<h3 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h3><ul><li><a href="#服务器硬件的优化">服务器硬件的优化</a></li><li><a href="#MySQL数据库配置优化">MySQL数据库配置优化</a></li><li><a href="#MySQL的参数配置">MySQL的参数配置</a></li></ul><h3 id="服务器硬件的优化"><a href="#服务器硬件的优化" class="headerlink" title="服务器硬件的优化"></a>服务器硬件的优化</h3><p>提升硬件设备，例如选择尽量高频率的内存（频率不能高于主板的支持）、提升网络带宽、使用SSD高速磁盘、提升CPU性能等。</p><p>CPU的选择:</p><ul><li>对于数据库并发比较高的场景，CPU的数量比频率重要。</li><li>对于CPU密集型场景和频繁执行复杂SQL的场景，CPU的频率越高越好。</li></ul><h3 id="MySQL数据库配置优化"><a href="#MySQL数据库配置优化" class="headerlink" title="MySQL数据库配置优化"></a>MySQL数据库配置优化</h3><h3 id="MySQL的参数配置"><a href="#MySQL的参数配置" class="headerlink" title="MySQL的参数配置"></a>MySQL的参数配置</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;目录&quot;&gt;&lt;a href=&quot;#目录&quot; class=&quot;headerlink&quot; title=&quot;目录&quot;&gt;&lt;/a&gt;目录&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#服务器硬件的优化&quot;&gt;服务器硬件的优化&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#MySQL数据库配置优化
      
    
    </summary>
    
      <category term="数据库" scheme="https://jiawea.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="MySQL" scheme="https://jiawea.github.io/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>MySQL优化之SQL优化</title>
    <link href="https://jiawea.github.io/2020/05/08/MySQL/"/>
    <id>https://jiawea.github.io/2020/05/08/MySQL/</id>
    <published>2020-05-08T01:30:18.000Z</published>
    <updated>2020-11-13T03:26:15.488Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-查询SQL尽量不要使用-select-而是select具体字段。"><a href="#1-查询SQL尽量不要使用-select-而是select具体字段。" class="headerlink" title="1 查询SQL尽量不要使用 select * ,而是select具体字段。"></a>1 查询SQL尽量不要使用 <code>select *</code> ,而是<code>select</code>具体字段。</h3><p>反例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from employee;</span><br></pre></td></tr></table></figure></p><p>正例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select id, name from employee;</span><br></pre></td></tr></table></figure></p><p>说明:</p><ol><li>只取需要的字段，节省资源、减少网络开销。</li><li>select * 进行查询时，很可能就不会使用到覆盖索引了，就会造成回表查询。</li></ol><a id="more"></a><h3 id="2-如果只查询结果只有一条的数据或者最大、最小一条记录，使用limit"><a href="#2-如果只查询结果只有一条的数据或者最大、最小一条记录，使用limit" class="headerlink" title="2 如果只查询结果只有一条的数据或者最大、最小一条记录，使用limit"></a>2 如果只查询结果只有一条的数据或者最大、最小一条记录，使用limit</h3><p>假如有employee员工表，要找出一个名字叫ray的人<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE  `employee`(</span><br><span class="line">  `id` int (11) NOT NULL,</span><br><span class="line">  `name` varchar(255) DEFAULT NULL,</span><br><span class="line">  `age` int(11) DEFAULT NULL,</span><br><span class="line">  `date` datetime DEFAULT NULL,</span><br><span class="line">  `sex` int (1) DEFAULT NULL,</span><br><span class="line">  PRIMARY KEY (`id`)</span><br><span class="line">) ENGINE=InnoDB DEFAULT CHARSET=utf8;</span><br></pre></td></tr></table></figure></p><p>反例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select id, name from employee where name=&apos;ray&apos;</span><br></pre></td></tr></table></figure></p><p>正例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select id, name from employee where name=&apos;ray&apos; limit 1;</span><br></pre></td></tr></table></figure></p><p>说明：</p><ol><li>加上limit 1后,只要找到了对应的一条记录,就不会继续向下扫描了,效率将会大大提高。</li><li>当然，如果name是唯一索引的话，是不必要加上limit 1了，因为limit的存在主要就是为了防止全表扫描，从而提高性能,如果一个语句本身可以预知不用全表扫描，有没有limit ，性能的差别并不大。</li></ol><h3 id="3-批量插入"><a href="#3-批量插入" class="headerlink" title="3 批量插入"></a>3 批量插入</h3><p>反例<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">INSERT into person(name,age) values(&apos;A&apos;,24)</span><br><span class="line">INSERT into person(name,age) values(&apos;B&apos;,24)</span><br><span class="line">INSERT into person(name,age) values(&apos;C&apos;,24)</span><br></pre></td></tr></table></figure></p><p>正例<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">INSERT into person(name,age) values(&apos;A&apos;,24),(&apos;B&apos;,24),(&apos;C&apos;,24);</span><br></pre></td></tr></table></figure></p><p>说明:</p><ol><li>比较常规，就不多做说明了</li></ol><h3 id="4-优化like语句"><a href="#4-优化like语句" class="headerlink" title="4 优化like语句"></a>4 优化like语句</h3><p>尽量使用右模糊<code>xxx%</code>代替左模糊或者全模糊</p><p>反例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select userId, name from user where user_id like &apos;%123&apos;;</span><br><span class="line">select userId, name from user where user_id like &apos;%123%&apos;;</span><br></pre></td></tr></table></figure></p><p>正例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select userId, name from user where user_id like &apos;123%&apos;;</span><br></pre></td></tr></table></figure></p><h3 id="5-避免SQL中对where字段进行函数转换或表达式计算"><a href="#5-避免SQL中对where字段进行函数转换或表达式计算" class="headerlink" title="5 避免SQL中对where字段进行函数转换或表达式计算"></a>5 避免SQL中对where字段进行函数转换或表达式计算</h3><p>反例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from employee where user_id + 1 = 15551;</span><br></pre></td></tr></table></figure></p><p>正例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from employee where user_id  = 15550;</span><br></pre></td></tr></table></figure></p><p>说明：</p><ol><li>将导致系统放弃使用索引而进行全表扫</li><li>其实在知道了有SQL优化器之后，我个人感觉这种普通的表达式转换应该可以提前进行处理再进行查询，这样一来就可以用到索引了，但是问题又来了，如果mysql优化器可以提前计算出结果，那么写sql语句的人也一定可以提前计算出结果，所以矛盾点在这个地方，导致5.7版本以前的此种情况都无法使用索引吧，未来可能会对其进行优化</li></ol><h3 id="6-超大分页场景解决方案-limit"><a href="#6-超大分页场景解决方案-limit" class="headerlink" title="6 超大分页场景解决方案(limit)"></a>6 超大分页场景解决方案(limit)</h3><p>我们日常做分页需求时，一般会用 limit 实现，但是当偏移量特别大的时候，查询效率就变得低下。</p><p>反例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select id, name, age from employee LIMIT 1000000, 10;</span><br></pre></td></tr></table></figure></p><p>正例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 方案一：返回上次查询的最大记录（偏移量）</span><br><span class="line">select id, name, age from employee id &gt; 1000000 limit 10;</span><br><span class="line"></span><br><span class="line">// 方案二：先通过索引查询需要的id</span><br><span class="line">select id, name, age from employee a, (select id from employee limit 1000000, 10) b where a.id = b.id;</span><br><span class="line"></span><br><span class="line">// 方案三：order by + 索引</span><br><span class="line">select id, name, age from employee order by id limit 1000000, 10</span><br></pre></td></tr></table></figure></p><p>说明：</p><ol><li>MySQL 并不是跳过 offset 行，而是取 offset+N 行，然后返回放弃前 offset 行，返回 N 行，那当 offset 特别大的时候，效率就非常的低下，要么控制返回的总页数，要么对超过特定阈值的页数进行 SQL 改写</li></ol><h3 id="7-尽量避免在where子句中使用-或-lt-gt-操作符，否则将引擎放弃使用索引而进行全表扫描。"><a href="#7-尽量避免在where子句中使用-或-lt-gt-操作符，否则将引擎放弃使用索引而进行全表扫描。" class="headerlink" title="7 尽量避免在where子句中使用!=或&lt;&gt;操作符，否则将引擎放弃使用索引而进行全表扫描。"></a>7 尽量避免在where子句中使用!=或&lt;&gt;操作符，否则将引擎放弃使用索引而进行全表扫描。</h3><p>反例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select age, name from user where age &lt;&gt; 18;</span><br></pre></td></tr></table></figure></p><p>正例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 可以考虑分开两条sql写</span><br><span class="line">select age, name from user where age &lt; 18;</span><br><span class="line">select age, name from user where age &gt; 18;</span><br></pre></td></tr></table></figure></p><p>说明：</p><ol><li>使用!=和&lt;&gt;很可能会让索引失效</li></ol><h3 id="8-对查询进行优化，应考虑在where及order-by涉及的列上建立索引，尽量避免全表扫描。"><a href="#8-对查询进行优化，应考虑在where及order-by涉及的列上建立索引，尽量避免全表扫描。" class="headerlink" title="8 对查询进行优化，应考虑在where及order by涉及的列上建立索引，尽量避免全表扫描。"></a>8 对查询进行优化，应考虑在where及order by涉及的列上建立索引，尽量避免全表扫描。</h3><p>对经常使用where和order by的字段加上索引</p><h3 id="9-where子句中考虑使用默认值代替null。"><a href="#9-where子句中考虑使用默认值代替null。" class="headerlink" title="9 where子句中考虑使用默认值代替null。"></a>9 where子句中考虑使用默认值代替null。</h3><p>反例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from user where age is not null;</span><br></pre></td></tr></table></figure></p><p>正例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 设置默认值为 0 </span><br><span class="line">select * from user where age &gt; 0;</span><br></pre></td></tr></table></figure></p><p>说明：</p><ol><li>并不是说使用了is null 或者 is not null 就会不走索引了，这个跟mysql版本以及查询成本都有关。</li><li>如果把null值，换成默认值，很多时候让走索引成为可能，同时，表达意思会相对清晰一点。</li></ol><h3 id="10-索引不宜太多，一般5个以内"><a href="#10-索引不宜太多，一般5个以内" class="headerlink" title="10 索引不宜太多，一般5个以内"></a>10 索引不宜太多，一般5个以内</h3><p>说明：</p><ol><li>索引并不是越多越好，索引虽然提高了查询的效率，但是也降低了插入和更新的效率。</li><li>insert或update时有可能会重建索引，所以建索引需要慎重考虑，视具体情况来定。</li><li>一个表的索引数最好不要超过5个，若太多需要考虑一些索引是否没有存在的必要。</li></ol><p>###　11 索引不适合建在有大量重复数据的字段上，如性别这类型数据库字段</p><p>说明：</p><ol><li>因为SQL优化器是根据表中数据量来进行查询优化的，如果索引列有大量重复数据，Mysql查询优化器推算发现不走索引的成本更低，很可能就放弃索引了。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-查询SQL尽量不要使用-select-而是select具体字段。&quot;&gt;&lt;a href=&quot;#1-查询SQL尽量不要使用-select-而是select具体字段。&quot; class=&quot;headerlink&quot; title=&quot;1 查询SQL尽量不要使用 select * ,而是select具体字段。&quot;&gt;&lt;/a&gt;1 查询SQL尽量不要使用 &lt;code&gt;select *&lt;/code&gt; ,而是&lt;code&gt;select&lt;/code&gt;具体字段。&lt;/h3&gt;&lt;p&gt;反例：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;select * from employee;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;正例：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;select id, name from employee;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;说明:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;只取需要的字段，节省资源、减少网络开销。&lt;/li&gt;
&lt;li&gt;select * 进行查询时，很可能就不会使用到覆盖索引了，就会造成回表查询。&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="数据库" scheme="https://jiawea.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="MySQL" scheme="https://jiawea.github.io/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>HTTP和WebSocket协议的区别</title>
    <link href="https://jiawea.github.io/2020/04/11/Http_WebSocket/"/>
    <id>https://jiawea.github.io/2020/04/11/Http_WebSocket/</id>
    <published>2020-04-11T07:30:00.000Z</published>
    <updated>2020-06-10T01:12:24.656Z</updated>
    
    <content type="html"><![CDATA[<p>最近需要实现一个可以和客户端进行实时通讯的后端服务，由于后端可以主动发送消息给客户端，如果使用<code>HTTP</code>的话服务端是不能主动向客户端发送信息的，之前对<code>Socket</code>只是一个大概的了解。所以查了一些相关的资料，记录一下<code>HTTP</code>和<code>WebSocket</code>的区别。</p><a id="more"></a><h3 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h3><p>HTTP是一个Request/Response请求和响应的模式，两种类型都是由请求行、请求头、空行、请求主体四部分组成。这里将不详细介绍，可看我之前的文章。<br>只有客户端向服务端发送一个请求后，服务端才能向客户端回复，客户端在没有请求服务端时，服务端是不能主动向客户端发送数据的。</p><h4 id="短连接"><a href="#短连接" class="headerlink" title="短连接"></a>短连接</h4><p>举个栗子：<br>比如说客户端想实时地知道某个状态是否<strong>发生</strong>变化时，于是请求了服务端，但是服务端此时又<strong>没有发生</strong>变化。遇到这种情况下客户端只能不断地想服务端发送请求，直到返回满意的结果。这也就是我们所说的<strong>轮询</strong>。这是一个很浪费资源的，因为每个资源都需要建立一个新的连接，而HTTP底层使用的是<code>TCP</code>，每次都需要三次握手建立连接，所以会造成资源浪费。</p><p>于是由引出了一个新的概念，<code>HTTP</code>长连接，这里的长连接和<code>socket</code>的长连接是有区别的，这个稍后再说。</p><h4 id="长连接"><a href="#长连接" class="headerlink" title="长连接"></a>长连接</h4><p>所谓的长连接就是客户端向服务端发送请求，服务端不需要马上回复客户端，只有等到服务端有结果了才向客户端回复。相比上面的短连接可以减少连接次数和压力。</p><center><img src="/static/blogImg/HTTP_connect.png" alt="avatar">WebSocket.png</center><p>在一个TCP连接上也可以传输多个Request/Response消息对，但是HTTP的基本模型还是一个Request对应一个Response。</p><h3 id="WebSocket"><a href="#WebSocket" class="headerlink" title="WebSocket"></a>WebSocket</h3><p>WebSocket 协议在2008年诞生，2011年成为国际标准。所有浏览器都已经支持了。</p><p>它的最大特点就是，服务器可以主动向客户端推送信息，客户端也可以主动向服务器发送信息，是真正的双向平等对话，属于服务器推送技术的一种。</p><center><img src="/static/blogImg/WebSocket.png" alt="avatar"></center><p>其他特点包括：</p><ol><li>建立在 TCP 协议之上，服务器端的实现比较容易。</li><li>与 HTTP 协议有着良好的兼容性。默认端口也是80和443，并且握手阶段采用 HTTP 协议，因此不容易屏蔽，能通过各种 HTTP 代理服务器。</li><li>数据格式比较轻量，性能开销小，通信高效。</li><li>可以发送文本，也可以发送二进制数据。</li><li>没有同源限制，客户端可以与任意服务器通信。</li><li>协议标识符是ws（如果加密，则为wss），服务器网址就是 URL。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ws://example.com:80/some/path</span><br></pre></td></tr></table></figure><center><img src="/static/blogImg/tcp_http_ws.png" alt="avatar"></center><h4 id="WebSocket协议的规范"><a href="#WebSocket协议的规范" class="headerlink" title="WebSocket协议的规范"></a>WebSocket协议的规范</h4><p>以下是一个典型的WebSocket发起请求到响应请求的示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">客户端到服务端：</span><br><span class="line">GET / HTTP/1.1</span><br><span class="line">Connection:Upgrade</span><br><span class="line">Host:127.0.0.1:8088</span><br><span class="line">Origin:null</span><br><span class="line">Sec-WebSocket-Extensions:x-webkit-deflate-frame</span><br><span class="line">Sec-WebSocket-Key:puVOuWb7rel6z2AVZBKnfw==</span><br><span class="line">Sec-WebSocket-Version:13</span><br><span class="line">Upgrade:websocket</span><br><span class="line"></span><br><span class="line">服务端到客户端：</span><br><span class="line">HTTP/1.1 101 Switching Protocols</span><br><span class="line">Connection:Upgrade</span><br><span class="line">Server:beetle websocket server</span><br><span class="line">Upgrade:WebSocket</span><br><span class="line">date: Thu, 10 May 2018 07:32:25 GMT</span><br><span class="line">Access-Control-Allow-Credentials:true</span><br><span class="line">Access-Control-Allow-Headers:content-type</span><br><span class="line">Sec-WebSocket-Accept:FCKgUr8c7OsDsLFeJTWrJw6WO8Q=</span><br></pre></td></tr></table></figure></p><p>我们可以看到，WebSocket协议和HTTP协议乍看并没有太大的区别，但细看下来，区别还是有些的，这其实是一个握手的http请求，首先请求和响应的，”Upgrade:WebSocket”表示请求的目的就是要将客户端和服务器端的通讯协议从 HTTP 协议升级到 WebSocket协议。从客户端到服务器端请求的信息里包含有”Sec-WebSocket-Extensions”、“Sec-WebSocket-Key”这样的头信息。这是客户端浏览器需要向服务器端提供的握手信息，服务器端解析这些头信息，并在握手的过程中依据这些信息生成一个28位的安全密钥并返回给客户端，以表明服务器端获取了客户端的请求，同意创建 WebSocket 连接。</p><p>当握手成功后，这个时候TCP连接就已经建立了，客户端与服务端就能够直接通过WebSocket直接进行数据传递。不过服务端还需要判断一次数据请求是什么时候开始的和什么时候是请求的结束的。在WebSocket中，由于浏览端和服务端已经打好招呼，如我发送的内容为utf-8编码，如果我发送0x00,表示包的开始，如果发送了0xFF，就表示包的结束了。这就解决了黏包的问题。</p><h4 id="与HTTP的相同点"><a href="#与HTTP的相同点" class="headerlink" title="与HTTP的相同点"></a>与HTTP的相同点</h4><ol><li>都是基于TCP的应用层协议。</li><li>都使用Request/Response模型进行连接的建立。</li><li>在连接的建立过程中对错误的处理方式相同，在这个阶段WS可能返回和HTTP相同的返回码。</li><li>都可以在网络中传输数据。</li></ol><h4 id="与HTTP的不同点"><a href="#与HTTP的不同点" class="headerlink" title="与HTTP的不同点"></a>与HTTP的不同点</h4><ol><li>WS使用HTTP来建立连接，但是定义了一系列新的header域，这些域在HTTP中并不会使用。</li><li>WS的连接不能通过中间人来转发，它必须是一个直接连接。</li><li>WS连接建立之后，通信双方都可以在任何时刻向另一方发送数据。</li><li>WS连接建立之后，数据的传输使用帧来传递，不再需要Request消息。</li><li>WS的数据帧有序。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近需要实现一个可以和客户端进行实时通讯的后端服务，由于后端可以主动发送消息给客户端，如果使用&lt;code&gt;HTTP&lt;/code&gt;的话服务端是不能主动向客户端发送信息的，之前对&lt;code&gt;Socket&lt;/code&gt;只是一个大概的了解。所以查了一些相关的资料，记录一下&lt;code&gt;HTTP&lt;/code&gt;和&lt;code&gt;WebSocket&lt;/code&gt;的区别。&lt;/p&gt;
    
    </summary>
    
      <category term="网络" scheme="https://jiawea.github.io/categories/%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="HTTP" scheme="https://jiawea.github.io/tags/HTTP/"/>
    
      <category term="WebSocket" scheme="https://jiawea.github.io/tags/WebSocket/"/>
    
      <category term="TCP" scheme="https://jiawea.github.io/tags/TCP/"/>
    
  </entry>
  
  <entry>
    <title>RPC是什么</title>
    <link href="https://jiawea.github.io/2020/03/27/WHAT-IS-RPC/"/>
    <id>https://jiawea.github.io/2020/03/27/WHAT-IS-RPC/</id>
    <published>2020-03-27T02:28:49.000Z</published>
    <updated>2020-06-10T01:13:22.706Z</updated>
    
    <content type="html"><![CDATA[<p>RPC（Remote Procedure Call Protocol）—— 远程过程调用协议，它是一种通过网络从远程计算机程序上请求服务，而不需要了解底层网络技术的协议。</p><p>​简单来说，就是跟远程访问或者web请求差不多，都是一个client向远端服务器请求服务返回结果，但是web请求使用的网络协议是<code>http</code>高层协议，而<code>rpc</code>所使用的协议多为<code>TCP</code>，是网络层协议，减少了信息的包装，加快了处理速度。</p><center><img src="/static/blogImg/RemoteProcedureCall.png" alt="client"></center><a id="more"></a><p>说起<code>RPC</code>，就不能不提到<code>分布式</code>（促使RPC诞生的领域）。</p><h3 id="举个栗子"><a href="#举个栗子" class="headerlink" title="举个栗子.."></a>举个栗子..</h3><p>假如你实现了一个计算器接口，Caculator，以及它实现类CalculatorImpl，那么在系统还是单位应用时，只需要new一个CalculatorImpl，然后直接调用其方法，例如<code>add</code>，<code>times</code>等就可以了，这就是普通的<code>本地调用</code>，因为在同一个地址空间/同一块内存。</p><p>但是由于业务上的考虑，基于高性能可靠等因素你得将系统改造为<code>分布式应用</code>。将很多可以共用的分享功能单独做成一个服务，让其他所有服务可以直接调用。</p><p>那么问题来了，如何调用这个单独出来的服务呢？</p><p>你可能会说，模仿B/S架构方式呀，把单独出来共享服务，这里简称为<code>服务C</code>，提供一个<code>Restful</code>接口，然后用<code>Http</code>调用。</p><p>这样确实可以实现，那这样就每次调用都需要发送一连串的的<code>Http</code>请求了，如<code>request.get()</code>等。那能不能像本地调用一样呢？此时<code>RPC</code>的作用到了。使用<code>代理模式</code>，让用户直接引入<code>服务C</code>提供的类。而代理内部就是通过<code>Htpp</code>或者<code>TCP/UPD</code>来实现<code>RPC</code>远程过程调用的。</p><p><strong>说到这，总结一下<code>RPC</code>要解决的问题：</strong></p><ul><li>解决分布式系统中，服务之间的调用问题。</li><li>远程调用时，要能够像本地直接调用一样方便，用调用者感觉不到是在远程调用</li></ul><h3 id="实现一个RPC"><a href="#实现一个RPC" class="headerlink" title="实现一个RPC"></a>实现一个RPC</h3><p><strong>RPC工作流程</strong></p><ol><li>本地调用某个类的函数方法</li><li>本地机器的<code>RPC</code>框架把这个调用信息封装起来（调用函数、入参、提供服务机器地址端口等），将数据序列化成<code>JSON</code>或者<code>XML</code>后以二进制的方式通过网络传输（如Socket）发送给远程服务器</li><li>远程服务器收到调用后，远程机器的<code>RPC</code>框架获取二进制数据后反序列化出来，并根据调用信息定位到实现要执行的方法，执行完后序列化结果，通过网络传输把执行结果发送回本地机器。</li><li>本地机器的<code>RPC</code>框架反序列化出执行结果。</li></ol><p>Client端（本地机器）：</p><center><img src="/static/blogImg/RPC-client.jpg" alt="client"></center><p>Service端（远程机器）：</p><center><img src="/static/blogImg/RPC-service.jpg" alt="service"></center><p>总体流程：</p><center><img src="/static/blogImg/RPC.jpg" alt="rpc"></center><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>如何解决通讯问题？<br>客户端和服务器之前建立<code>TPC</code>连接，远程过程调用的所有交换数据都在这个连接里传输。连接可以是按需连接，调用结束后断开链接。</p><p>如何解决寻址问题？<br>客户端机器应用要怎么告诉底层<code>RPC</code>框架，如何连接到服务端机器（主机/IP、端口），方法名称是什么，这样才能调用。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;RPC（Remote Procedure Call Protocol）—— 远程过程调用协议，它是一种通过网络从远程计算机程序上请求服务，而不需要了解底层网络技术的协议。&lt;/p&gt;
&lt;p&gt;​简单来说，就是跟远程访问或者web请求差不多，都是一个client向远端服务器请求服务返回结果，但是web请求使用的网络协议是&lt;code&gt;http&lt;/code&gt;高层协议，而&lt;code&gt;rpc&lt;/code&gt;所使用的协议多为&lt;code&gt;TCP&lt;/code&gt;，是网络层协议，减少了信息的包装，加快了处理速度。&lt;/p&gt;
&lt;center&gt;&lt;img src=&quot;/static/blogImg/RemoteProcedureCall.png&quot; alt=&quot;client&quot;&gt;&lt;/center&gt;
    
    </summary>
    
      <category term="后端" scheme="https://jiawea.github.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
      <category term="RPC" scheme="https://jiawea.github.io/tags/RPC/"/>
    
  </entry>
  
  <entry>
    <title>数据结构之链表</title>
    <link href="https://jiawea.github.io/2019/12/10/Algorithm-linked-list/"/>
    <id>https://jiawea.github.io/2019/12/10/Algorithm-linked-list/</id>
    <published>2019-12-10T04:01:36.000Z</published>
    <updated>2020-06-10T01:10:45.466Z</updated>
    
    <content type="html"><![CDATA[<h2 id="单向链表"><a href="#单向链表" class="headerlink" title="单向链表"></a>单向链表</h2><p>单向链表也叫单链表，是链表中最简单的一种形式，它的每个节点包含两个域，一个信息域（元素域）和一个链接域。这个链接指向链表中的下一个节点，而最后一个节点的链接域则指向一个空值。</p><a id="more"></a><center><img src="https://img-blog.csdnimg.cn/20191111093914440.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0pJQVdFQQ==,size_16,color_FFFFFF,t_70" alt></center><ul><li>表元素域elem用来存放具体的数据。</li><li>链接域next用来存放下一个节点的位置（python中的标识）</li><li>变量p指向链表的头节点（首节点）的位置，从p出发能找到表中的任意节点。</li></ul><p><strong>下面引用算法图解一书中的链表：</strong><br>链表中的元素可存储在内存的任何地方。</p><center><img src="https://img-blog.csdnimg.cn/20191111094236680.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0pJQVdFQQ==,size_16,color_FFFFFF,t_70" alt></center><p>链表的每个元素都存储了下一个元素的地址，从而使一系列随机的内存地址串在一起。</p><center><img src="https://img-blog.csdnimg.cn/20191111094413665.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0pJQVdFQQ==,size_16,color_FFFFFF,t_70" alt></center><p>这犹如寻宝游戏。你前往第一个地址，那里有一张纸条写着“下一个元素的地址为123”。因此，你前往地址123，那里又有一张纸条写着“下一个元素的地址为668”。在链表中添加元素很容易：只需将其放入内存，并将其地址存储到前一个元素中。</p><h2 id="链表的查找"><a href="#链表的查找" class="headerlink" title="链表的查找"></a>链表的查找</h2><p>在查找元素时，链表不想数组那样可以通过下标快速定位，只能从头节点向后一个一个节点逐一查找。</p><h2 id="链表的更新"><a href="#链表的更新" class="headerlink" title="链表的更新"></a>链表的更新</h2><p>如果不考虑查找节点的话，链表的更新过程会想数组那样简单，直接把旧数据替换成新数据</p><center><img src="/static/data_struct/lianbiao_update.png" alt="链表更新"></center><h2 id="链表的插入"><a href="#链表的插入" class="headerlink" title="链表的插入"></a>链表的插入</h2><p>与数组类似，分为三种：</p><ul><li>头部插入</li><li>中间插入</li><li>尾部插入</li></ul><h3 id="1-头部插入"><a href="#1-头部插入" class="headerlink" title="1).头部插入"></a>1).头部插入</h3><ol><li>把新节点的<code>next</code>指向原先的头节点。</li><li>把新节点变为链表的头节点</li></ol><center><img src="/static/data_struct/link_list_add.png" alt></center><h3 id="2-中间插入"><a href="#2-中间插入" class="headerlink" title="2).中间插入"></a>2).中间插入</h3><ol><li>把新节点的<code>next</code>指向插入位置的节点。</li><li>把插入位置前置节点的<code>next</code>指向新节点</li></ol><center><img src="/static/data_struct/link_list_add_2.png" alt></center><h3 id="3-尾部插入"><a href="#3-尾部插入" class="headerlink" title="3).尾部插入"></a>3).尾部插入</h3><p>尾部插入最简单，把最后一个节点的<code>next</code>指向新插入的节点</p><center><img src="/static/data_struct/link_list_add_3.png" alt></center><h2 id="链表的删除"><a href="#链表的删除" class="headerlink" title="链表的删除"></a>链表的删除</h2><p>也分为三种：头部删除、中间删除、尾部删除。跟上面插入相似，这里将不啰嗦了。</p><h2 id="链表与顺序表的对比"><a href="#链表与顺序表的对比" class="headerlink" title="链表与顺序表的对比"></a>链表与顺序表的对比</h2><p>链表失去了顺序表随机读取的优点，同时链表由于增加了结点的指针域，空间开销比较大，但对存储空间的使用要相对灵活。</p><p>链表与顺序表的各种操作复杂度如下所示：</p><center><img src="/static/data_struct/list_vs_link_list.png" alt></center><p>链表和顺序表在插入和删除时进行的是完全不同的操作。</p><ul><li>链表的主要耗时操作是遍历查找，删除和插入操作本身的复杂度是O(1)。</li><li>顺序表查找很快，主要耗时的操作是拷贝覆盖。因为除了目标元素在尾部的特殊情况，顺序表进行插入和删除时需要对操作点之后的所有元素进行前后移位操作，只能通过拷贝和覆盖的方法进行。</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li>在读操作比较多、写操作比较少的情况下用数组比较合适。</li><li>在读操作比较少，需要频繁地插入和删除操作比较多的情况下，使用链表更合适一些。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;单向链表&quot;&gt;&lt;a href=&quot;#单向链表&quot; class=&quot;headerlink&quot; title=&quot;单向链表&quot;&gt;&lt;/a&gt;单向链表&lt;/h2&gt;&lt;p&gt;单向链表也叫单链表，是链表中最简单的一种形式，它的每个节点包含两个域，一个信息域（元素域）和一个链接域。这个链接指向链表中的下一个节点，而最后一个节点的链接域则指向一个空值。&lt;/p&gt;
    
    </summary>
    
      <category term="数据结构与算法" scheme="https://jiawea.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="数据结构" scheme="https://jiawea.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="链表" scheme="https://jiawea.github.io/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>Docker之数据卷volume</title>
    <link href="https://jiawea.github.io/2019/12/10/Docker-volume/"/>
    <id>https://jiawea.github.io/2019/12/10/Docker-volume/</id>
    <published>2019-12-10T03:48:02.000Z</published>
    <updated>2020-06-10T01:29:14.152Z</updated>
    
    <content type="html"><![CDATA[<p><strong>数据卷</strong><br>默认情况下，在容器内创建的所有文件都存储在可写容器层上。这意味着：</p><ul><li>当该容器不再存在时，数据将不会持久保存，并且如果另一个进程需要它，则可能很难从容器中取出数据。</li><li>容器的可写层与运行容器的主机紧密耦合。您不能轻易地将数据移动到其他地方。</li><li>写入容器的可写层需要 存储驱动程序来管理文件系统。存储驱动程序使用Linux内核提供联合文件系统。与使用直接写入主机文件系统的数据卷相比，这种额外的抽象降低了性能 。</li></ul><center><img src="/static/blogImg/DockerVolume.jpg" alt="avatar"></center><a id="more"></a><p>Docker为容器提供了两个选项来将文件存储在主机中，以便即使容器停止后文件也可以持久存储：</p><ul><li>bind mount（绑定安装）</li><li>volume（数据卷）</li></ul><h3 id="volume："><a href="#volume：" class="headerlink" title="volume："></a>volume：</h3><p>是一个可供一个或多个容器使用的特殊目录，它绕过 UFS，可以提供很多有用的特性：</p><ul><li>数据卷 可以在容器之间共享和重用</li><li>对 数据卷 的修改会立马生效</li><li>对 数据卷 的更新，不会影响镜像</li><li>数据卷 默认会一直存在，即使容器被删除</li></ul><h3 id="bind-mount："><a href="#bind-mount：" class="headerlink" title="bind mount："></a>bind mount：</h3><ul><li>文件或目录由主机上的完整路径引用。</li><li>该文件或目录不需要在Docker主机上已经存在。如果尚不存在，则按需创建。</li><li>性能非常好，但是它们依赖于具有特定目录结构的主机文件系统。</li></ul><p><strong>注意：可以通过容器中运行的进程来更改主机文件系统 ，包括创建，修改或删除重要的系统文件或目录，存在安全隐患</strong></p><h2 id="创建数据卷"><a href="#创建数据卷" class="headerlink" title="创建数据卷"></a>创建数据卷</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker volume create my-vol</span><br></pre></td></tr></table></figure><p>查看所有的 数据卷<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker volume ls</span><br><span class="line">local               my-vol</span><br></pre></td></tr></table></figure></p><p>在主机里使用以下命令可以查看指定 数据卷 的信息<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ docker volume inspect my-vol</span><br><span class="line"></span><br><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;Driver&quot;: &quot;local&quot;,</span><br><span class="line">        &quot;Labels&quot;: &#123;&#125;,</span><br><span class="line">        &quot;Mountpoint&quot;: &quot;/var/lib/docker/volumes/my-vol/_data&quot;,</span><br><span class="line">        &quot;Name&quot;: &quot;my-vol&quot;,</span><br><span class="line">        &quot;Options&quot;: &#123;&#125;,</span><br><span class="line">        &quot;Scope&quot;: &quot;local&quot;</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p><h3 id="查看数据卷的具体信息"><a href="#查看数据卷的具体信息" class="headerlink" title="查看数据卷的具体信息"></a>查看数据卷的具体信息</h3><p>在主机里使用以下命令可以查看 web 容器的信息<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">$ docker inspect web</span><br><span class="line">数据卷 信息在 &quot;Mounts&quot; Key 下面</span><br><span class="line"></span><br><span class="line">&quot;Mounts&quot;: [</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;Type&quot;: &quot;volume&quot;,</span><br><span class="line">        &quot;Name&quot;: &quot;my-vol&quot;,</span><br><span class="line">        &quot;Source&quot;: &quot;/var/lib/docker/volumes/my-vol/_data&quot;,</span><br><span class="line">        &quot;Destination&quot;: &quot;/app&quot;,</span><br><span class="line">        &quot;Driver&quot;: &quot;local&quot;,</span><br><span class="line">        &quot;Mode&quot;: &quot;&quot;,</span><br><span class="line">        &quot;RW&quot;: true,</span><br><span class="line">        &quot;Propagation&quot;: &quot;&quot;</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p><h3 id="启动一个挂载数据卷的容器"><a href="#启动一个挂载数据卷的容器" class="headerlink" title="启动一个挂载数据卷的容器"></a>启动一个挂载数据卷的容器</h3><p>在用 docker run 命令的时候，使用 <code>--mount</code> 标记或者直接使用<code>-v</code>来将 数据卷 挂载到容器里。在一次 docker run 中可以挂载多个 数据卷。</p><p>下面创建一个名为 web 的容器，并加载一个 数据卷 到容器的 /webapp 目录。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -d -P \</span><br><span class="line">    --name web \</span><br><span class="line">    # -v my-vol:/wepapp \</span><br><span class="line">    --mount source=my-vol,target=/webapp \</span><br><span class="line">    training/webapp \</span><br><span class="line">    python app.py</span><br></pre></td></tr></table></figure></p><h3 id="删除数据卷"><a href="#删除数据卷" class="headerlink" title="删除数据卷"></a>删除数据卷</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker volume rm my-vol</span><br></pre></td></tr></table></figure><p>数据卷 是被设计用来持久化数据的，它的生命周期独立于容器，Docker 不会在容器被删除后自动删除 数据卷，并且也不存在垃圾回收这样的机制来处理没有任何容器引用的 数据卷。如果需要在删除容器的同时移除数据卷。可以在删除容器的时候使用<code>docker rm -v</code> 这个命令。</p><p>无主的数据卷可能会占据很多空间，要清理请使用以下命令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker volume prune</span><br></pre></td></tr></table></figure></p><p>在删除容器的时候也可使用<code>-v</code>来删除数据卷或者在启动容器是加上<code>--rm</code>，如：</p><ul><li><code>docker rm -v 容器</code></li><li><code>docker run --rm</code></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;数据卷&lt;/strong&gt;&lt;br&gt;默认情况下，在容器内创建的所有文件都存储在可写容器层上。这意味着：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;当该容器不再存在时，数据将不会持久保存，并且如果另一个进程需要它，则可能很难从容器中取出数据。&lt;/li&gt;
&lt;li&gt;容器的可写层与运行容器的主机紧密耦合。您不能轻易地将数据移动到其他地方。&lt;/li&gt;
&lt;li&gt;写入容器的可写层需要 存储驱动程序来管理文件系统。存储驱动程序使用Linux内核提供联合文件系统。与使用直接写入主机文件系统的数据卷相比，这种额外的抽象降低了性能 。&lt;/li&gt;
&lt;/ul&gt;
&lt;center&gt;&lt;img src=&quot;/static/blogImg/DockerVolume.jpg&quot; alt=&quot;avatar&quot;&gt;&lt;/center&gt;
    
    </summary>
    
      <category term="Docker" scheme="https://jiawea.github.io/categories/Docker/"/>
    
    
      <category term="Docker" scheme="https://jiawea.github.io/tags/Docker/"/>
    
      <category term="volume" scheme="https://jiawea.github.io/tags/volume/"/>
    
  </entry>
  
  <entry>
    <title>数据结构之顺序表</title>
    <link href="https://jiawea.github.io/2019/11/08/Algorithm-SeqList/"/>
    <id>https://jiawea.github.io/2019/11/08/Algorithm-SeqList/</id>
    <published>2019-11-08T02:49:50.000Z</published>
    <updated>2020-06-10T01:10:55.806Z</updated>
    
    <content type="html"><![CDATA[<h2 id="顺序表"><a href="#顺序表" class="headerlink" title="顺序表"></a>顺序表</h2><p>在程序中，经常需要将一组（通常是同为某个类型的）数据元素作为整体管理和使用，需要创建这种元素组，用变量记录它们，传进传出函数等。一组数据中包含的元素个数可能发生变化（可以增加或删除元素）。</p><p>对于这种需求，最简单的解决方案便是将这样一组元素看成一个序列，用元素在序列里的位置和顺序，表示实际应用中的某种有意义的信息，或者表示数据之间的某种关系。</p><a id="more"></a><p>这样的一组序列元素的组织形式，我们可以将其抽象为线性表。一个线性表是某类元素的一个集合，还记录着元素之间的一种顺序关系。线性表是最基本的数据结构之一，在实际程序中应用非常广泛，它还经常被用作更复杂的数据结构的实现基础。</p><p>根据线性表的实际存储方式，分为两种实现模型：</p><ul><li><strong>顺序表</strong>，将元素顺序地存放在一块连续的存储区里，元素间的顺序关系由它们的存储顺序自然表示。</li><li><strong>链表</strong>，将元素存放在通过链接构造起来的一系列存储块中。</li></ul><h2 id="顺序表的基本形式"><a href="#顺序表的基本形式" class="headerlink" title="顺序表的基本形式"></a>顺序表的基本形式</h2><p><center><img src="https://img-blog.csdnimg.cn/20191108094130855.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0pJQVdFQQ==,size_16,color_FFFFFF,t_70" alt="顺序表基本形式"></center><br>图a表示的是顺序表的基本形式，数据元素本身连续存储，每个元素所占的存储单元大小固定相同，元素的下标是其逻辑地址，而元素存储的物理地址（实际内存地址）可以通过存储区的起始地址Loc (e0)加上逻辑地址（第i个元素）与存储单元大小（c）的乘积计算而得，即：</p><p><strong>Loc(ei) = Loc(e0) + c*i</strong></p><p>故，访问指定元素时无需从头遍历，通过计算便可获得对应地址，其时间复杂度为<strong>O(1)</strong>。<br>如果元素的大小不统一（如Python中的一个列表中有多种数据类型：[1, “a”, 1.001]等），则须采用图b的元素外置的形式，将实际数据元素另行存储，而顺序表中各单元位置保存对应元素的地址信息（即链接）。由于每个链接所需的存储量相同，通过上述公式，可以计算出元素链接的存储位置，而后顺着链接找到实际存储的数据元素。<strong>注意，图b中的c不再是数据元素的大小，而是存储一个链接地址所需的存储量，这个量通常很小。</strong><br>图b这样的顺序表也被称为对实际数据的索引，这是最简单的索引结构。</p><h2 id="顺序表的结构与实现"><a href="#顺序表的结构与实现" class="headerlink" title="顺序表的结构与实现"></a>顺序表的结构与实现</h2><p><strong>顺序表的结构</strong></p><p><center><img src="https://img-blog.csdnimg.cn/20191108094457522.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0pJQVdFQQ==,size_16,color_FFFFFF,t_70" alt="顺序表的结构"></center><br>一个顺序表的完整信息包括两部分：</p><ul><li>一部分是表中的元素集合</li><li>另一部分是为实现正确操作而需记录的信息，即有关表的整体情况的信息，这部分信息主要包括元素存储区的容量和当前表中已有的元素个数两项。</li></ul><p><strong>顺序表的两种基本实现方式</strong></p><p><center><img src="https://img-blog.csdnimg.cn/2019110809464595.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0pJQVdFQQ==,size_16,color_FFFFFF,t_70" alt="顺序表两种基本实现方式"></center><br>图a为一体式结构，存储表信息的单元与元素存储区以连续的方式安排在一块存储区里，两部分数据的整体形成一个完整的顺序表对象。</p><p>一体式结构整体性强，易于管理。但是由于数据元素存储区域是表对象的一部分，顺序表创建后，元素存储区就固定了。</p><p>图b为分离式结构，表对象里只保存与整个表有关的信息（即容量和元素个数），实际数据元素存放在另一个独立的元素存储区里，通过链接与基本表对象关联。</p><p><strong>元素存储区替换</strong><br>一体式结构由于顺序表信息区与数据区连续存储在一起，所以若想更换数据区，则只能整体搬迁，即整个顺序表对象（指存储顺序表的结构信息的区域）改变了。</p><p>分离式结构若想更换数据区，只需将表信息区中的数据区链接地址更新即可，而该顺序表对象不变。</p><p><strong>元素存储区扩充</strong><br>采用分离式结构的顺序表，若将数据区更换为存储空间更大的区域，则可以在不改变表对象的前提下对其数据存储区进行了扩充，所有使用这个表的地方都不必修改。只要程序的运行环境（计算机系统）还有空闲存储，这种表结构就不会因为满了而导致操作无法进行。人们把采用这种技术实现的顺序表称为动态顺序表，因为其容量可以在使用中动态变化。</p><p>扩充的两种策略：</p><ul><li><p>每次扩充增加固定数目的存储位置，如每次扩充增加10个元素位置，这种策略可称为线性增长。<strong>特点：节省空间，但是扩充操作频繁，操作次数多。</strong></p></li><li><p>每次扩充容量加倍，如每次扩充增加一倍存储空间。<strong>特点：减少了扩充操作的执行次数，但可能会浪费空间资源。以空间换时间，推荐的方式。</strong></p></li></ul><h2 id="顺序表的操作"><a href="#顺序表的操作" class="headerlink" title="顺序表的操作"></a>顺序表的操作</h2><p><strong>增加元素</strong></p><ul><li><p>尾端加入元素，时间复杂度为O(1)</p></li><li><p>非保序的加入元素（不常见），时间复杂度为O(1)</p></li><li><p>保序的元素加入，时间复杂度为O(n)</p></li></ul><p><strong>删除元素</strong></p><ul><li><p>删除表尾元素，时间复杂度为O(1)</p></li><li><p>非保序的元素删除（不常见），时间复杂度为O(1)</p></li><li><p>保序的元素删除，时间复杂度为O(n)</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;顺序表&quot;&gt;&lt;a href=&quot;#顺序表&quot; class=&quot;headerlink&quot; title=&quot;顺序表&quot;&gt;&lt;/a&gt;顺序表&lt;/h2&gt;&lt;p&gt;在程序中，经常需要将一组（通常是同为某个类型的）数据元素作为整体管理和使用，需要创建这种元素组，用变量记录它们，传进传出函数等。一组数据中包含的元素个数可能发生变化（可以增加或删除元素）。&lt;/p&gt;
&lt;p&gt;对于这种需求，最简单的解决方案便是将这样一组元素看成一个序列，用元素在序列里的位置和顺序，表示实际应用中的某种有意义的信息，或者表示数据之间的某种关系。&lt;/p&gt;
    
    </summary>
    
      <category term="数据结构与算法" scheme="https://jiawea.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="数据结构" scheme="https://jiawea.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="顺序表" scheme="https://jiawea.github.io/tags/%E9%A1%BA%E5%BA%8F%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>算法之时间复杂度</title>
    <link href="https://jiawea.github.io/2019/11/06/Algorithm-O/"/>
    <id>https://jiawea.github.io/2019/11/06/Algorithm-O/</id>
    <published>2019-11-06T02:25:36.000Z</published>
    <updated>2020-06-10T01:10:49.652Z</updated>
    
    <content type="html"><![CDATA[<h2 id="在了解时间复杂度之前，让我们来了解一下什么是算法？"><a href="#在了解时间复杂度之前，让我们来了解一下什么是算法？" class="headerlink" title="在了解时间复杂度之前，让我们来了解一下什么是算法？"></a>在了解时间复杂度之前，让我们来了解一下什么是算法？</h2><p>算法（Algorithm）是指解题方案的准确而完整的描述，是一系列解决问题的清晰指令（我的理解是一系列解决问题的步骤），算法代表着用系统的方法描述解决问题的策略机制。也就是说，能够对一定规范的输入，在有限时间内获得所要求的输出。不同的算法可能用不同的时间、空间或效率来完成同样的任务。</p><p>一个算法的优劣可以用空间复杂度与时间复杂度来衡量。</p><a id="more"></a><h3 id="算法的五大特性："><a href="#算法的五大特性：" class="headerlink" title="算法的五大特性："></a>算法的五大特性：</h3><p>输入：算法具有0个或多个输入<br>输出: 算法至少有1个或多个输出<br>有穷性: 算法在有限的步骤之后会自动结束而不会无限循环，并且每一个步骤可以在可接受的时间内完成<br>确定性：算法中的每一步都有确定的含义，不会出现二义性<br>可行性：算法的每一步都是可行的，也就是说每一步都能够执行有限的次数完成</p><p>不同的算法对执行程序的结果也许是一样的，但是执行时间和效率却有着很大的区别，下面让我们来看个例子：</p><p>问题：a + b + c = 100, a^2  + b^2 = c^2,请计算出所有符合的a, b, c结果。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">import time</span><br><span class="line"> </span><br><span class="line">start_time = time.time()</span><br><span class="line"> </span><br><span class="line"># 注意是三重循环</span><br><span class="line">for a in range(0, 1001):</span><br><span class="line">    for b in range(0, 1001):</span><br><span class="line">        for c in range(0, 1001):</span><br><span class="line">            if a**2 + b**2 == c**2 and a+b+c == 1000:</span><br><span class="line">                print(&quot;a, b, c: %d, %d, %d&quot; % (a, b, c))</span><br><span class="line"> </span><br><span class="line">end_time = time.time()</span><br><span class="line">print(&quot;time: %f&quot; % (end_time - start_time))</span><br><span class="line">print(&quot;finished!&quot;)</span><br></pre></td></tr></table></figure></p><p>结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a, b, c: 0, 500, 500</span><br><span class="line">a, b, c: 200, 375, 425</span><br><span class="line">a, b, c: 375, 200, 425</span><br><span class="line">a, b, c: 500, 0, 500</span><br><span class="line">time: 214.583347</span><br><span class="line">finished!</span><br></pre></td></tr></table></figure></p><p>程序执行完总共花费了214秒。我们再来看一个例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">import time</span><br><span class="line"> </span><br><span class="line">start_time = time.time()</span><br><span class="line"> </span><br><span class="line"># 注意是两重循环</span><br><span class="line">for a in range(0, 1001):</span><br><span class="line">    for b in range(0, 1001-a):</span><br><span class="line">        c = 1000 - a - b</span><br><span class="line">        if a**2 + b**2 == c**2:</span><br><span class="line">            print(&quot;a, b, c: %d, %d, %d&quot; % (a, b, c))</span><br><span class="line"> </span><br><span class="line">end_time = time.time()</span><br><span class="line">print(&quot;time: %f&quot; % (end_time - start_time))</span><br><span class="line">print(&quot;finished!&quot;)</span><br></pre></td></tr></table></figure></p><p>结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a, b, c: 0, 500, 500</span><br><span class="line">a, b, c: 200, 375, 425</span><br><span class="line">a, b, c: 375, 200, 425</span><br><span class="line">a, b, c: 500, 0, 500</span><br><span class="line">time: 0.182897</span><br><span class="line">finished!</span><br></pre></td></tr></table></figure></p><p>程序执行完总共花费了0.18秒，这对于第一种方法来说，无疑是一种很大的提升。所以说，算法的好坏对于程序来说是非常重要的。</p><p><strong>因此，我们可以得出一个结论：实现算法程序的执行时间可以反应出算法的效率，即算法的优劣。</strong></p><h2 id="单靠时间值绝对可信吗？"><a href="#单靠时间值绝对可信吗？" class="headerlink" title="单靠时间值绝对可信吗？"></a>单靠时间值绝对可信吗？</h2><p>假设我们将第二次尝试的算法程序运行在一台配置古老性能低下的计算机中，情况会如何？很可能运行的时间并不会比在我们的电脑中运行算法一的214.583347秒快多少。</p><p>单纯依靠运行的时间来比较算法的优劣并不一定是客观准确的！</p><p>程序的运行离不开计算机环境（包括硬件和操作系统），这些客观原因会影响程序运行的速度并反应在程序的执行时间上。那么如何才能客观的评判一个算法的优劣呢？</p><h2 id="时间复杂度与“大O记法”"><a href="#时间复杂度与“大O记法”" class="headerlink" title="时间复杂度与“大O记法”"></a>时间复杂度与“大O记法”</h2><p>我们假定计算机执行算法每一个基本操作的时间是固定的一个时间单位，那么有多少个基本操作就代表会花费多少时间单位。算然对于不同的机器环境而言，确切的单位时间是不同的，但是对于算法进行多少个基本操作（即花费多少时间单位）在规模数量级上却是相同的，由此可以忽略机器环境的影响而客观的反应算法的时间效率。</p><p>对于算法的时间效率，我们可以用“大O记法”来表示。</p><p>“大O记法”：对于单调的整数函数f，如果存在一个整数函数g和实常数c&gt;0，使得对于充分大的n总有f(n)&lt;=c*g(n)，就说函数g是f的一个渐近函数（忽略常数），记为f(n)=O(g(n))。也就是说，在趋向无穷的极限意义下，函数f的增长速度受到函数g的约束，亦即函数f与函数g的特征相似。</p><p><strong>时间复杂度：假设存在函数g，使得算法A处理规模为n的问题示例所用时间为T(n)=O(g(n))，则称O(g(n))为算法A的渐近时间复杂度，简称时间复杂度，记为T(n)</strong></p><h2 id="最坏时间复杂度"><a href="#最坏时间复杂度" class="headerlink" title="最坏时间复杂度"></a>最坏时间复杂度</h2><p>分析算法时，存在几种可能的考虑：</p><p>算法完成工作最少需要多少基本操作，即最优时间复杂度<br>算法完成工作最多需要多少基本操作，即最坏时间复杂度<br>算法完成工作平均需要多少基本操作，即平均时间复杂度<br>对于最优时间复杂度，其价值不大，因为它没有提供什么有用信息，其反映的只是最乐观最理想的情况，没有参考价值。</p><p>对于最坏时间复杂度，提供了一种保证，表明算法在此种程度的基本操作中一定能完成工作。</p><p>对于平均时间复杂度，是对算法的一个全面评价，因此它完整全面的反映了这个算法的性质。但另一方面，这种衡量并没有保证，不是每个计算都能在这个基本操作内完成。而且，对于平均情况的计算，也会因为应用算法的实例分布可能并不均匀而难以计算。</p><p>因此，我们主要关注算法的最坏情况，亦即最坏时间复杂度。</p><h2 id="算法分析"><a href="#算法分析" class="headerlink" title="算法分析"></a>算法分析</h2><p>1）上面第一个列子核心部分：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">for a in range(0, 1001):</span><br><span class="line">    for b in range(0, 1001):</span><br><span class="line">        for c in range(0, 1001):</span><br><span class="line">            if a**2 + b**2 == c**2 and a+b+c == 1000:</span><br><span class="line">                print(&quot;a, b, c: %d, %d, %d&quot; % (a, b, c))</span><br></pre></td></tr></table></figure></p><p>时间复杂度：<br><code>T(n) = O(n*n*n) = O(n3)</code></p><p>2）第二个例子核心部分：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">for a in range(0, 1001):</span><br><span class="line">    for b in range(0, 1001-a):</span><br><span class="line">        c = 1000 - a - b</span><br><span class="line">        if a**2 + b**2 == c**2:</span><br><span class="line">            print(&quot;a, b, c: %d, %d, %d&quot; % (a, b, c))</span><br></pre></td></tr></table></figure></p><p>时间复杂度：<br><code>T(n) = O(n*n*(1+1)) = O(n*n) = O(n2)</code></p><p>由此可见，我们尝试的第二种算法要比第一种算法的时间复杂度好多的。</p><h3 id="常见时间复杂度"><a href="#常见时间复杂度" class="headerlink" title="常见时间复杂度"></a>常见时间复杂度</h3><table><thead><tr><th style="text-align:center">执行次数函数举例</th><th style="text-align:center">阶</th><th style="text-align:center">非正式术语</th></tr></thead><tbody><tr><td style="text-align:center">12</td><td style="text-align:center">O(1)</td><td style="text-align:center">常数阶</td></tr><tr><td style="text-align:center">2n+3</td><td style="text-align:center">O(n)</td><td style="text-align:center">线性阶</td></tr><tr><td style="text-align:center">3n^2+2n+1</td><td style="text-align:center">O(n^2)</td><td style="text-align:center">平方阶</td></tr><tr><td style="text-align:center">5log2n+20</td><td style="text-align:center">O(logn)</td><td style="text-align:center">对数阶</td></tr><tr><td style="text-align:center">2n+3nlog2n+19</td><td style="text-align:center">O(nlogn)</td><td style="text-align:center">nlogn阶</td></tr><tr><td style="text-align:center">6n^3+2n^2+3n+4</td><td style="text-align:center">O(n^3)</td><td style="text-align:center">立方阶</td></tr><tr><td style="text-align:center">2^n    O(2n)</td><td style="text-align:center">O(2^n)</td><td style="text-align:center">指数阶</td></tr></tbody></table><h3 id="常见时间复杂度的关系"><a href="#常见时间复杂度的关系" class="headerlink" title="常见时间复杂度的关系"></a>常见时间复杂度的关系</h3><center><img src="/static/blogImg/algorithm_1.png" alt="avatar"></center><p>所消耗的时间从小到大<br>O(1) &lt; O(logn) &lt; O(n) &lt; O(nlogn) &lt; O(n2) &lt; O(n3) &lt; O(2n) &lt; O(n!) &lt; O(nn)</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;在了解时间复杂度之前，让我们来了解一下什么是算法？&quot;&gt;&lt;a href=&quot;#在了解时间复杂度之前，让我们来了解一下什么是算法？&quot; class=&quot;headerlink&quot; title=&quot;在了解时间复杂度之前，让我们来了解一下什么是算法？&quot;&gt;&lt;/a&gt;在了解时间复杂度之前，让我们来了解一下什么是算法？&lt;/h2&gt;&lt;p&gt;算法（Algorithm）是指解题方案的准确而完整的描述，是一系列解决问题的清晰指令（我的理解是一系列解决问题的步骤），算法代表着用系统的方法描述解决问题的策略机制。也就是说，能够对一定规范的输入，在有限时间内获得所要求的输出。不同的算法可能用不同的时间、空间或效率来完成同样的任务。&lt;/p&gt;
&lt;p&gt;一个算法的优劣可以用空间复杂度与时间复杂度来衡量。&lt;/p&gt;
    
    </summary>
    
      <category term="数据结构与算法" scheme="https://jiawea.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="https://jiawea.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="时间复杂度" scheme="https://jiawea.github.io/tags/%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/"/>
    
  </entry>
  
  <entry>
    <title>HTTP报文理解</title>
    <link href="https://jiawea.github.io/2019/10/17/HttpMessages/"/>
    <id>https://jiawea.github.io/2019/10/17/HttpMessages/</id>
    <published>2019-10-17T02:06:47.000Z</published>
    <updated>2020-06-10T01:12:38.190Z</updated>
    
    <content type="html"><![CDATA[<p>HTTP报文携带着HTTP协议交互的信息，可以理解为它为搬东西的包裹，来搬运交换的信息。<br>其中有两种类型的报文，一是客户端发送的请求到服务器的HTTP报文叫做请求报文，二是服务器响应给客户端的叫响应报文。</p><center><img src="/static/blogImg/HTTP_Messages.png" alt="avatar"></center><a id="more"></a><h3 id="请求报文组成部分"><a href="#请求报文组成部分" class="headerlink" title="请求报文组成部分"></a>请求报文组成部分</h3><p>HTTP 报文大致可分为请求行、请求头、空行、请求主体四部分。</p><ul><li>请求行</li><li>请求头</li><li>空行</li><li>请求数据</li></ul><h3 id="请求报文"><a href="#请求报文" class="headerlink" title="请求报文"></a>请求报文</h3><p><strong>请求行</strong><br>组成：请求方式 + 请求URI + HTTP版本 + CR LF(换行)<br>HTTP请求是客户端发送的用于在服务器上启动操作的消息。它们的起始行包含三个元素，例如，GET /index.html HTTP/1.1。</p><p>HTTP协议的请求方法有GET、POST、HEAD、PUT、DELETE、OPTIONS、TRACE、CONNECT。</p><ul><li>GET: 请求目标通常是URL，或者协议，端口和域的绝对路径通常由请求上下文来表征。此请求目标的格式在不同的HTTP方法之间有所不同。有可能绝对路径，最后跟一个“？”和查询字符串。这是最常见的形式，称为原始形式，并且与GET，POST，HEAD和OPTIONS方法一起使用。如：GET /index.html?id=1 HTTP/1.1</li><li>POST: 对于不适合使用GET方式的情况（比如账号登录），可以使用POST方式，因为使用POST方法可以允许客户端给服务器提供信息较多。POST方法将请求参数封装在HTTP请求数据中，以“键：值”的形式出现，可以传输大量数据，这样POST方式对传送的数据大小没有限制，而且也不会显示在URL中。</li><li>HEAD: HEAD就像GET，只不过服务端接受到HEAD请求后只返回响应头，而不会发送响应内容。当我们只需要查看某个页面的状态的时候，使用HEAD是非常高效的，因为在传输的过程中省去了页面内容。</li></ul><p><strong>请求头部</strong></p><center><img src="/static/blogImg/HTTP_Request_Headers2.png" alt="avatar"></center><p>请求头部由键值对组成，每行一对，关键字和值用英文冒号“:”分隔。请求头部通知服务器有关于客户端请求的信息，典型的请求头有：</p><ul><li>User-Agent：产生请求的浏览器类型。</li><li>Accept：客户端可识别的内容类型列表。</li><li>Host：请求的主机名，允许多个域名同处一个IP地址，即虚拟主机。</li></ul><p><strong>空行</strong><br>最后一个请求头之后是一个空行，发送回车符和换行符，通知服务器以下不再有请求头。</p><p><strong>请求数据</strong><br>请求数据不在GET方法中使用，而是在POST方法中使用。POST方法适用于需要客户填写表单的场合。与请求数据相关的最常使用的请求头是<code>Content-Type</code>和<code>Content-Length</code>。</p><h3 id="响应报文"><a href="#响应报文" class="headerlink" title="响应报文"></a>响应报文</h3><p><strong>请求行</strong><br>组成：HTTP版本 + 状态码  + 状态码描述 + CR LF(换行)<br>响应报文结构与请求报文结构唯一的区别在于第一行中用状态信息代替了请求信息。状态行（status line）通过提供一个状态码来说明所请求的资源情况。</p><p>HTTP状态码被分为五大类:</p><ol><li>状态代码由服务器发出，以响应客户端对服务器的请求。</li><li>1xx（信息）：收到请求，继续处理</li><li>2xx（成功）：请求已成功接收，理解和接受</li><li>3xx（重定向）：为了完成指定的动作，必须接受进一步处理</li><li>4xx（客户端错误）：请求包含错误的语法或无法满足</li><li>5xx（服务器错误）：服务器不能正确执行一个正确的请求</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;HTTP报文携带着HTTP协议交互的信息，可以理解为它为搬东西的包裹，来搬运交换的信息。&lt;br&gt;其中有两种类型的报文，一是客户端发送的请求到服务器的HTTP报文叫做请求报文，二是服务器响应给客户端的叫响应报文。&lt;/p&gt;
&lt;center&gt;&lt;img src=&quot;/static/blogImg/HTTP_Messages.png&quot; alt=&quot;avatar&quot;&gt;&lt;/center&gt;
    
    </summary>
    
      <category term="网络" scheme="https://jiawea.github.io/categories/%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="HTTP" scheme="https://jiawea.github.io/tags/HTTP/"/>
    
  </entry>
  
  <entry>
    <title>Python进阶用法</title>
    <link href="https://jiawea.github.io/2019/10/14/HiddenFeaturesOfPython/"/>
    <id>https://jiawea.github.io/2019/10/14/HiddenFeaturesOfPython/</id>
    <published>2019-10-14T02:58:14.000Z</published>
    <updated>2020-06-10T01:25:16.471Z</updated>
    
    <content type="html"><![CDATA[<p>使用Python来编写也有很长一段时间了，也想着如何优化自己的代码，随之也搜了一些问题。<br>其中印象比较深刻的就是stackoverflow上的一个问题解答了。</p><a id="more"></a><p>原文：<a href="https://stackoverflow.com/questions/101268/hidden-features-of-python" target="_blank" rel="noopener">Hidden features of Python</a></p><p><strong>Argument Unpacking</strong><br>可以使用 * 和 ** 分别将一个列表和一个字典解包为函数参数<br>如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">def draw_point(x, y):</span><br><span class="line"># do something</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">tuple = (6, 8)</span><br><span class="line">dir = &#123;&apos;x&apos;: 6, &apos;y&apos;: 8&#125;</span><br><span class="line"></span><br><span class="line">draw_point(*tuple)</span><br><span class="line">draw_point(**dir)</span><br></pre></td></tr></table></figure></p><p><strong>Decorators</strong><br>装饰器的作用就是在不需要修改原函数代码的前提下增加新的功能，在调用原函数的时候先执行装饰器，如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">def print_before_func(func):</span><br><span class="line">def wrapper(*args, **kwargs):</span><br><span class="line">print(&quot;print before func&quot;)</span><br><span class="line">return func(*args, **kwargs)</span><br><span class="line">return wrapper</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@print_befor_func</span><br><span class="line">def write(text):</span><br><span class="line">print(text)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">write(Hello world)</span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line">print before func</span><br><span class="line">Hello world</span><br></pre></td></tr></table></figure></p><p><strong>Dictionary default .get value</strong><br>字典中有一个<code>get()</code>方法。如果你使用<code>dict[&#39;key&#39;]</code>的方式而<code>key</code>不存在的话就会出现异常。使用<code>dict.get(&#39;key&#39;)</code>的话如果<code>key</code>不存在则只会返回<code>None</code>。当然<code>get()</code>方法提供了第二个参数，如果返回<code>None</code>则会返回第二个参数的值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">num = dict.get(&apos;num&apos;, 0)</span><br></pre></td></tr></table></figure></p><p><strong>Enumeration</strong><br>使用enumeration包住一个可迭代对象，它会将index和item绑在一起，返回一个enumeration对象，如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">a = [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;]</span><br><span class="line">for index, item in enumeration(a):</span><br><span class="line">print(index, item)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">···</span><br><span class="line">0 a</span><br><span class="line">1 b</span><br><span class="line">2 c</span><br><span class="line">3 d</span><br><span class="line">···</span><br></pre></td></tr></table></figure></p><p>在同时需要索引和值的时候很有用</p><p><strong>For/else</strong><br>语法如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">for i in foo:</span><br><span class="line">if i == 0:</span><br><span class="line">break</span><br><span class="line">else:</span><br><span class="line">print(&quot;it was never 0&quot;)</span><br></pre></td></tr></table></figure></p><p><code>else</code>代码块会在循环正常结束后执行，也就是说没用出现<code>break</code>时才会调用<code>else</code>代码块，上面代码等价于:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">found = False</span><br><span class="line">for i in foo:</span><br><span class="line">if i == 0:</span><br><span class="line">found = True</span><br><span class="line">break</span><br><span class="line"></span><br><span class="line">if not found:</span><br><span class="line">print(&quot;it was never 0&quot;)</span><br></pre></td></tr></table></figure></p><p>这个语法挺容易让人混淆的，所有在使用的时候最好是注释一下，以免被其他小伙伴搞错含义了。</p><p>上面的代码也等价于：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if any(i == 0 for i in foo):</span><br><span class="line">pass</span><br><span class="line">else:</span><br><span class="line">print(&quot;it was never 0&quot;)</span><br></pre></td></tr></table></figure></p><p><strong>Generator expressions</strong><br>假如你这样写：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x = (n for n in foo if bar(n))</span><br></pre></td></tr></table></figure></p><p>你将会得到一个生成器，并可以把它付给一个变量x。现在你可以像下面一样使用生成器：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">for n in x:</span><br><span class="line">print(n)</span><br></pre></td></tr></table></figure></p><p>这样做的好处就是节省内存了。你不需要中间存储，而如果像下面这样的话，则需要：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x = [n for n in foo if bar(n)]</span><br><span class="line"># 列表推导</span><br></pre></td></tr></table></figure></p><p>在某些情况下，这会导致极重要的速度提升。<br>你可以添加许多if语句到生成器的尾端，基本复制for循环嵌套：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; n = ((a,b) for a in range(0,2) for b in range(4,6))</span><br><span class="line">&gt;&gt;&gt; for i in n:</span><br><span class="line">...   print i </span><br><span class="line"></span><br><span class="line">(0, 4)</span><br><span class="line">(0, 5)</span><br><span class="line">(1, 4)</span><br><span class="line">(1, 5)</span><br></pre></td></tr></table></figure></p><p>使用生成器最大的好处就是节省内存了。因为每一个值只有在你需要的时候才会生成，而不像列表推导那样一次性生成所有的结果。</p><p><strong>List stepping</strong><br>切片操作符中的步长(step)参数。例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = [1,2,3,4,5]</span><br><span class="line">&gt;&gt;&gt; a[::2]  # iterate over the whole list in 2-increments</span><br><span class="line">[1,3,5]</span><br></pre></td></tr></table></figure></p><p>特殊例子<code>x[::-1]</code>对‘x反转’来说相当有用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; a[::-1]</span><br><span class="line">[5,4,3,2,1]</span><br></pre></td></tr></table></figure></p><p>当然，你可以使用<code>reversed()</code>函数来实现反转。<br>区别在于，reversed()返回一个迭代器，所以还需要一个额外的步骤来将结果转换成需要的对象类型。<br>这个特性在判断例如回文的时候灰常有用，一句话搞定<br><code>True if someseq == someseq[::-1] else False</code></p><p><strong>Named string formatting</strong><br>%-格式化接收一个字典（也适用于%i%s等）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; print &quot;The %(foo)s is %(bar)i.&quot; % &#123;&apos;foo&apos;: &apos;answer&apos;, &apos;bar&apos;:42&#125;</span><br><span class="line">The answer is 42.</span><br></pre></td></tr></table></figure></p><p><strong>try/except/else</strong><br>else语句块只有当try语句正常执行（也就是说，except语句未执行）的时候，才会执行。<br>finally则无论是否异常都会执行。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">try:</span><br><span class="line">     Normal execution block</span><br><span class="line">except A:</span><br><span class="line">     Exception A handle</span><br><span class="line">except B:</span><br><span class="line">     Exception B handle</span><br><span class="line">except:</span><br><span class="line">     Other exception handle</span><br><span class="line">else:</span><br><span class="line">     if no exception,get here</span><br><span class="line">finally:</span><br><span class="line">     this block will be excuted no matter how it goes above</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;使用Python来编写也有很长一段时间了，也想着如何优化自己的代码，随之也搜了一些问题。&lt;br&gt;其中印象比较深刻的就是stackoverflow上的一个问题解答了。&lt;/p&gt;
    
    </summary>
    
      <category term="后端" scheme="https://jiawea.github.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
      <category term="Python" scheme="https://jiawea.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>告别GOPATH,使用go mod</title>
    <link href="https://jiawea.github.io/2019/09/25/go_mod/"/>
    <id>https://jiawea.github.io/2019/09/25/go_mod/</id>
    <published>2019-09-25T01:47:23.000Z</published>
    <updated>2020-06-10T01:13:57.751Z</updated>
    
    <content type="html"><![CDATA[<p>我们都知道在使用Golang时开发程序时都需要在 <code>GOPATH</code> 下面，这就非常不方便。如果你想放在磁盘上的其他地方，那么go mod将是你的“好伙伴”。</p><a id="more"></a><p>关于 go mod 的说明，可以参考：</p><ul><li><a href="https://roberto.selbach.ca/intro-to-go-modules/" target="_blank" rel="noopener">Introduction to Go Modules</a></li><li><a href="https://github.com/golang/go/wiki/Modules" target="_blank" rel="noopener">Go 1.11 Modules 官方说明文档</a></li></ul><h3 id="命令行说明"><a href="#命令行说明" class="headerlink" title="命令行说明"></a>命令行说明</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ go mod</span><br><span class="line">Go mod provides access to operations on modules.</span><br><span class="line">Note that support for modules is built into all the go commands,</span><br><span class="line">not just &apos;go mod&apos;. For example, day-to-day adding, removing, upgrading,</span><br><span class="line">and downgrading of dependencies should be done using &apos;go get&apos;.</span><br><span class="line">See &apos;go help modules&apos; for an overview of module functionality.</span><br><span class="line">Usage:</span><br><span class="line">go mod &lt;command&gt; [arguments]</span><br><span class="line">The commands are:</span><br><span class="line">download    download modules to local cache</span><br><span class="line">edit        edit go.mod from tools or scripts</span><br><span class="line">graph       print module requirement graph</span><br><span class="line">init        initialize new module in current directory</span><br><span class="line">tidy        add missing and remove unused modules </span><br><span class="line">vendor      make vendored copy of dependencies</span><br><span class="line">verify      verify dependencies have expected content  </span><br><span class="line">why         explain why packages or modules are needed </span><br><span class="line">Use &quot;go help mod &lt;command&gt;&quot; for more information about a command.</span><br></pre></td></tr></table></figure><ul><li>go mod download: 下载依赖的 module 到本地 cache</li><li>go mod edit: 编辑 go.mod</li><li>go mod graph: 打印模块依赖图</li><li>go mod init: 在当前目录下初始化 go.mod(就是会新建一个 go.mod 文件)</li><li>go mod tidy: 整理依赖关系，会添加丢失的 module，删除不需要的 module</li><li>go mod vender: 将依赖复制到 vendor 下</li><li>go mod verify: 校验依赖</li><li>go mod why: 解释为什么需要依赖</li></ul><p>执行命令<code>go mod verify</code>命令来检查当前模块的依赖是否全部下载下来，是否下载下来被修改过。如果所有的模块都没有被修改过，那么执行这条命令之后，会打印<code>all modules verified</code>。</p><h3 id="如果在项目中使用"><a href="#如果在项目中使用" class="headerlink" title="如果在项目中使用"></a>如果在项目中使用</h3><ol><li>版本：首先将你的Go版本更新到(&gt;=1.11)，这里将不介绍怎么更新</li><li>设置环境变量(1.12默认)：在你的项目目录下使用<code>set GO111MODULE=ON</code></li><li>执行<code>go mod init</code>在当前目录下生成一个<code>go.mod</code>文件，如果之前有生成过需要删除再初始化</li></ol><p>执行完上面步骤基本就完成了，运行下程序你会发现目录下多了一个<code>go.sum</code>文件，是用来记录所依赖的版本的锁定</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>使用<code>go mod</code>后你会发现在<code>GOPATH</code>下面的<code>pkg</code>目录会有一个<code>mod</code>目录，里面包含了项目需要的依赖包，这也是为什么不需要再<code>GOPATH</code>中开发程序也能使用的原因</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我们都知道在使用Golang时开发程序时都需要在 &lt;code&gt;GOPATH&lt;/code&gt; 下面，这就非常不方便。如果你想放在磁盘上的其他地方，那么go mod将是你的“好伙伴”。&lt;/p&gt;
    
    </summary>
    
      <category term="后端" scheme="https://jiawea.github.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
      <category term="Golang" scheme="https://jiawea.github.io/tags/Golang/"/>
    
      <category term="mod" scheme="https://jiawea.github.io/tags/mod/"/>
    
  </entry>
  
  <entry>
    <title>初识Python asyncio异步编程</title>
    <link href="https://jiawea.github.io/2019/09/23/asyncio/"/>
    <id>https://jiawea.github.io/2019/09/23/asyncio/</id>
    <published>2019-09-23T07:58:52.000Z</published>
    <updated>2020-06-10T01:36:15.132Z</updated>
    
    <content type="html"><![CDATA[<p>同步代码(synchrnous code)<br>我们都很熟悉，就是运行完一个步骤再运行下一个。要在同步代码里面实现”同时”运行多个任务，最简单也是最直观地方式就是运行多个 threads 或者多个 processes。<br><a id="more"></a><br>这个层次的『同时运行』多个任务，是操作系统协助完成的。 也就是操作系统的任务调度系统来决定什么时候运行这个任务，什么时候切换任务，你自己，作为一个应用层的程序员，是没办法进行干预的。</p><p>我相信你也已经听说了什么关于 thread 和 process 的抱怨：process 太重，thread 又要牵涉到很多头条的锁问题。尤其是对于一个 Python 开发者来说，由于GIL（全局解释器锁）的存在，多线程无法真正使用多核，如果你用多线程来运行计算型任务，速度会更慢。</p><p>异步编程与之不同的是，值使用一个进程，不使用 threads，但是也能实现”同时”运行多个任务（这里的任务其实就是函数）。</p><p>这些函数有一个非常 nice 的 feature：必要的可以暂停，把运行的权利交给其他函数。等到时机恰当，又可以恢复之前的状态继续运行。这听上去是不是有点像进程呢？可以暂停，可以恢复运行。只不过进程的调度是操作系统完成的，这些函数的调度是进程自己（或者说程序员你自己）完成的。这也就意味着这将省去了很多计算机的资源，因为进程的调度必然需要大量 syscall，而 syscall 是很昂贵的。</p><h3 id="一-定义一个简单的协程："><a href="#一-定义一个简单的协程：" class="headerlink" title="一 定义一个简单的协程："></a>一 定义一个简单的协程：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">import asyncio</span><br><span class="line">  </span><br><span class="line">async def execute(x):</span><br><span class="line">    print(&apos;Number:&apos;, x)</span><br><span class="line">    return x</span><br><span class="line">  </span><br><span class="line">coroutine = execute(1)</span><br><span class="line">print(&apos;Coroutine:&apos;, coroutine)</span><br><span class="line">print(&apos;After calling execute&apos;)</span><br><span class="line">  </span><br><span class="line">loop = asyncio.get_event_loop()</span><br><span class="line">task = loop.create_task(coroutine)</span><br><span class="line">print(&apos;Task:&apos;, task)</span><br><span class="line">loop.run_until_complete(task)</span><br><span class="line">print(&apos;Task:&apos;, task)</span><br><span class="line">print(&apos;After calling loop&apos;)</span><br></pre></td></tr></table></figure><p>print(‘Task Result:’, task.result())  这样也能查看task执行的结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Coroutine: &lt;coroutine object execute at 0x10e0f7830&gt;</span><br><span class="line">After calling execute</span><br><span class="line">Task: &lt;Task pending coro=&lt;execute() running at demo.py:4&gt;&gt;</span><br><span class="line">Number: 1</span><br><span class="line">Task: &lt;Task finished coro=&lt;execute() done, defined at demo.py:4&gt; result=1&gt;</span><br><span class="line">After calling loop</span><br></pre></td></tr></table></figure><p>我们使用 async 定义了一个 execute() 方法，方法接收一个数字参数，方法执行之后会打印这个数字。<br>随后我们直接调用了这个方法，然而这个方法并没有执行，而是返回了一个 coroutine 协程对象。</p><p>随后我们使用 get_event_loop() 方法创建了一个事件循环 loop，并调用了 loop 对象的 run_until_complete() 方法将协程注册到事件循环 loop 中，然后启动。最后我们才看到了 execute() 方法打印了输出结果。可见，async 定义的方法就会变成一个无法直接执行的 coroutine 对象，必须将其注册到事件循环中才可以执行。</p><p>我们也可以不使用task来运行，它里面相比 coroutine 对象多了运行状态，比如 running、finished 等，我们可以用这些状态来获取协程对象的执行情况。将 coroutine 对象传递给 run_until_complete() 方法的时候，实际上它进行了一个操作就是将 coroutine 封装成了 task 对象，如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">import asyncio</span><br><span class="line"></span><br><span class="line">async def execute(x):</span><br><span class="line">    print(&apos;Number:&apos;, x)</span><br><span class="line"></span><br><span class="line">coroutine = execute(1)</span><br><span class="line">print(&apos;Coroutine:&apos;, coroutine)</span><br><span class="line">print(&apos;After calling execute&apos;)</span><br><span class="line"></span><br><span class="line">loop = asyncio.get_event_loop()</span><br><span class="line">loop.run_until_complete(coroutine)</span><br><span class="line">print(&apos;After calling loop&apos;)</span><br></pre></td></tr></table></figure><p>查看了源码，正好可以验证上面这一观点：</p><p>run_until_complete()这个方法位于源码中的base_events.py，函数有句注释：<br>Run until the Future is done.If the argument is a coroutine, it is wrapped in a Task.</p><h3 id="二-发送网络请求结合aiohttp实现异步："><a href="#二-发送网络请求结合aiohttp实现异步：" class="headerlink" title="二 发送网络请求结合aiohttp实现异步："></a>二 发送网络请求结合aiohttp实现异步：</h3><p>我们用一个网络请求作为示例，这就是一个耗时等待的操作，因为我们请求网页之后需要等待页面响应并返回结果。耗时等待的操作一般都是 IO 操作，比如文件读取、网络请求等等。协程对于处理这种操作是有很大优势的，当遇到需要等待的情况的时候，程序可以暂时挂起，转而去执行其他的操作，从而避免一直等待一个程序而耗费过多的时间，充分利用资源。为了测试，我自己先通过flask 创建一个实验环境：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">from flask import Flask</span><br><span class="line">import time</span><br><span class="line">  </span><br><span class="line">app = Flask(__name__)</span><br><span class="line">  </span><br><span class="line">@app.route(&apos;/&apos;)</span><br><span class="line">def index():</span><br><span class="line">    time.sleep(3)</span><br><span class="line">    return &apos;Hello!&apos;</span><br><span class="line">  </span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    app.run(threaded=True)</span><br></pre></td></tr></table></figure></p><p>开始测试…<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">import asyncio</span><br><span class="line">import aiohttp</span><br><span class="line">import time</span><br><span class="line">  </span><br><span class="line">start = time.time()</span><br><span class="line">  </span><br><span class="line">async def get(url):</span><br><span class="line">    session = aiohttp.ClientSession()</span><br><span class="line">    response = await session.get(url)</span><br><span class="line">    result = await response.text()</span><br><span class="line">    session.close()</span><br><span class="line">    return result</span><br><span class="line">  </span><br><span class="line">async def request():</span><br><span class="line">    url = &apos;http://127.0.0.1:5000&apos;          # 访问flask搭建的服务器（睡眠3秒），模仿IO阻塞</span><br><span class="line">    print(&apos;Waiting for&apos;, url)</span><br><span class="line">    result = await get(url)</span><br><span class="line">    print(&apos;Get response from&apos;, url, &apos;Result:&apos;, result)</span><br><span class="line">  </span><br><span class="line">tasks = [asyncio.ensure_future(request()) for _ in range(5)]</span><br><span class="line">loop = asyncio.get_event_loop()</span><br><span class="line">loop.run_until_complete(asyncio.wait(tasks))</span><br><span class="line">  </span><br><span class="line">end = time.time()</span><br><span class="line">print(&apos;Cost time:&apos;, end - start)</span><br></pre></td></tr></table></figure></p><p>运行结果…<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Waiting for http://127.0.0.1:5000</span><br><span class="line">Waiting for http://127.0.0.1:5000</span><br><span class="line">Waiting for http://127.0.0.1:5000</span><br><span class="line">Waiting for http://127.0.0.1:5000</span><br><span class="line">Waiting for http://127.0.0.1:5000</span><br><span class="line">Get response from http://127.0.0.1:5000 Result: Hello!</span><br><span class="line">Get response from http://127.0.0.1:5000 Result: Hello!</span><br><span class="line">Get response from http://127.0.0.1:5000 Result: Hello!</span><br><span class="line">Get response from http://127.0.0.1:5000 Result: Hello!</span><br><span class="line">Get response from http://127.0.0.1:5000 Result: Hello!</span><br><span class="line">Cost time: 3.0199508666992188</span><br></pre></td></tr></table></figure></p><p>我们发现这次请求的耗时由 15 秒变成了 3 秒，耗时直接变成了原来的 1/5。</p><p>代码里面我们使用了 await，后面跟了 get() 方法，在执行这五个协程的时候，如果遇到了 await，那么就会将当前协程挂起，转而去执行其他的协程，直到其他的协程也挂起或执行完毕，再进行下一个协程的执行。</p><h2 id="二-总结"><a href="#二-总结" class="headerlink" title="二 总结"></a>二 总结</h2><p>协程”同时”运行多个任务的基础是函数可以暂停（await实际就是用到了yield）。上面的代码中使用到了 asyncio的 event_loop，它做的事情，本质上来说就是当函数暂停时，切换到下一个任务，当时机恰当（这个例子中是请求完成了）恢复函数让他继续运行（这有点像操作系统了）。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;同步代码(synchrnous code)&lt;br&gt;我们都很熟悉，就是运行完一个步骤再运行下一个。要在同步代码里面实现”同时”运行多个任务，最简单也是最直观地方式就是运行多个 threads 或者多个 processes。&lt;br&gt;
    
    </summary>
    
      <category term="后端" scheme="https://jiawea.github.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
      <category term="异步" scheme="https://jiawea.github.io/tags/%E5%BC%82%E6%AD%A5/"/>
    
      <category term="asyncio" scheme="https://jiawea.github.io/tags/asyncio/"/>
    
  </entry>
  
  <entry>
    <title>关于我</title>
    <link href="https://jiawea.github.io/2019/09/23/index/"/>
    <id>https://jiawea.github.io/2019/09/23/index/</id>
    <published>2019-09-23T01:47:23.000Z</published>
    <updated>2020-05-30T05:59:14.240Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;2018年毕业于惠州经济职业技术学院，计算机网络专业。喜欢学习新事物，挑战自己。目前担任后端工程师。</p><p>&emsp;&emsp;关于写博客是希望认识更多拥有相同兴趣爱好的人，并记录一下自己学习历程，踩过的一些坑。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&amp;emsp;&amp;emsp;2018年毕业于惠州经济职业技术学院，计算机网络专业。喜欢学习新事物，挑战自己。目前担任后端工程师。&lt;/p&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;关于写博客是希望认识更多拥有相同兴趣爱好的人，并记录一下自己学习历程，踩过的一些坑。&lt;/p&gt;

      
    
    </summary>
    
    
      <category term="介绍" scheme="https://jiawea.github.io/tags/%E4%BB%8B%E7%BB%8D/"/>
    
  </entry>
  
</feed>
