<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Ray的博客</title>
  
  <subtitle>Keep coding...</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://jiawea.github.io/"/>
  <updated>2020-05-27T09:47:51.243Z</updated>
  <id>https://jiawea.github.io/</id>
  
  <author>
    <name>Ray Wong</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Golang的值类型和引用类型</title>
    <link href="https://jiawea.github.io/2020/05/27/Go_variable/"/>
    <id>https://jiawea.github.io/2020/05/27/Go_variable/</id>
    <published>2020-05-27T01:00:26.000Z</published>
    <updated>2020-05-27T09:47:51.243Z</updated>
    
    <content type="html"><![CDATA[<h3 id="值类型和引用类型"><a href="#值类型和引用类型" class="headerlink" title="值类型和引用类型"></a>值类型和引用类型</h3><ul><li>值类型：变量直接存储，内存通常在栈中分配。</li><li>引用类型：变量存储的是一个地址，这个地址存储最终的值。内存通常在堆上分配。通过GC回收</li></ul><p>PS : 通常在函数中转入指针效率比较高，因为方法中的参数是需要进行拷贝的，拷贝指针的效率比较高，要是一个大的接口体的话拷贝的效率就比较低</p><h3 id="GoLang中的值类型和引用类型"><a href="#GoLang中的值类型和引用类型" class="headerlink" title="GoLang中的值类型和引用类型"></a>GoLang中的值类型和引用类型</h3><ol><li>值类型 ： 基本数据类型int、float、bool、string以及数组和struct。</li><li>引用类型：指针、slice、map、chan等都是引用类型</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;值类型和引用类型&quot;&gt;&lt;a href=&quot;#值类型和引用类型&quot; class=&quot;headerlink&quot; title=&quot;值类型和引用类型&quot;&gt;&lt;/a&gt;值类型和引用类型&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;值类型：变量直接存储，内存通常在栈中分配。&lt;/li&gt;
&lt;li&gt;引用类型：变量存储
      
    
    </summary>
    
    
      <category term="Golang" scheme="https://jiawea.github.io/tags/Golang/"/>
    
      <category term="值类型" scheme="https://jiawea.github.io/tags/%E5%80%BC%E7%B1%BB%E5%9E%8B/"/>
    
      <category term="引用类型" scheme="https://jiawea.github.io/tags/%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>Redis类型及应用场景</title>
    <link href="https://jiawea.github.io/2020/05/24/Redis/"/>
    <id>https://jiawea.github.io/2020/05/24/Redis/</id>
    <published>2020-05-24T04:26:00.000Z</published>
    <updated>2020-05-27T09:41:31.268Z</updated>
    
    <content type="html"><![CDATA[<p>NoSQL非关系型数据库。<br>Redis支持5种数据类型：string(字符串), hash(哈希), list(双向列表), set(无序集合), zset(有序集合)</p><h3 id="1、string"><a href="#1、string" class="headerlink" title="1、string"></a>1、string</h3><p><strong>介绍</strong><br>string数据类型是最常用的、简单的key-value类型，普通的key/value存储都可以归为此类。value也可以是数字。因为是二进制安全的，所有可以将一个图片文件的内容作为string来存储。redis的string完全实现目前<code>memcached</code>的功能，并且效率更高。除了提供与memcached一样的<code>get</code>,<code>set</code>,<code>incr</code>,<code>decr</code>等操作外，还提供了下面的操作：</p><ol><li>获取字符串长度</li><li>往字符串append内容</li><li>设置和获取字符串的某一段内容</li><li>设置和获取字符串的某一位(bit)</li><li>批量设置一系列字符串的内容</li></ol><a id="more"></a><p><strong>应用场景</strong></p><ol><li>应用memcached和ckv的所有场景。字符串和数字之间存取。结构化数据需要先序列化，再set到value，取出时也需要反序列化。</li><li>可以利用INCR, INCRBY, DECR, DECRBY等指令来实现原子计数的效果。即可用来实现业务上的统计计数需求。</li><li>存放session key，实现一个分布式session系统。Redis的key可以方便地设置过期时间，用于实现session key的自动过期。验证skey时先根据uid路由到对应的redis，如取不到skey，则表示skey已过期，需要重新登录；如取到skey且校验通过则升级此skey的过期时间即可。</li><li>Set nx或SetNx，仅当key不存在时才Set。可以用来选举Master或实现分布式锁：所有Client不断尝试使用SetNx master myName抢注Master，成功的那位不断使用Expire刷新它的过期时间。如果Master挂掉了key就会失效，剩下的节点又会发生新一轮抢夺。</li><li>借助redis2.6开始支持的lua脚本，可以实现更安全的2种分布式锁：一种适用于各进程竞争但总是单个进程获取锁并处理的场景。除非原处理进程挂掉因而锁过期才会被其它进程获取到锁。无须主动解锁。通过get、expire/pexpire、setnx ex| px的lua脚本实现；一种适用于各进程竞争获取锁并处理的场景。通过set nx ex| px获取锁，用完需要通过先get判断再del释放锁，否则在锁过期之前不能获取到锁。</li><li>GetSet， 设置新值，返回旧值。比如实现一个计数器，可以用GetSet获取计数并重置为0。</li><li>GetBit/SetBit/BitOp/BitCount， BitMap的玩法，比如统计今天的独立访问用户数时，每个注册用户都有一个offset，他今天进来的话就把他那个位设为1，用BitCount就可以得出今天的总人数。</li><li>Append/SetRange/GetRange/StrLen，对文本进行扩展、替换、截取和求长度，对特定数据格式非常有用。</li></ol><p><strong>实现方式</strong><br>String在redis内部存储默认就是一个字符串，被redisObject所引用，当遇到incr,decr等操作时会转成数值型进行计算，此时redisObject的encoding字段为int。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;NoSQL非关系型数据库。&lt;br&gt;Redis支持5种数据类型：string(字符串), hash(哈希), list(双向列表), set(无序集合), zset(有序集合)&lt;/p&gt;
&lt;h3 id=&quot;1、string&quot;&gt;&lt;a href=&quot;#1、string&quot; class=&quot;headerlink&quot; title=&quot;1、string&quot;&gt;&lt;/a&gt;1、string&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;介绍&lt;/strong&gt;&lt;br&gt;string数据类型是最常用的、简单的key-value类型，普通的key/value存储都可以归为此类。value也可以是数字。因为是二进制安全的，所有可以将一个图片文件的内容作为string来存储。redis的string完全实现目前&lt;code&gt;memcached&lt;/code&gt;的功能，并且效率更高。除了提供与memcached一样的&lt;code&gt;get&lt;/code&gt;,&lt;code&gt;set&lt;/code&gt;,&lt;code&gt;incr&lt;/code&gt;,&lt;code&gt;decr&lt;/code&gt;等操作外，还提供了下面的操作：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;获取字符串长度&lt;/li&gt;
&lt;li&gt;往字符串append内容&lt;/li&gt;
&lt;li&gt;设置和获取字符串的某一段内容&lt;/li&gt;
&lt;li&gt;设置和获取字符串的某一位(bit)&lt;/li&gt;
&lt;li&gt;批量设置一系列字符串的内容&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="redis" scheme="https://jiawea.github.io/tags/redis/"/>
    
      <category term="NoSQL" scheme="https://jiawea.github.io/tags/NoSQL/"/>
    
  </entry>
  
  <entry>
    <title>MySQL优化</title>
    <link href="https://jiawea.github.io/2020/05/08/MySQL/"/>
    <id>https://jiawea.github.io/2020/05/08/MySQL/</id>
    <published>2020-05-08T01:30:18.000Z</published>
    <updated>2020-05-08T04:03:54.387Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-查询SQL尽量不要使用-select-而是select具体字段。"><a href="#1-查询SQL尽量不要使用-select-而是select具体字段。" class="headerlink" title="1 查询SQL尽量不要使用 select * ,而是select具体字段。"></a>1 查询SQL尽量不要使用 <code>select *</code> ,而是<code>select</code>具体字段。</h3><p>反例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from employee;</span><br></pre></td></tr></table></figure></p><p>正例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select id, name from employee;</span><br></pre></td></tr></table></figure></p><p>说明:</p><ol><li>只取需要的字段，节省资源、减少网络开销。</li><li>select * 进行查询时，很可能就不会使用到覆盖索引了，就会造成回表查询。</li></ol><a id="more"></a><h3 id="2-如果只查询结果只有一条的数据或者最大、最小一条记录，使用limit"><a href="#2-如果只查询结果只有一条的数据或者最大、最小一条记录，使用limit" class="headerlink" title="2 如果只查询结果只有一条的数据或者最大、最小一条记录，使用limit"></a>2 如果只查询结果只有一条的数据或者最大、最小一条记录，使用limit</h3><p>假如有employee员工表，要找出一个名字叫ray的人<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE  `employee`(</span><br><span class="line">  `id` int (11) NOT NULL,</span><br><span class="line">  `name` varchar(255) DEFAULT NULL,</span><br><span class="line">  `age` int(11) DEFAULT NULL,</span><br><span class="line">  `date` datetime DEFAULT NULL,</span><br><span class="line">  `sex` int (1) DEFAULT NULL,</span><br><span class="line">  PRIMARY KEY (`id`)</span><br><span class="line">) ENGINE=InnoDB DEFAULT CHARSET=utf8;</span><br></pre></td></tr></table></figure></p><p>反例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select id, name from employee where name=&apos;ray&apos;</span><br></pre></td></tr></table></figure></p><p>正例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select id, name from employee where name=&apos;ray&apos; limit 1;</span><br></pre></td></tr></table></figure></p><p>说明：</p><ol><li>加上limit 1后,只要找到了对应的一条记录,就不会继续向下扫描了,效率将会大大提高。</li><li>当然，如果name是唯一索引的话，是不必要加上limit 1了，因为limit的存在主要就是为了防止全表扫描，从而提高性能,如果一个语句本身可以预知不用全表扫描，有没有limit ，性能的差别并不大。</li></ol><h3 id="3-批量插入"><a href="#3-批量插入" class="headerlink" title="3 批量插入"></a>3 批量插入</h3><p>反例<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">INSERT into person(name,age) values(&apos;A&apos;,24)</span><br><span class="line">INSERT into person(name,age) values(&apos;B&apos;,24)</span><br><span class="line">INSERT into person(name,age) values(&apos;C&apos;,24)</span><br></pre></td></tr></table></figure></p><p>正例<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">INSERT into person(name,age) values(&apos;A&apos;,24),(&apos;B&apos;,24),(&apos;C&apos;,24);</span><br></pre></td></tr></table></figure></p><p>说明:</p><ol><li>比较常规，就不多做说明了</li></ol><h3 id="4-优化like语句"><a href="#4-优化like语句" class="headerlink" title="4 优化like语句"></a>4 优化like语句</h3><p>尽量使用右模糊<code>xxx%</code>代替左模糊或者全模糊</p><p>反例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select userId, name from user where user_id like &apos;%123&apos;;</span><br><span class="line">select userId, name from user where user_id like &apos;%123%&apos;;</span><br></pre></td></tr></table></figure></p><p>正例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select userId, name from user where user_id like &apos;123%&apos;;</span><br></pre></td></tr></table></figure></p><h3 id="5-避免SQL中对where字段进行函数转换或表达式计算"><a href="#5-避免SQL中对where字段进行函数转换或表达式计算" class="headerlink" title="5 避免SQL中对where字段进行函数转换或表达式计算"></a>5 避免SQL中对where字段进行函数转换或表达式计算</h3><p>反例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from employee where user_id + 1 = 15551;</span><br></pre></td></tr></table></figure></p><p>正例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from employee where user_id  = 15550;</span><br></pre></td></tr></table></figure></p><p>说明：</p><ol><li>将导致系统放弃使用索引而进行全表扫</li><li>其实在知道了有SQL优化器之后，我个人感觉这种普通的表达式转换应该可以提前进行处理再进行查询，这样一来就可以用到索引了，但是问题又来了，如果mysql优化器可以提前计算出结果，那么写sql语句的人也一定可以提前计算出结果，所以矛盾点在这个地方，导致5.7版本以前的此种情况都无法使用索引吧，未来可能会对其进行优化</li></ol><h3 id="6-超大分页场景解决方案-limit"><a href="#6-超大分页场景解决方案-limit" class="headerlink" title="6 超大分页场景解决方案(limit)"></a>6 超大分页场景解决方案(limit)</h3><p>我们日常做分页需求时，一般会用 limit 实现，但是当偏移量特别大的时候，查询效率就变得低下。</p><p>反例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select id, name, age from employee LIMIT 1000000, 10;</span><br></pre></td></tr></table></figure></p><p>正例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 方案一：返回上次查询的最大记录（偏移量）</span><br><span class="line">select id, name, age from employee id &gt; 1000000 limit 10;</span><br><span class="line"></span><br><span class="line">// 方案二：先通过索引查询需要的id</span><br><span class="line">select id, name, age from employee a, (select id from employee limit 1000000, 10) b where a.id = b.id;</span><br><span class="line"></span><br><span class="line">// 方案三：order by + 索引</span><br><span class="line">select id, name, age from employee order by id limit 1000000, 10</span><br></pre></td></tr></table></figure></p><p>说明：</p><ol><li>MySQL 并不是跳过 offset 行，而是取 offset+N 行，然后返回放弃前 offset 行，返回 N 行，那当 offset 特别大的时候，效率就非常的低下，要么控制返回的总页数，要么对超过特定阈值的页数进行 SQL 改写</li></ol><h3 id="7-尽量避免在where子句中使用-或-lt-gt-操作符，否则将引擎放弃使用索引而进行全表扫描。"><a href="#7-尽量避免在where子句中使用-或-lt-gt-操作符，否则将引擎放弃使用索引而进行全表扫描。" class="headerlink" title="7 尽量避免在where子句中使用!=或&lt;&gt;操作符，否则将引擎放弃使用索引而进行全表扫描。"></a>7 尽量避免在where子句中使用!=或&lt;&gt;操作符，否则将引擎放弃使用索引而进行全表扫描。</h3><p>反例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select age, name from user where age &lt;&gt; 18;</span><br></pre></td></tr></table></figure></p><p>正例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 可以考虑分开两条sql写</span><br><span class="line">select age, name from user where age &lt; 18;</span><br><span class="line">select age, name from user where age &gt; 18;</span><br></pre></td></tr></table></figure></p><p>说明：</p><ol><li>使用!=和&lt;&gt;很可能会让索引失效</li></ol><h3 id="8-对查询进行优化，应考虑在where及order-by涉及的列上建立索引，尽量避免全表扫描。"><a href="#8-对查询进行优化，应考虑在where及order-by涉及的列上建立索引，尽量避免全表扫描。" class="headerlink" title="8 对查询进行优化，应考虑在where及order by涉及的列上建立索引，尽量避免全表扫描。"></a>8 对查询进行优化，应考虑在where及order by涉及的列上建立索引，尽量避免全表扫描。</h3><p>对经常使用where和order by的字段加上索引</p><h3 id="9-where子句中考虑使用默认值代替null。"><a href="#9-where子句中考虑使用默认值代替null。" class="headerlink" title="9 where子句中考虑使用默认值代替null。"></a>9 where子句中考虑使用默认值代替null。</h3><p>反例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from user where age is not null;</span><br></pre></td></tr></table></figure></p><p>正例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 设置默认值为 0 </span><br><span class="line">select * from user where age &gt; 0;</span><br></pre></td></tr></table></figure></p><p>说明：</p><ol><li>并不是说使用了is null 或者 is not null 就会不走索引了，这个跟mysql版本以及查询成本都有关。</li><li>如果把null值，换成默认值，很多时候让走索引成为可能，同时，表达意思会相对清晰一点。</li></ol><h3 id="10-索引不宜太多，一般5个以内"><a href="#10-索引不宜太多，一般5个以内" class="headerlink" title="10 索引不宜太多，一般5个以内"></a>10 索引不宜太多，一般5个以内</h3><p>说明：</p><ol><li>索引并不是越多越好，索引虽然提高了查询的效率，但是也降低了插入和更新的效率。</li><li>insert或update时有可能会重建索引，所以建索引需要慎重考虑，视具体情况来定。</li><li>一个表的索引数最好不要超过5个，若太多需要考虑一些索引是否没有存在的必要。</li></ol><p>###　11 索引不适合建在有大量重复数据的字段上，如性别这类型数据库字段</p><p>说明：</p><ol><li>因为SQL优化器是根据表中数据量来进行查询优化的，如果索引列有大量重复数据，Mysql查询优化器推算发现不走索引的成本更低，很可能就放弃索引了。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-查询SQL尽量不要使用-select-而是select具体字段。&quot;&gt;&lt;a href=&quot;#1-查询SQL尽量不要使用-select-而是select具体字段。&quot; class=&quot;headerlink&quot; title=&quot;1 查询SQL尽量不要使用 select * ,而是select具体字段。&quot;&gt;&lt;/a&gt;1 查询SQL尽量不要使用 &lt;code&gt;select *&lt;/code&gt; ,而是&lt;code&gt;select&lt;/code&gt;具体字段。&lt;/h3&gt;&lt;p&gt;反例：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;select * from employee;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;正例：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;select id, name from employee;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;说明:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;只取需要的字段，节省资源、减少网络开销。&lt;/li&gt;
&lt;li&gt;select * 进行查询时，很可能就不会使用到覆盖索引了，就会造成回表查询。&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="MySQL" scheme="https://jiawea.github.io/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>HTTP和WebSocket协议的区别</title>
    <link href="https://jiawea.github.io/2020/04/11/Http_WebSocket/"/>
    <id>https://jiawea.github.io/2020/04/11/Http_WebSocket/</id>
    <published>2020-04-11T07:30:00.000Z</published>
    <updated>2020-04-27T01:22:49.349Z</updated>
    
    <content type="html"><![CDATA[<p>最近需要实现一个可以和客户端进行实时通讯的后端服务，由于后端可以主动发送消息给客户端，如果使用<code>HTTP</code>的话服务端是不能主动向客户端发送信息的，之前对<code>Socket</code>只是一个大概的了解。所以查了一些相关的资料，记录一下<code>HTTP</code>和<code>WebSocket</code>的区别。</p><a id="more"></a><h3 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h3><p>HTTP是一个Request/Response请求和响应的模式，两种类型都是由请求行、请求头、空行、请求主体四部分组成。这里将不详细介绍，可看我之前的文章。<br>只有客户端向服务端发送一个请求后，服务端才能向客户端回复，客户端在没有请求服务端时，服务端是不能主动向客户端发送数据的。</p><h4 id="短连接"><a href="#短连接" class="headerlink" title="短连接"></a>短连接</h4><p>举个栗子：<br>比如说客户端想实时地知道某个状态是否<strong>发生</strong>变化时，于是请求了服务端，但是服务端此时又<strong>没有发生</strong>变化。遇到这种情况下客户端只能不断地想服务端发送请求，直到返回满意的结果。这也就是我们所说的<strong>轮询</strong>。这是一个很浪费资源的，因为每个资源都需要建立一个新的连接，而HTTP底层使用的是<code>TCP</code>，每次都需要三次握手建立连接，所以会造成资源浪费。</p><p>于是由引出了一个新的概念，<code>HTTP</code>长连接，这里的长连接和<code>socket</code>的长连接是有区别的，这个稍后再说。</p><h4 id="长连接"><a href="#长连接" class="headerlink" title="长连接"></a>长连接</h4><p>所谓的长连接就是客户端向服务端发送请求，服务端不需要马上回复客户端，只有等到服务端有结果了才向客户端回复。相比上面的短连接可以减少连接次数和压力。</p><center><img src="/static/blogImg/HTTP_connect.png" alt="avatar">WebSocket.png</center><p>在一个TCP连接上也可以传输多个Request/Response消息对，但是HTTP的基本模型还是一个Request对应一个Response。</p><h3 id="WebSocket"><a href="#WebSocket" class="headerlink" title="WebSocket"></a>WebSocket</h3><p>WebSocket 协议在2008年诞生，2011年成为国际标准。所有浏览器都已经支持了。</p><p>它的最大特点就是，服务器可以主动向客户端推送信息，客户端也可以主动向服务器发送信息，是真正的双向平等对话，属于服务器推送技术的一种。</p><center><img src="/static/blogImg/WebSocket.png" alt="avatar"></center><p>其他特点包括：</p><ol><li>建立在 TCP 协议之上，服务器端的实现比较容易。</li><li>与 HTTP 协议有着良好的兼容性。默认端口也是80和443，并且握手阶段采用 HTTP 协议，因此不容易屏蔽，能通过各种 HTTP 代理服务器。</li><li>数据格式比较轻量，性能开销小，通信高效。</li><li>可以发送文本，也可以发送二进制数据。</li><li>没有同源限制，客户端可以与任意服务器通信。</li><li>协议标识符是ws（如果加密，则为wss），服务器网址就是 URL。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ws://example.com:80/some/path</span><br></pre></td></tr></table></figure><center><img src="/static/blogImg/tcp_http_ws.png" alt="avatar"></center><h4 id="WebSocket协议的规范"><a href="#WebSocket协议的规范" class="headerlink" title="WebSocket协议的规范"></a>WebSocket协议的规范</h4><p>以下是一个典型的WebSocket发起请求到响应请求的示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">客户端到服务端：</span><br><span class="line">GET / HTTP/1.1</span><br><span class="line">Connection:Upgrade</span><br><span class="line">Host:127.0.0.1:8088</span><br><span class="line">Origin:null</span><br><span class="line">Sec-WebSocket-Extensions:x-webkit-deflate-frame</span><br><span class="line">Sec-WebSocket-Key:puVOuWb7rel6z2AVZBKnfw==</span><br><span class="line">Sec-WebSocket-Version:13</span><br><span class="line">Upgrade:websocket</span><br><span class="line"></span><br><span class="line">服务端到客户端：</span><br><span class="line">HTTP/1.1 101 Switching Protocols</span><br><span class="line">Connection:Upgrade</span><br><span class="line">Server:beetle websocket server</span><br><span class="line">Upgrade:WebSocket</span><br><span class="line">date: Thu, 10 May 2018 07:32:25 GMT</span><br><span class="line">Access-Control-Allow-Credentials:true</span><br><span class="line">Access-Control-Allow-Headers:content-type</span><br><span class="line">Sec-WebSocket-Accept:FCKgUr8c7OsDsLFeJTWrJw6WO8Q=</span><br></pre></td></tr></table></figure></p><p>我们可以看到，WebSocket协议和HTTP协议乍看并没有太大的区别，但细看下来，区别还是有些的，这其实是一个握手的http请求，首先请求和响应的，”Upgrade:WebSocket”表示请求的目的就是要将客户端和服务器端的通讯协议从 HTTP 协议升级到 WebSocket协议。从客户端到服务器端请求的信息里包含有”Sec-WebSocket-Extensions”、“Sec-WebSocket-Key”这样的头信息。这是客户端浏览器需要向服务器端提供的握手信息，服务器端解析这些头信息，并在握手的过程中依据这些信息生成一个28位的安全密钥并返回给客户端，以表明服务器端获取了客户端的请求，同意创建 WebSocket 连接。</p><p>当握手成功后，这个时候TCP连接就已经建立了，客户端与服务端就能够直接通过WebSocket直接进行数据传递。不过服务端还需要判断一次数据请求是什么时候开始的和什么时候是请求的结束的。在WebSocket中，由于浏览端和服务端已经打好招呼，如我发送的内容为utf-8编码，如果我发送0x00,表示包的开始，如果发送了0xFF，就表示包的结束了。这就解决了黏包的问题。</p><h4 id="与HTTP的相同点"><a href="#与HTTP的相同点" class="headerlink" title="与HTTP的相同点"></a>与HTTP的相同点</h4><ol><li>都是基于TCP的应用层协议。</li><li>都使用Request/Response模型进行连接的建立。</li><li>在连接的建立过程中对错误的处理方式相同，在这个阶段WS可能返回和HTTP相同的返回码。</li><li>都可以在网络中传输数据。</li></ol><h4 id="与HTTP的不同点"><a href="#与HTTP的不同点" class="headerlink" title="与HTTP的不同点"></a>与HTTP的不同点</h4><ol><li>WS使用HTTP来建立连接，但是定义了一系列新的header域，这些域在HTTP中并不会使用。</li><li>WS的连接不能通过中间人来转发，它必须是一个直接连接。</li><li>WS连接建立之后，通信双方都可以在任何时刻向另一方发送数据。</li><li>WS连接建立之后，数据的传输使用帧来传递，不再需要Request消息。</li><li>WS的数据帧有序。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近需要实现一个可以和客户端进行实时通讯的后端服务，由于后端可以主动发送消息给客户端，如果使用&lt;code&gt;HTTP&lt;/code&gt;的话服务端是不能主动向客户端发送信息的，之前对&lt;code&gt;Socket&lt;/code&gt;只是一个大概的了解。所以查了一些相关的资料，记录一下&lt;code&gt;HTTP&lt;/code&gt;和&lt;code&gt;WebSocket&lt;/code&gt;的区别。&lt;/p&gt;
    
    </summary>
    
    
      <category term="HTTP" scheme="https://jiawea.github.io/tags/HTTP/"/>
    
      <category term="WebSocket" scheme="https://jiawea.github.io/tags/WebSocket/"/>
    
      <category term="TCP" scheme="https://jiawea.github.io/tags/TCP/"/>
    
  </entry>
  
  <entry>
    <title>RPC是什么</title>
    <link href="https://jiawea.github.io/2020/03/27/WHAT-IS-RPC/"/>
    <id>https://jiawea.github.io/2020/03/27/WHAT-IS-RPC/</id>
    <published>2020-03-27T02:28:49.000Z</published>
    <updated>2020-04-27T01:16:17.640Z</updated>
    
    <content type="html"><![CDATA[<p>RPC（Remote Procedure Call Protocol）—— 远程过程调用协议，它是一种通过网络从远程计算机程序上请求服务，而不需要了解底层网络技术的协议。</p><p>​简单来说，就是跟远程访问或者web请求差不多，都是一个client向远端服务器请求服务返回结果，但是web请求使用的网络协议是<code>http</code>高层协议，而<code>rpc</code>所使用的协议多为<code>TCP</code>，是网络层协议，减少了信息的包装，加快了处理速度。</p><center><img src="/static/blogImg/RemoteProcedureCall.png" alt="client"></center><a id="more"></a><p>说起<code>RPC</code>，就不能不提到<code>分布式</code>（促使RPC诞生的领域）。</p><h3 id="举个栗子"><a href="#举个栗子" class="headerlink" title="举个栗子.."></a>举个栗子..</h3><p>假如你实现了一个计算器接口，Caculator，以及它实现类CalculatorImpl，那么在系统还是单位应用时，只需要new一个CalculatorImpl，然后直接调用其方法，例如<code>add</code>，<code>times</code>等就可以了，这就是普通的<code>本地调用</code>，因为在同一个地址空间/同一块内存。</p><p>但是由于业务上的考虑，基于高性能可靠等因素你得将系统改造为<code>分布式应用</code>。将很多可以共用的分享功能单独做成一个服务，让其他所有服务可以直接调用。</p><p>那么问题来了，如何调用这个单独出来的服务呢？</p><p>你可能会说，模仿B/S架构方式呀，把单独出来共享服务，这里简称为<code>服务C</code>，提供一个<code>Restful</code>接口，然后用<code>Http</code>调用。</p><p>这样确实可以实现，那这样就每次调用都需要发送一连串的的<code>Http</code>请求了，如<code>request.get()</code>等。那能不能像本地调用一样呢？此时<code>RPC</code>的作用到了。使用<code>代理模式</code>，让用户直接引入<code>服务C</code>提供的类。而代理内部就是通过<code>Htpp</code>或者<code>TCP/UPD</code>来实现<code>RPC</code>远程过程调用的。</p><p><strong>说到这，总结一下<code>RPC</code>要解决的问题：</strong></p><ul><li>解决分布式系统中，服务之间的调用问题。</li><li>远程调用时，要能够像本地直接调用一样方便，用调用者感觉不到是在远程调用</li></ul><h3 id="实现一个RPC"><a href="#实现一个RPC" class="headerlink" title="实现一个RPC"></a>实现一个RPC</h3><p><strong>RPC工作流程</strong></p><ol><li>本地调用某个类的函数方法</li><li>本地机器的<code>RPC</code>框架把这个调用信息封装起来（调用函数、入参、提供服务机器地址端口等），将数据序列化成<code>JSON</code>或者<code>XML</code>后以二进制的方式通过网络传输（如Socket）发送给远程服务器</li><li>远程服务器收到调用后，远程机器的<code>RPC</code>框架获取二进制数据后反序列化出来，并根据调用信息定位到实现要执行的方法，执行完后序列化结果，通过网络传输把执行结果发送回本地机器。</li><li>本地机器的<code>RPC</code>框架反序列化出执行结果。</li></ol><p>Client端（本地机器）：</p><center><img src="/static/blogImg/RPC-client.jpg" alt="client"></center><p>Service端（远程机器）：</p><center><img src="/static/blogImg/RPC-service.jpg" alt="service"></center><p>总体流程：</p><center><img src="/static/blogImg/RPC.jpg" alt="rpc"></center><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>如何解决通讯问题？<br>客户端和服务器之前建立<code>TPC</code>连接，远程过程调用的所有交换数据都在这个连接里传输。连接可以是按需连接，调用结束后断开链接。</p><p>如何解决寻址问题？<br>客户端机器应用要怎么告诉底层<code>RPC</code>框架，如何连接到服务端机器（主机/IP、端口），方法名称是什么，这样才能调用。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;RPC（Remote Procedure Call Protocol）—— 远程过程调用协议，它是一种通过网络从远程计算机程序上请求服务，而不需要了解底层网络技术的协议。&lt;/p&gt;
&lt;p&gt;​简单来说，就是跟远程访问或者web请求差不多，都是一个client向远端服务器请求服务返回结果，但是web请求使用的网络协议是&lt;code&gt;http&lt;/code&gt;高层协议，而&lt;code&gt;rpc&lt;/code&gt;所使用的协议多为&lt;code&gt;TCP&lt;/code&gt;，是网络层协议，减少了信息的包装，加快了处理速度。&lt;/p&gt;
&lt;center&gt;&lt;img src=&quot;/static/blogImg/RemoteProcedureCall.png&quot; alt=&quot;client&quot;&gt;&lt;/center&gt;
    
    </summary>
    
    
      <category term="RPC" scheme="https://jiawea.github.io/tags/RPC/"/>
    
  </entry>
  
  <entry>
    <title>算法之链表</title>
    <link href="https://jiawea.github.io/2019/12/10/Algorithm-linked-list/"/>
    <id>https://jiawea.github.io/2019/12/10/Algorithm-linked-list/</id>
    <published>2019-12-10T04:01:36.000Z</published>
    <updated>2020-04-27T01:18:16.353Z</updated>
    
    <content type="html"><![CDATA[<h2 id="单向链表"><a href="#单向链表" class="headerlink" title="单向链表"></a>单向链表</h2><p>单向链表也叫单链表，是链表中最简单的一种形式，它的每个节点包含两个域，一个信息域（元素域）和一个链接域。这个链接指向链表中的下一个节点，而最后一个节点的链接域则指向一个空值。<br><a id="more"></a></p><p><center><img src="https://img-blog.csdnimg.cn/20191111093914440.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0pJQVdFQQ==,size_16,color_FFFFFF,t_70" alt="单向链表"></center></p><ul><li>表元素域elem用来存放具体的数据。</li><li>链接域next用来存放下一个节点的位置（python中的标识）</li><li>变量p指向链表的头节点（首节点）的位置，从p出发能找到表中的任意节点。</li></ul><p><strong>下面引用算法图解一书中的链表：</strong><br>链表中的元素可存储在内存的任何地方。</p><p><center><img src="https://img-blog.csdnimg.cn/20191111094236680.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0pJQVdFQQ==,size_16,color_FFFFFF,t_70" alt="链表在内存"></center><br>链表的每个元素都存储了下一个元素的地址，从而使一系列随机的内存地址串在一起。</p><p><center><img src="https://img-blog.csdnimg.cn/20191111094413665.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0pJQVdFQQ==,size_16,color_FFFFFF,t_70" alt="串在一起的链表"></center><br>这犹如寻宝游戏。你前往第一个地址，那里有一张纸条写着“下一个元素的地址为123”。因此，你前往地址123，那里又有一张纸条写着“下一个元素的地址为668”。在链表中添加元素很容易：只需将其放入内存，并将其地址存储到前一个元素中。</p><h2 id="链表与顺序表的对比"><a href="#链表与顺序表的对比" class="headerlink" title="链表与顺序表的对比"></a>链表与顺序表的对比</h2><p>链表失去了顺序表随机读取的优点，同时链表由于增加了结点的指针域，空间开销比较大，但对存储空间的使用要相对灵活。</p><p>链表与顺序表的各种操作复杂度如下所示：<br>操作| 链表|  顺序表<br>-|-|-<br>访问元素| O(n) | O(1) |<br>在头部插入/删除|  O(1)  | O(n) |<br>在尾部插入/删除| O(n) |  O(1)  |<br>在中间插入/删除| O(n) | O(n) |</p><p>注意虽然表面看起来复杂度都是 O(n)，但是链表和顺序表在插入和删除时进行的是完全不同的操作。链表的主要耗时操作是遍历查找，删除和插入操作本身的复杂度是O(1)。顺序表查找很快，主要耗时的操作是拷贝覆盖。因为除了目标元素在尾部的特殊情况，顺序表进行插入和删除时需要对操作点之后的所有元素进行前后移位操作，只能通过拷贝和覆盖的方法进行。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;单向链表&quot;&gt;&lt;a href=&quot;#单向链表&quot; class=&quot;headerlink&quot; title=&quot;单向链表&quot;&gt;&lt;/a&gt;单向链表&lt;/h2&gt;&lt;p&gt;单向链表也叫单链表，是链表中最简单的一种形式，它的每个节点包含两个域，一个信息域（元素域）和一个链接域。这个链接指向链表中的下一个节点，而最后一个节点的链接域则指向一个空值。&lt;br&gt;
    
    </summary>
    
    
      <category term="算法" scheme="https://jiawea.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="链表" scheme="https://jiawea.github.io/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>Docker之数据卷volume</title>
    <link href="https://jiawea.github.io/2019/12/10/Docker-volume/"/>
    <id>https://jiawea.github.io/2019/12/10/Docker-volume/</id>
    <published>2019-12-10T03:48:02.000Z</published>
    <updated>2020-04-27T01:26:02.217Z</updated>
    
    <content type="html"><![CDATA[<p><strong>数据卷</strong><br>默认情况下，在容器内创建的所有文件都存储在可写容器层上。这意味着：</p><ul><li>当该容器不再存在时，数据将不会持久保存，并且如果另一个进程需要它，则可能很难从容器中取出数据。</li><li>容器的可写层与运行容器的主机紧密耦合。您不能轻易地将数据移动到其他地方。</li><li>写入容器的可写层需要 存储驱动程序来管理文件系统。存储驱动程序使用Linux内核提供联合文件系统。与使用直接写入主机文件系统的数据卷相比，这种额外的抽象降低了性能 。</li></ul><center><img src="/static/blogImg/DockerVolume.jpg" alt="avatar"></center><a id="more"></a><p>Docker为容器提供了两个选项来将文件存储在主机中，以便即使容器停止后文件也可以持久存储：</p><ul><li>bind mount（绑定安装）</li><li>volume（数据卷）</li></ul><h3 id="volume："><a href="#volume：" class="headerlink" title="volume："></a>volume：</h3><p>是一个可供一个或多个容器使用的特殊目录，它绕过 UFS，可以提供很多有用的特性：</p><ul><li>数据卷 可以在容器之间共享和重用</li><li>对 数据卷 的修改会立马生效</li><li>对 数据卷 的更新，不会影响镜像</li><li>数据卷 默认会一直存在，即使容器被删除</li></ul><h3 id="bind-mount："><a href="#bind-mount：" class="headerlink" title="bind mount："></a>bind mount：</h3><ul><li>文件或目录由主机上的完整路径引用。</li><li>该文件或目录不需要在Docker主机上已经存在。如果尚不存在，则按需创建。</li><li>性能非常好，但是它们依赖于具有特定目录结构的主机文件系统。</li></ul><p><strong>注意：可以通过容器中运行的进程来更改主机文件系统 ，包括创建，修改或删除重要的系统文件或目录，存在安全隐患</strong></p><h2 id="创建数据卷"><a href="#创建数据卷" class="headerlink" title="创建数据卷"></a>创建数据卷</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker volume create my-vol</span><br></pre></td></tr></table></figure><p>查看所有的 数据卷<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker volume ls</span><br><span class="line">local               my-vol</span><br></pre></td></tr></table></figure></p><p>在主机里使用以下命令可以查看指定 数据卷 的信息<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ docker volume inspect my-vol</span><br><span class="line"></span><br><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;Driver&quot;: &quot;local&quot;,</span><br><span class="line">        &quot;Labels&quot;: &#123;&#125;,</span><br><span class="line">        &quot;Mountpoint&quot;: &quot;/var/lib/docker/volumes/my-vol/_data&quot;,</span><br><span class="line">        &quot;Name&quot;: &quot;my-vol&quot;,</span><br><span class="line">        &quot;Options&quot;: &#123;&#125;,</span><br><span class="line">        &quot;Scope&quot;: &quot;local&quot;</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p><h3 id="查看数据卷的具体信息"><a href="#查看数据卷的具体信息" class="headerlink" title="查看数据卷的具体信息"></a>查看数据卷的具体信息</h3><p>在主机里使用以下命令可以查看 web 容器的信息<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">$ docker inspect web</span><br><span class="line">数据卷 信息在 &quot;Mounts&quot; Key 下面</span><br><span class="line"></span><br><span class="line">&quot;Mounts&quot;: [</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;Type&quot;: &quot;volume&quot;,</span><br><span class="line">        &quot;Name&quot;: &quot;my-vol&quot;,</span><br><span class="line">        &quot;Source&quot;: &quot;/var/lib/docker/volumes/my-vol/_data&quot;,</span><br><span class="line">        &quot;Destination&quot;: &quot;/app&quot;,</span><br><span class="line">        &quot;Driver&quot;: &quot;local&quot;,</span><br><span class="line">        &quot;Mode&quot;: &quot;&quot;,</span><br><span class="line">        &quot;RW&quot;: true,</span><br><span class="line">        &quot;Propagation&quot;: &quot;&quot;</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p><h3 id="启动一个挂载数据卷的容器"><a href="#启动一个挂载数据卷的容器" class="headerlink" title="启动一个挂载数据卷的容器"></a>启动一个挂载数据卷的容器</h3><p>在用 docker run 命令的时候，使用 <code>--mount</code> 标记或者直接使用<code>-v</code>来将 数据卷 挂载到容器里。在一次 docker run 中可以挂载多个 数据卷。</p><p>下面创建一个名为 web 的容器，并加载一个 数据卷 到容器的 /webapp 目录。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -d -P \</span><br><span class="line">    --name web \</span><br><span class="line">    # -v my-vol:/wepapp \</span><br><span class="line">    --mount source=my-vol,target=/webapp \</span><br><span class="line">    training/webapp \</span><br><span class="line">    python app.py</span><br></pre></td></tr></table></figure></p><h3 id="删除数据卷"><a href="#删除数据卷" class="headerlink" title="删除数据卷"></a>删除数据卷</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker volume rm my-vol</span><br></pre></td></tr></table></figure><p>数据卷 是被设计用来持久化数据的，它的生命周期独立于容器，Docker 不会在容器被删除后自动删除 数据卷，并且也不存在垃圾回收这样的机制来处理没有任何容器引用的 数据卷。如果需要在删除容器的同时移除数据卷。可以在删除容器的时候使用<code>docker rm -v</code> 这个命令。</p><p>无主的数据卷可能会占据很多空间，要清理请使用以下命令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker volume prune</span><br></pre></td></tr></table></figure></p><p>在删除容器的时候也可使用<code>-v</code>来删除数据卷或者在启动容器是加上<code>--rm</code>，如：</p><ul><li><code>docker rm -v 容器</code></li><li><code>docker run --rm</code></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;数据卷&lt;/strong&gt;&lt;br&gt;默认情况下，在容器内创建的所有文件都存储在可写容器层上。这意味着：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;当该容器不再存在时，数据将不会持久保存，并且如果另一个进程需要它，则可能很难从容器中取出数据。&lt;/li&gt;
&lt;li&gt;容器的可写层与运行容器的主机紧密耦合。您不能轻易地将数据移动到其他地方。&lt;/li&gt;
&lt;li&gt;写入容器的可写层需要 存储驱动程序来管理文件系统。存储驱动程序使用Linux内核提供联合文件系统。与使用直接写入主机文件系统的数据卷相比，这种额外的抽象降低了性能 。&lt;/li&gt;
&lt;/ul&gt;
&lt;center&gt;&lt;img src=&quot;/static/blogImg/DockerVolume.jpg&quot; alt=&quot;avatar&quot;&gt;&lt;/center&gt;
    
    </summary>
    
    
      <category term="Docker" scheme="https://jiawea.github.io/tags/Docker/"/>
    
      <category term="volume" scheme="https://jiawea.github.io/tags/volume/"/>
    
  </entry>
  
  <entry>
    <title>算法之顺序表</title>
    <link href="https://jiawea.github.io/2019/11/08/Algorithm-SeqList/"/>
    <id>https://jiawea.github.io/2019/11/08/Algorithm-SeqList/</id>
    <published>2019-11-08T02:49:50.000Z</published>
    <updated>2020-04-27T01:19:05.808Z</updated>
    
    <content type="html"><![CDATA[<h2 id="顺序表"><a href="#顺序表" class="headerlink" title="顺序表"></a>顺序表</h2><p>在程序中，经常需要将一组（通常是同为某个类型的）数据元素作为整体管理和使用，需要创建这种元素组，用变量记录它们，传进传出函数等。一组数据中包含的元素个数可能发生变化（可以增加或删除元素）。</p><p>对于这种需求，最简单的解决方案便是将这样一组元素看成一个序列，用元素在序列里的位置和顺序，表示实际应用中的某种有意义的信息，或者表示数据之间的某种关系。</p><a id="more"></a><p>这样的一组序列元素的组织形式，我们可以将其抽象为线性表。一个线性表是某类元素的一个集合，还记录着元素之间的一种顺序关系。线性表是最基本的数据结构之一，在实际程序中应用非常广泛，它还经常被用作更复杂的数据结构的实现基础。</p><p>根据线性表的实际存储方式，分为两种实现模型：</p><ul><li><strong>顺序表</strong>，将元素顺序地存放在一块连续的存储区里，元素间的顺序关系由它们的存储顺序自然表示。</li><li><strong>链表</strong>，将元素存放在通过链接构造起来的一系列存储块中。</li></ul><h2 id="顺序表的基本形式"><a href="#顺序表的基本形式" class="headerlink" title="顺序表的基本形式"></a>顺序表的基本形式</h2><p><center><img src="https://img-blog.csdnimg.cn/20191108094130855.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0pJQVdFQQ==,size_16,color_FFFFFF,t_70" alt="顺序表基本形式"></center><br>图a表示的是顺序表的基本形式，数据元素本身连续存储，每个元素所占的存储单元大小固定相同，元素的下标是其逻辑地址，而元素存储的物理地址（实际内存地址）可以通过存储区的起始地址Loc (e0)加上逻辑地址（第i个元素）与存储单元大小（c）的乘积计算而得，即：</p><p><strong>Loc(ei) = Loc(e0) + c*i</strong></p><p>故，访问指定元素时无需从头遍历，通过计算便可获得对应地址，其时间复杂度为<strong>O(1)</strong>。<br>如果元素的大小不统一（如Python中的一个列表中有多种数据类型：[1, “a”, 1.001]等），则须采用图b的元素外置的形式，将实际数据元素另行存储，而顺序表中各单元位置保存对应元素的地址信息（即链接）。由于每个链接所需的存储量相同，通过上述公式，可以计算出元素链接的存储位置，而后顺着链接找到实际存储的数据元素。<strong>注意，图b中的c不再是数据元素的大小，而是存储一个链接地址所需的存储量，这个量通常很小。</strong><br>图b这样的顺序表也被称为对实际数据的索引，这是最简单的索引结构。</p><h2 id="顺序表的结构与实现"><a href="#顺序表的结构与实现" class="headerlink" title="顺序表的结构与实现"></a>顺序表的结构与实现</h2><p><strong>顺序表的结构</strong></p><p><center><img src="https://img-blog.csdnimg.cn/20191108094457522.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0pJQVdFQQ==,size_16,color_FFFFFF,t_70" alt="顺序表的结构"></center><br>一个顺序表的完整信息包括两部分：</p><ul><li>一部分是表中的元素集合</li><li>另一部分是为实现正确操作而需记录的信息，即有关表的整体情况的信息，这部分信息主要包括元素存储区的容量和当前表中已有的元素个数两项。</li></ul><p><strong>顺序表的两种基本实现方式</strong></p><p><center><img src="https://img-blog.csdnimg.cn/2019110809464595.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0pJQVdFQQ==,size_16,color_FFFFFF,t_70" alt="顺序表两种基本实现方式"></center><br>图a为一体式结构，存储表信息的单元与元素存储区以连续的方式安排在一块存储区里，两部分数据的整体形成一个完整的顺序表对象。</p><p>一体式结构整体性强，易于管理。但是由于数据元素存储区域是表对象的一部分，顺序表创建后，元素存储区就固定了。</p><p>图b为分离式结构，表对象里只保存与整个表有关的信息（即容量和元素个数），实际数据元素存放在另一个独立的元素存储区里，通过链接与基本表对象关联。</p><p><strong>元素存储区替换</strong><br>一体式结构由于顺序表信息区与数据区连续存储在一起，所以若想更换数据区，则只能整体搬迁，即整个顺序表对象（指存储顺序表的结构信息的区域）改变了。</p><p>分离式结构若想更换数据区，只需将表信息区中的数据区链接地址更新即可，而该顺序表对象不变。</p><p><strong>元素存储区扩充</strong><br>采用分离式结构的顺序表，若将数据区更换为存储空间更大的区域，则可以在不改变表对象的前提下对其数据存储区进行了扩充，所有使用这个表的地方都不必修改。只要程序的运行环境（计算机系统）还有空闲存储，这种表结构就不会因为满了而导致操作无法进行。人们把采用这种技术实现的顺序表称为动态顺序表，因为其容量可以在使用中动态变化。</p><p>扩充的两种策略：</p><ul><li><p>每次扩充增加固定数目的存储位置，如每次扩充增加10个元素位置，这种策略可称为线性增长。<strong>特点：节省空间，但是扩充操作频繁，操作次数多。</strong></p></li><li><p>每次扩充容量加倍，如每次扩充增加一倍存储空间。<strong>特点：减少了扩充操作的执行次数，但可能会浪费空间资源。以空间换时间，推荐的方式。</strong></p></li></ul><h2 id="顺序表的操作"><a href="#顺序表的操作" class="headerlink" title="顺序表的操作"></a>顺序表的操作</h2><p><strong>增加元素</strong></p><ul><li><p>尾端加入元素，时间复杂度为O(1)</p></li><li><p>非保序的加入元素（不常见），时间复杂度为O(1)</p></li><li><p>保序的元素加入，时间复杂度为O(n)</p></li></ul><p><strong>删除元素</strong></p><ul><li><p>删除表尾元素，时间复杂度为O(1)</p></li><li><p>非保序的元素删除（不常见），时间复杂度为O(1)</p></li><li><p>保序的元素删除，时间复杂度为O(n)</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;顺序表&quot;&gt;&lt;a href=&quot;#顺序表&quot; class=&quot;headerlink&quot; title=&quot;顺序表&quot;&gt;&lt;/a&gt;顺序表&lt;/h2&gt;&lt;p&gt;在程序中，经常需要将一组（通常是同为某个类型的）数据元素作为整体管理和使用，需要创建这种元素组，用变量记录它们，传进传出函数等。一组数据中包含的元素个数可能发生变化（可以增加或删除元素）。&lt;/p&gt;
&lt;p&gt;对于这种需求，最简单的解决方案便是将这样一组元素看成一个序列，用元素在序列里的位置和顺序，表示实际应用中的某种有意义的信息，或者表示数据之间的某种关系。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="https://jiawea.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="顺序表" scheme="https://jiawea.github.io/tags/%E9%A1%BA%E5%BA%8F%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>算法之时间复杂度</title>
    <link href="https://jiawea.github.io/2019/11/06/Algorithm-O/"/>
    <id>https://jiawea.github.io/2019/11/06/Algorithm-O/</id>
    <published>2019-11-06T02:25:36.000Z</published>
    <updated>2020-04-27T01:18:40.347Z</updated>
    
    <content type="html"><![CDATA[<h2 id="在了解时间复杂度之前，让我们来了解一下什么是算法？"><a href="#在了解时间复杂度之前，让我们来了解一下什么是算法？" class="headerlink" title="在了解时间复杂度之前，让我们来了解一下什么是算法？"></a>在了解时间复杂度之前，让我们来了解一下什么是算法？</h2><p>算法（Algorithm）是指解题方案的准确而完整的描述，是一系列解决问题的清晰指令（我的理解是一系列解决问题的步骤），算法代表着用系统的方法描述解决问题的策略机制。也就是说，能够对一定规范的输入，在有限时间内获得所要求的输出。不同的算法可能用不同的时间、空间或效率来完成同样的任务。</p><p>一个算法的优劣可以用空间复杂度与时间复杂度来衡量。</p><a id="more"></a><h3 id="算法的五大特性："><a href="#算法的五大特性：" class="headerlink" title="算法的五大特性："></a>算法的五大特性：</h3><p>输入：算法具有0个或多个输入<br>输出: 算法至少有1个或多个输出<br>有穷性: 算法在有限的步骤之后会自动结束而不会无限循环，并且每一个步骤可以在可接受的时间内完成<br>确定性：算法中的每一步都有确定的含义，不会出现二义性<br>可行性：算法的每一步都是可行的，也就是说每一步都能够执行有限的次数完成</p><p>不同的算法对执行程序的结果也许是一样的，但是执行时间和效率却有着很大的区别，下面让我们来看个例子：</p><p>问题：a + b + c = 100, a^2  + b^2 = c^2,请计算出所有符合的a, b, c结果。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">import time</span><br><span class="line"> </span><br><span class="line">start_time = time.time()</span><br><span class="line"> </span><br><span class="line"># 注意是三重循环</span><br><span class="line">for a in range(0, 1001):</span><br><span class="line">    for b in range(0, 1001):</span><br><span class="line">        for c in range(0, 1001):</span><br><span class="line">            if a**2 + b**2 == c**2 and a+b+c == 1000:</span><br><span class="line">                print(&quot;a, b, c: %d, %d, %d&quot; % (a, b, c))</span><br><span class="line"> </span><br><span class="line">end_time = time.time()</span><br><span class="line">print(&quot;time: %f&quot; % (end_time - start_time))</span><br><span class="line">print(&quot;finished!&quot;)</span><br></pre></td></tr></table></figure></p><p>结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a, b, c: 0, 500, 500</span><br><span class="line">a, b, c: 200, 375, 425</span><br><span class="line">a, b, c: 375, 200, 425</span><br><span class="line">a, b, c: 500, 0, 500</span><br><span class="line">time: 214.583347</span><br><span class="line">finished!</span><br></pre></td></tr></table></figure></p><p>程序执行完总共花费了214秒。我们再来看一个例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">import time</span><br><span class="line"> </span><br><span class="line">start_time = time.time()</span><br><span class="line"> </span><br><span class="line"># 注意是两重循环</span><br><span class="line">for a in range(0, 1001):</span><br><span class="line">    for b in range(0, 1001-a):</span><br><span class="line">        c = 1000 - a - b</span><br><span class="line">        if a**2 + b**2 == c**2:</span><br><span class="line">            print(&quot;a, b, c: %d, %d, %d&quot; % (a, b, c))</span><br><span class="line"> </span><br><span class="line">end_time = time.time()</span><br><span class="line">print(&quot;time: %f&quot; % (end_time - start_time))</span><br><span class="line">print(&quot;finished!&quot;)</span><br></pre></td></tr></table></figure></p><p>结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a, b, c: 0, 500, 500</span><br><span class="line">a, b, c: 200, 375, 425</span><br><span class="line">a, b, c: 375, 200, 425</span><br><span class="line">a, b, c: 500, 0, 500</span><br><span class="line">time: 0.182897</span><br><span class="line">finished!</span><br></pre></td></tr></table></figure></p><p>程序执行完总共花费了0.18秒，这对于第一种方法来说，无疑是一种很大的提升。所以说，算法的好坏对于程序来说是非常重要的。</p><p><strong>因此，我们可以得出一个结论：实现算法程序的执行时间可以反应出算法的效率，即算法的优劣。</strong></p><h2 id="单靠时间值绝对可信吗？"><a href="#单靠时间值绝对可信吗？" class="headerlink" title="单靠时间值绝对可信吗？"></a>单靠时间值绝对可信吗？</h2><p>假设我们将第二次尝试的算法程序运行在一台配置古老性能低下的计算机中，情况会如何？很可能运行的时间并不会比在我们的电脑中运行算法一的214.583347秒快多少。</p><p>单纯依靠运行的时间来比较算法的优劣并不一定是客观准确的！</p><p>程序的运行离不开计算机环境（包括硬件和操作系统），这些客观原因会影响程序运行的速度并反应在程序的执行时间上。那么如何才能客观的评判一个算法的优劣呢？</p><h2 id="时间复杂度与“大O记法”"><a href="#时间复杂度与“大O记法”" class="headerlink" title="时间复杂度与“大O记法”"></a>时间复杂度与“大O记法”</h2><p>我们假定计算机执行算法每一个基本操作的时间是固定的一个时间单位，那么有多少个基本操作就代表会花费多少时间单位。算然对于不同的机器环境而言，确切的单位时间是不同的，但是对于算法进行多少个基本操作（即花费多少时间单位）在规模数量级上却是相同的，由此可以忽略机器环境的影响而客观的反应算法的时间效率。</p><p>对于算法的时间效率，我们可以用“大O记法”来表示。</p><p>“大O记法”：对于单调的整数函数f，如果存在一个整数函数g和实常数c&gt;0，使得对于充分大的n总有f(n)&lt;=c*g(n)，就说函数g是f的一个渐近函数（忽略常数），记为f(n)=O(g(n))。也就是说，在趋向无穷的极限意义下，函数f的增长速度受到函数g的约束，亦即函数f与函数g的特征相似。</p><p><strong>时间复杂度：假设存在函数g，使得算法A处理规模为n的问题示例所用时间为T(n)=O(g(n))，则称O(g(n))为算法A的渐近时间复杂度，简称时间复杂度，记为T(n)</strong></p><h2 id="最坏时间复杂度"><a href="#最坏时间复杂度" class="headerlink" title="最坏时间复杂度"></a>最坏时间复杂度</h2><p>分析算法时，存在几种可能的考虑：</p><p>算法完成工作最少需要多少基本操作，即最优时间复杂度<br>算法完成工作最多需要多少基本操作，即最坏时间复杂度<br>算法完成工作平均需要多少基本操作，即平均时间复杂度<br>对于最优时间复杂度，其价值不大，因为它没有提供什么有用信息，其反映的只是最乐观最理想的情况，没有参考价值。</p><p>对于最坏时间复杂度，提供了一种保证，表明算法在此种程度的基本操作中一定能完成工作。</p><p>对于平均时间复杂度，是对算法的一个全面评价，因此它完整全面的反映了这个算法的性质。但另一方面，这种衡量并没有保证，不是每个计算都能在这个基本操作内完成。而且，对于平均情况的计算，也会因为应用算法的实例分布可能并不均匀而难以计算。</p><p>因此，我们主要关注算法的最坏情况，亦即最坏时间复杂度。</p><h2 id="算法分析"><a href="#算法分析" class="headerlink" title="算法分析"></a>算法分析</h2><p>1）上面第一个列子核心部分：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">for a in range(0, 1001):</span><br><span class="line">    for b in range(0, 1001):</span><br><span class="line">        for c in range(0, 1001):</span><br><span class="line">            if a**2 + b**2 == c**2 and a+b+c == 1000:</span><br><span class="line">                print(&quot;a, b, c: %d, %d, %d&quot; % (a, b, c))</span><br></pre></td></tr></table></figure></p><p>时间复杂度：<br><code>T(n) = O(n*n*n) = O(n3)</code></p><p>2）第二个例子核心部分：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">for a in range(0, 1001):</span><br><span class="line">    for b in range(0, 1001-a):</span><br><span class="line">        c = 1000 - a - b</span><br><span class="line">        if a**2 + b**2 == c**2:</span><br><span class="line">            print(&quot;a, b, c: %d, %d, %d&quot; % (a, b, c))</span><br></pre></td></tr></table></figure></p><p>时间复杂度：<br><code>T(n) = O(n*n*(1+1)) = O(n*n) = O(n2)</code></p><p>由此可见，我们尝试的第二种算法要比第一种算法的时间复杂度好多的。</p><h3 id="常见时间复杂度"><a href="#常见时间复杂度" class="headerlink" title="常见时间复杂度"></a>常见时间复杂度</h3><table><thead><tr><th style="text-align:center">执行次数函数举例</th><th style="text-align:center">阶</th><th style="text-align:center">非正式术语</th></tr></thead><tbody><tr><td style="text-align:center">12</td><td style="text-align:center">O(1)</td><td style="text-align:center">常数阶</td></tr><tr><td style="text-align:center">2n+3</td><td style="text-align:center">O(n)</td><td style="text-align:center">线性阶</td></tr><tr><td style="text-align:center">3n^2+2n+1</td><td style="text-align:center">O(n^2)</td><td style="text-align:center">平方阶</td></tr><tr><td style="text-align:center">5log2n+20</td><td style="text-align:center">O(logn)</td><td style="text-align:center">对数阶</td></tr><tr><td style="text-align:center">2n+3nlog2n+19</td><td style="text-align:center">O(nlogn)</td><td style="text-align:center">nlogn阶</td></tr><tr><td style="text-align:center">6n^3+2n^2+3n+4</td><td style="text-align:center">O(n^3)</td><td style="text-align:center">立方阶</td></tr><tr><td style="text-align:center">2^n    O(2n)</td><td style="text-align:center">O(2^n)</td><td style="text-align:center">指数阶</td></tr></tbody></table><h3 id="常见时间复杂度的关系"><a href="#常见时间复杂度的关系" class="headerlink" title="常见时间复杂度的关系"></a>常见时间复杂度的关系</h3><center><img src="/static/blogImg/algorithm_1.png" alt="avatar"></center><p>所消耗的时间从小到大<br>O(1) &lt; O(logn) &lt; O(n) &lt; O(nlogn) &lt; O(n2) &lt; O(n3) &lt; O(2n) &lt; O(n!) &lt; O(nn)</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;在了解时间复杂度之前，让我们来了解一下什么是算法？&quot;&gt;&lt;a href=&quot;#在了解时间复杂度之前，让我们来了解一下什么是算法？&quot; class=&quot;headerlink&quot; title=&quot;在了解时间复杂度之前，让我们来了解一下什么是算法？&quot;&gt;&lt;/a&gt;在了解时间复杂度之前，让我们来了解一下什么是算法？&lt;/h2&gt;&lt;p&gt;算法（Algorithm）是指解题方案的准确而完整的描述，是一系列解决问题的清晰指令（我的理解是一系列解决问题的步骤），算法代表着用系统的方法描述解决问题的策略机制。也就是说，能够对一定规范的输入，在有限时间内获得所要求的输出。不同的算法可能用不同的时间、空间或效率来完成同样的任务。&lt;/p&gt;
&lt;p&gt;一个算法的优劣可以用空间复杂度与时间复杂度来衡量。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="https://jiawea.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="时间复杂度" scheme="https://jiawea.github.io/tags/%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/"/>
    
  </entry>
  
  <entry>
    <title>HTTP报文理解</title>
    <link href="https://jiawea.github.io/2019/10/17/HttpMessages/"/>
    <id>https://jiawea.github.io/2019/10/17/HttpMessages/</id>
    <published>2019-10-17T02:06:47.000Z</published>
    <updated>2020-04-27T01:20:30.690Z</updated>
    
    <content type="html"><![CDATA[<p>HTTP报文携带着HTTP协议交互的信息，可以理解为它为搬东西的包裹，来搬运交换的信息。<br>其中有两种类型的报文，一是客户端发送的请求到服务器的HTTP报文叫做请求报文，二是服务器响应给客户端的叫响应报文。</p><center><img src="/static/blogImg/HTTP_Messages.png" alt="avatar"></center><a id="more"></a><h3 id="请求报文组成部分"><a href="#请求报文组成部分" class="headerlink" title="请求报文组成部分"></a>请求报文组成部分</h3><p>HTTP 报文大致可分为请求行、请求头、空行、请求主体四部分。</p><ul><li>请求行</li><li>请求头</li><li>空行</li><li>请求数据</li></ul><h3 id="请求报文"><a href="#请求报文" class="headerlink" title="请求报文"></a>请求报文</h3><p><strong>请求行</strong><br>组成：请求方式 + 请求URI + HTTP版本 + CR LF(换行)<br>HTTP请求是客户端发送的用于在服务器上启动操作的消息。它们的起始行包含三个元素，例如，GET /index.html HTTP/1.1。</p><p>HTTP协议的请求方法有GET、POST、HEAD、PUT、DELETE、OPTIONS、TRACE、CONNECT。</p><ul><li>GET: 请求目标通常是URL，或者协议，端口和域的绝对路径通常由请求上下文来表征。此请求目标的格式在不同的HTTP方法之间有所不同。有可能绝对路径，最后跟一个“？”和查询字符串。这是最常见的形式，称为原始形式，并且与GET，POST，HEAD和OPTIONS方法一起使用。如：GET /index.html?id=1 HTTP/1.1</li><li>POST: 对于不适合使用GET方式的情况（比如账号登录），可以使用POST方式，因为使用POST方法可以允许客户端给服务器提供信息较多。POST方法将请求参数封装在HTTP请求数据中，以“键：值”的形式出现，可以传输大量数据，这样POST方式对传送的数据大小没有限制，而且也不会显示在URL中。</li><li>HEAD: HEAD就像GET，只不过服务端接受到HEAD请求后只返回响应头，而不会发送响应内容。当我们只需要查看某个页面的状态的时候，使用HEAD是非常高效的，因为在传输的过程中省去了页面内容。</li></ul><p><strong>请求头部</strong></p><center><img src="/static/blogImg/HTTP_Request_Headers2.png" alt="avatar"></center><p>请求头部由键值对组成，每行一对，关键字和值用英文冒号“:”分隔。请求头部通知服务器有关于客户端请求的信息，典型的请求头有：</p><ul><li>User-Agent：产生请求的浏览器类型。</li><li>Accept：客户端可识别的内容类型列表。</li><li>Host：请求的主机名，允许多个域名同处一个IP地址，即虚拟主机。</li></ul><p><strong>空行</strong><br>最后一个请求头之后是一个空行，发送回车符和换行符，通知服务器以下不再有请求头。</p><p><strong>请求数据</strong><br>请求数据不在GET方法中使用，而是在POST方法中使用。POST方法适用于需要客户填写表单的场合。与请求数据相关的最常使用的请求头是<code>Content-Type</code>和<code>Content-Length</code>。</p><h3 id="响应报文"><a href="#响应报文" class="headerlink" title="响应报文"></a>响应报文</h3><p><strong>请求行</strong><br>组成：HTTP版本 + 状态码  + 状态码描述 + CR LF(换行)<br>响应报文结构与请求报文结构唯一的区别在于第一行中用状态信息代替了请求信息。状态行（status line）通过提供一个状态码来说明所请求的资源情况。</p><p>HTTP状态码被分为五大类:</p><ol><li>状态代码由服务器发出，以响应客户端对服务器的请求。</li><li>1xx（信息）：收到请求，继续处理</li><li>2xx（成功）：请求已成功接收，理解和接受</li><li>3xx（重定向）：为了完成指定的动作，必须接受进一步处理</li><li>4xx（客户端错误）：请求包含错误的语法或无法满足</li><li>5xx（服务器错误）：服务器不能正确执行一个正确的请求</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;HTTP报文携带着HTTP协议交互的信息，可以理解为它为搬东西的包裹，来搬运交换的信息。&lt;br&gt;其中有两种类型的报文，一是客户端发送的请求到服务器的HTTP报文叫做请求报文，二是服务器响应给客户端的叫响应报文。&lt;/p&gt;
&lt;center&gt;&lt;img src=&quot;/static/blogImg/HTTP_Messages.png&quot; alt=&quot;avatar&quot;&gt;&lt;/center&gt;
    
    </summary>
    
    
      <category term="HTTP" scheme="https://jiawea.github.io/tags/HTTP/"/>
    
  </entry>
  
  <entry>
    <title>Python进阶用法</title>
    <link href="https://jiawea.github.io/2019/10/14/HiddenFeaturesOfPython/"/>
    <id>https://jiawea.github.io/2019/10/14/HiddenFeaturesOfPython/</id>
    <published>2019-10-14T02:58:14.000Z</published>
    <updated>2020-03-27T03:39:30.572Z</updated>
    
    <content type="html"><![CDATA[<p>使用Python来编写也有很长一段时间了，也想着如何优化自己的代码，随之也搜了一些问题。<br>其中印象比较深刻的就是stackoverflow上的一个问题解答了。</p><a id="more"></a><p>原文：<a href="https://stackoverflow.com/questions/101268/hidden-features-of-python" target="_blank" rel="noopener">Hidden features of Python</a></p><p><strong>Argument Unpacking</strong><br>可以使用 * 和 ** 分别将一个列表和一个字典解包为函数参数<br>如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">def draw_point(x, y):</span><br><span class="line"># do something</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">tuple = (6, 8)</span><br><span class="line">dir = &#123;&apos;x&apos;: 6, &apos;y&apos;: 8&#125;</span><br><span class="line"></span><br><span class="line">draw_point(*tuple)</span><br><span class="line">draw_point(**dir)</span><br></pre></td></tr></table></figure></p><p><strong>Decorators</strong><br>装饰器的作用就是在不需要修改原函数代码的前提下增加新的功能，在调用原函数的时候先执行装饰器，如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">def print_before_func(func):</span><br><span class="line">def wrapper(*args, **kwargs):</span><br><span class="line">print(&quot;print before func&quot;)</span><br><span class="line">return func(*args, **kwargs)</span><br><span class="line">return wrapper</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@print_befor_func</span><br><span class="line">def write(text):</span><br><span class="line">print(text)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">write(Hello world)</span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line">print before func</span><br><span class="line">Hello world</span><br></pre></td></tr></table></figure></p><p><strong>Dictionary default .get value</strong><br>字典中有一个<code>get()</code>方法。如果你使用<code>dict[&#39;key&#39;]</code>的方式而<code>key</code>不存在的话就会出现异常。使用<code>dict.get(&#39;key&#39;)</code>的话如果<code>key</code>不存在则只会返回<code>None</code>。当然<code>get()</code>方法提供了第二个参数，如果返回<code>None</code>则会返回第二个参数的值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">num = dict.get(&apos;num&apos;, 0)</span><br></pre></td></tr></table></figure></p><p><strong>Enumeration</strong><br>使用enumeration包住一个可迭代对象，它会将index和item绑在一起，返回一个enumeration对象，如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">a = [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;]</span><br><span class="line">for index, item in enumeration(a):</span><br><span class="line">print(index, item)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">···</span><br><span class="line">0 a</span><br><span class="line">1 b</span><br><span class="line">2 c</span><br><span class="line">3 d</span><br><span class="line">···</span><br></pre></td></tr></table></figure></p><p>在同时需要索引和值的时候很有用</p><p><strong>For/else</strong><br>语法如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">for i in foo:</span><br><span class="line">if i == 0:</span><br><span class="line">break</span><br><span class="line">else:</span><br><span class="line">print(&quot;it was never 0&quot;)</span><br></pre></td></tr></table></figure></p><p><code>else</code>代码块会在循环正常结束后执行，也就是说没用出现<code>break</code>时才会调用<code>else</code>代码块，上面代码等价于:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">found = False</span><br><span class="line">for i in foo:</span><br><span class="line">if i == 0:</span><br><span class="line">found = True</span><br><span class="line">break</span><br><span class="line"></span><br><span class="line">if not found:</span><br><span class="line">print(&quot;it was never 0&quot;)</span><br></pre></td></tr></table></figure></p><p>这个语法挺容易让人混淆的，所有在使用的时候最好是注释一下，以免被其他小伙伴搞错含义了。</p><p>上面的代码也等价于：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if any(i == 0 for i in foo):</span><br><span class="line">pass</span><br><span class="line">else:</span><br><span class="line">print(&quot;it was never 0&quot;)</span><br></pre></td></tr></table></figure></p><p><strong>Generator expressions</strong><br>假如你这样写：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x = (n for n in foo if bar(n))</span><br></pre></td></tr></table></figure></p><p>你将会得到一个生成器，并可以把它付给一个变量x。现在你可以像下面一样使用生成器：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">for n in x:</span><br><span class="line">print(n)</span><br></pre></td></tr></table></figure></p><p>这样做的好处就是节省内存了。你不需要中间存储，而如果像下面这样的话，则需要：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x = [n for n in foo if bar(n)]</span><br><span class="line"># 列表推导</span><br></pre></td></tr></table></figure></p><p>在某些情况下，这会导致极重要的速度提升。<br>你可以添加许多if语句到生成器的尾端，基本复制for循环嵌套：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; n = ((a,b) for a in range(0,2) for b in range(4,6))</span><br><span class="line">&gt;&gt;&gt; for i in n:</span><br><span class="line">...   print i </span><br><span class="line"></span><br><span class="line">(0, 4)</span><br><span class="line">(0, 5)</span><br><span class="line">(1, 4)</span><br><span class="line">(1, 5)</span><br></pre></td></tr></table></figure></p><p>使用生成器最大的好处就是节省内存了。因为每一个值只有在你需要的时候才会生成，而不像列表推导那样一次性生成所有的结果。</p><p><strong>List stepping</strong><br>切片操作符中的步长(step)参数。例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = [1,2,3,4,5]</span><br><span class="line">&gt;&gt;&gt; a[::2]  # iterate over the whole list in 2-increments</span><br><span class="line">[1,3,5]</span><br></pre></td></tr></table></figure></p><p>特殊例子<code>x[::-1]</code>对‘x反转’来说相当有用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; a[::-1]</span><br><span class="line">[5,4,3,2,1]</span><br></pre></td></tr></table></figure></p><p>当然，你可以使用<code>reversed()</code>函数来实现反转。<br>区别在于，reversed()返回一个迭代器，所以还需要一个额外的步骤来将结果转换成需要的对象类型。<br>这个特性在判断例如回文的时候灰常有用，一句话搞定<br><code>True if someseq == someseq[::-1] else False</code></p><p><strong>Named string formatting</strong><br>%-格式化接收一个字典（也适用于%i%s等）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; print &quot;The %(foo)s is %(bar)i.&quot; % &#123;&apos;foo&apos;: &apos;answer&apos;, &apos;bar&apos;:42&#125;</span><br><span class="line">The answer is 42.</span><br></pre></td></tr></table></figure></p><p><strong>try/except/else</strong><br>else语句块只有当try语句正常执行（也就是说，except语句未执行）的时候，才会执行。<br>finally则无论是否异常都会执行。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">try:</span><br><span class="line">     Normal execution block</span><br><span class="line">except A:</span><br><span class="line">     Exception A handle</span><br><span class="line">except B:</span><br><span class="line">     Exception B handle</span><br><span class="line">except:</span><br><span class="line">     Other exception handle</span><br><span class="line">else:</span><br><span class="line">     if no exception,get here</span><br><span class="line">finally:</span><br><span class="line">     this block will be excuted no matter how it goes above</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;使用Python来编写也有很长一段时间了，也想着如何优化自己的代码，随之也搜了一些问题。&lt;br&gt;其中印象比较深刻的就是stackoverflow上的一个问题解答了。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Python" scheme="https://jiawea.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>告别GOPATH,使用go mod</title>
    <link href="https://jiawea.github.io/2019/09/25/go_mod/"/>
    <id>https://jiawea.github.io/2019/09/25/go_mod/</id>
    <published>2019-09-25T01:47:23.000Z</published>
    <updated>2020-03-27T03:39:37.855Z</updated>
    
    <content type="html"><![CDATA[<p>我们都知道在使用Golang时开发程序时都需要在 <code>GOPATH</code> 下面，这就非常不方便。如果你想放在磁盘上的其他地方，那么go mod将是你的“好伙伴”。</p><a id="more"></a><p>关于 go mod 的说明，可以参考：</p><ul><li><a href="https://roberto.selbach.ca/intro-to-go-modules/" target="_blank" rel="noopener">Introduction to Go Modules</a></li><li><a href="https://github.com/golang/go/wiki/Modules" target="_blank" rel="noopener">Go 1.11 Modules 官方说明文档</a></li></ul><h3 id="命令行说明"><a href="#命令行说明" class="headerlink" title="命令行说明"></a>命令行说明</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ go mod</span><br><span class="line">Go mod provides access to operations on modules.</span><br><span class="line">Note that support for modules is built into all the go commands,</span><br><span class="line">not just &apos;go mod&apos;. For example, day-to-day adding, removing, upgrading,</span><br><span class="line">and downgrading of dependencies should be done using &apos;go get&apos;.</span><br><span class="line">See &apos;go help modules&apos; for an overview of module functionality.</span><br><span class="line">Usage:</span><br><span class="line">go mod &lt;command&gt; [arguments]</span><br><span class="line">The commands are:</span><br><span class="line">download    download modules to local cache</span><br><span class="line">edit        edit go.mod from tools or scripts</span><br><span class="line">graph       print module requirement graph</span><br><span class="line">init        initialize new module in current directory</span><br><span class="line">tidy        add missing and remove unused modules </span><br><span class="line">vendor      make vendored copy of dependencies</span><br><span class="line">verify      verify dependencies have expected content  </span><br><span class="line">why         explain why packages or modules are needed </span><br><span class="line">Use &quot;go help mod &lt;command&gt;&quot; for more information about a command.</span><br></pre></td></tr></table></figure><ul><li>go mod download: 下载依赖的 module 到本地 cache</li><li>go mod edit: 编辑 go.mod</li><li>go mod graph: 打印模块依赖图</li><li>go mod init: 在当前目录下初始化 go.mod(就是会新建一个 go.mod 文件)</li><li>go mod tidy: 整理依赖关系，会添加丢失的 module，删除不需要的 module</li><li>go mod vender: 将依赖复制到 vendor 下</li><li>go mod verify: 校验依赖</li><li>go mod why: 解释为什么需要依赖</li></ul><p>执行命令<code>go mod verify</code>命令来检查当前模块的依赖是否全部下载下来，是否下载下来被修改过。如果所有的模块都没有被修改过，那么执行这条命令之后，会打印<code>all modules verified</code>。</p><h3 id="如果在项目中使用"><a href="#如果在项目中使用" class="headerlink" title="如果在项目中使用"></a>如果在项目中使用</h3><ol><li>版本：首先将你的Go版本更新到(&gt;=1.11)，这里将不介绍怎么更新</li><li>设置环境变量(1.12默认)：在你的项目目录下使用<code>set GO111MODULE=ON</code></li><li>执行<code>go mod init</code>在当前目录下生成一个<code>go.mod</code>文件，如果之前有生成过需要删除再初始化</li></ol><p>执行完上面步骤基本就完成了，运行下程序你会发现目录下多了一个<code>go.sum</code>文件，是用来记录所依赖的版本的锁定</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>使用<code>go mod</code>后你会发现在<code>GOPATH</code>下面的<code>pkg</code>目录会有一个<code>mod</code>目录，里面包含了项目需要的依赖包，这也是为什么不需要再<code>GOPATH</code>中开发程序也能使用的原因</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我们都知道在使用Golang时开发程序时都需要在 &lt;code&gt;GOPATH&lt;/code&gt; 下面，这就非常不方便。如果你想放在磁盘上的其他地方，那么go mod将是你的“好伙伴”。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Go" scheme="https://jiawea.github.io/tags/Go/"/>
    
      <category term="mod" scheme="https://jiawea.github.io/tags/mod/"/>
    
  </entry>
  
  <entry>
    <title>初识Python asyncio异步编程</title>
    <link href="https://jiawea.github.io/2019/09/23/asyncio/"/>
    <id>https://jiawea.github.io/2019/09/23/asyncio/</id>
    <published>2019-09-23T07:58:52.000Z</published>
    <updated>2019-10-14T07:20:09.816Z</updated>
    
    <content type="html"><![CDATA[<p>同步代码(synchrnous code)<br>我们都很熟悉，就是运行完一个步骤再运行下一个。要在同步代码里面实现”同时”运行多个任务，最简单也是最直观地方式就是运行多个 threads 或者多个 processes。<br><a id="more"></a><br>这个层次的『同时运行』多个任务，是操作系统协助完成的。 也就是操作系统的任务调度系统来决定什么时候运行这个任务，什么时候切换任务，你自己，作为一个应用层的程序员，是没办法进行干预的。</p><p>我相信你也已经听说了什么关于 thread 和 process 的抱怨：process 太重，thread 又要牵涉到很多头条的锁问题。尤其是对于一个 Python 开发者来说，由于GIL（全局解释器锁）的存在，多线程无法真正使用多核，如果你用多线程来运行计算型任务，速度会更慢。</p><p>异步编程与之不同的是，值使用一个进程，不使用 threads，但是也能实现”同时”运行多个任务（这里的任务其实就是函数）。</p><p>这些函数有一个非常 nice 的 feature：必要的可以暂停，把运行的权利交给其他函数。等到时机恰当，又可以恢复之前的状态继续运行。这听上去是不是有点像进程呢？可以暂停，可以恢复运行。只不过进程的调度是操作系统完成的，这些函数的调度是进程自己（或者说程序员你自己）完成的。这也就意味着这将省去了很多计算机的资源，因为进程的调度必然需要大量 syscall，而 syscall 是很昂贵的。</p><h3 id="一-定义一个简单的协程："><a href="#一-定义一个简单的协程：" class="headerlink" title="一 定义一个简单的协程："></a>一 定义一个简单的协程：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">import asyncio</span><br><span class="line">  </span><br><span class="line">async def execute(x):</span><br><span class="line">    print(&apos;Number:&apos;, x)</span><br><span class="line">    return x</span><br><span class="line">  </span><br><span class="line">coroutine = execute(1)</span><br><span class="line">print(&apos;Coroutine:&apos;, coroutine)</span><br><span class="line">print(&apos;After calling execute&apos;)</span><br><span class="line">  </span><br><span class="line">loop = asyncio.get_event_loop()</span><br><span class="line">task = loop.create_task(coroutine)</span><br><span class="line">print(&apos;Task:&apos;, task)</span><br><span class="line">loop.run_until_complete(task)</span><br><span class="line">print(&apos;Task:&apos;, task)</span><br><span class="line">print(&apos;After calling loop&apos;)</span><br></pre></td></tr></table></figure><p>print(‘Task Result:’, task.result())  这样也能查看task执行的结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Coroutine: &lt;coroutine object execute at 0x10e0f7830&gt;</span><br><span class="line">After calling execute</span><br><span class="line">Task: &lt;Task pending coro=&lt;execute() running at demo.py:4&gt;&gt;</span><br><span class="line">Number: 1</span><br><span class="line">Task: &lt;Task finished coro=&lt;execute() done, defined at demo.py:4&gt; result=1&gt;</span><br><span class="line">After calling loop</span><br></pre></td></tr></table></figure><p>我们使用 async 定义了一个 execute() 方法，方法接收一个数字参数，方法执行之后会打印这个数字。<br>随后我们直接调用了这个方法，然而这个方法并没有执行，而是返回了一个 coroutine 协程对象。</p><p>随后我们使用 get_event_loop() 方法创建了一个事件循环 loop，并调用了 loop 对象的 run_until_complete() 方法将协程注册到事件循环 loop 中，然后启动。最后我们才看到了 execute() 方法打印了输出结果。可见，async 定义的方法就会变成一个无法直接执行的 coroutine 对象，必须将其注册到事件循环中才可以执行。</p><p>我们也可以不使用task来运行，它里面相比 coroutine 对象多了运行状态，比如 running、finished 等，我们可以用这些状态来获取协程对象的执行情况。将 coroutine 对象传递给 run_until_complete() 方法的时候，实际上它进行了一个操作就是将 coroutine 封装成了 task 对象，如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">import asyncio</span><br><span class="line"></span><br><span class="line">async def execute(x):</span><br><span class="line">    print(&apos;Number:&apos;, x)</span><br><span class="line"></span><br><span class="line">coroutine = execute(1)</span><br><span class="line">print(&apos;Coroutine:&apos;, coroutine)</span><br><span class="line">print(&apos;After calling execute&apos;)</span><br><span class="line"></span><br><span class="line">loop = asyncio.get_event_loop()</span><br><span class="line">loop.run_until_complete(coroutine)</span><br><span class="line">print(&apos;After calling loop&apos;)</span><br></pre></td></tr></table></figure><p>查看了源码，正好可以验证上面这一观点：</p><p>run_until_complete()这个方法位于源码中的base_events.py，函数有句注释：<br>Run until the Future is done.If the argument is a coroutine, it is wrapped in a Task.</p><h3 id="二-发送网络请求结合aiohttp实现异步："><a href="#二-发送网络请求结合aiohttp实现异步：" class="headerlink" title="二 发送网络请求结合aiohttp实现异步："></a>二 发送网络请求结合aiohttp实现异步：</h3><p>我们用一个网络请求作为示例，这就是一个耗时等待的操作，因为我们请求网页之后需要等待页面响应并返回结果。耗时等待的操作一般都是 IO 操作，比如文件读取、网络请求等等。协程对于处理这种操作是有很大优势的，当遇到需要等待的情况的时候，程序可以暂时挂起，转而去执行其他的操作，从而避免一直等待一个程序而耗费过多的时间，充分利用资源。为了测试，我自己先通过flask 创建一个实验环境：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">from flask import Flask</span><br><span class="line">import time</span><br><span class="line">  </span><br><span class="line">app = Flask(__name__)</span><br><span class="line">  </span><br><span class="line">@app.route(&apos;/&apos;)</span><br><span class="line">def index():</span><br><span class="line">    time.sleep(3)</span><br><span class="line">    return &apos;Hello!&apos;</span><br><span class="line">  </span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    app.run(threaded=True)</span><br></pre></td></tr></table></figure></p><p>开始测试…<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">import asyncio</span><br><span class="line">import aiohttp</span><br><span class="line">import time</span><br><span class="line">  </span><br><span class="line">start = time.time()</span><br><span class="line">  </span><br><span class="line">async def get(url):</span><br><span class="line">    session = aiohttp.ClientSession()</span><br><span class="line">    response = await session.get(url)</span><br><span class="line">    result = await response.text()</span><br><span class="line">    session.close()</span><br><span class="line">    return result</span><br><span class="line">  </span><br><span class="line">async def request():</span><br><span class="line">    url = &apos;http://127.0.0.1:5000&apos;          # 访问flask搭建的服务器（睡眠3秒），模仿IO阻塞</span><br><span class="line">    print(&apos;Waiting for&apos;, url)</span><br><span class="line">    result = await get(url)</span><br><span class="line">    print(&apos;Get response from&apos;, url, &apos;Result:&apos;, result)</span><br><span class="line">  </span><br><span class="line">tasks = [asyncio.ensure_future(request()) for _ in range(5)]</span><br><span class="line">loop = asyncio.get_event_loop()</span><br><span class="line">loop.run_until_complete(asyncio.wait(tasks))</span><br><span class="line">  </span><br><span class="line">end = time.time()</span><br><span class="line">print(&apos;Cost time:&apos;, end - start)</span><br></pre></td></tr></table></figure></p><p>运行结果…<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Waiting for http://127.0.0.1:5000</span><br><span class="line">Waiting for http://127.0.0.1:5000</span><br><span class="line">Waiting for http://127.0.0.1:5000</span><br><span class="line">Waiting for http://127.0.0.1:5000</span><br><span class="line">Waiting for http://127.0.0.1:5000</span><br><span class="line">Get response from http://127.0.0.1:5000 Result: Hello!</span><br><span class="line">Get response from http://127.0.0.1:5000 Result: Hello!</span><br><span class="line">Get response from http://127.0.0.1:5000 Result: Hello!</span><br><span class="line">Get response from http://127.0.0.1:5000 Result: Hello!</span><br><span class="line">Get response from http://127.0.0.1:5000 Result: Hello!</span><br><span class="line">Cost time: 3.0199508666992188</span><br></pre></td></tr></table></figure></p><p>我们发现这次请求的耗时由 15 秒变成了 3 秒，耗时直接变成了原来的 1/5。</p><p>代码里面我们使用了 await，后面跟了 get() 方法，在执行这五个协程的时候，如果遇到了 await，那么就会将当前协程挂起，转而去执行其他的协程，直到其他的协程也挂起或执行完毕，再进行下一个协程的执行。</p><h2 id="二-总结"><a href="#二-总结" class="headerlink" title="二 总结"></a>二 总结</h2><p>协程”同时”运行多个任务的基础是函数可以暂停（await实际就是用到了yield）。上面的代码中使用到了 asyncio的 event_loop，它做的事情，本质上来说就是当函数暂停时，切换到下一个任务，当时机恰当（这个例子中是请求完成了）恢复函数让他继续运行（这有点像操作系统了）。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;同步代码(synchrnous code)&lt;br&gt;我们都很熟悉，就是运行完一个步骤再运行下一个。要在同步代码里面实现”同时”运行多个任务，最简单也是最直观地方式就是运行多个 threads 或者多个 processes。&lt;br&gt;
    
    </summary>
    
      <category term="Python" scheme="https://jiawea.github.io/categories/Python/"/>
    
    
      <category term="异步" scheme="https://jiawea.github.io/tags/%E5%BC%82%E6%AD%A5/"/>
    
      <category term="asyncio" scheme="https://jiawea.github.io/tags/asyncio/"/>
    
  </entry>
  
  <entry>
    <title>关于我</title>
    <link href="https://jiawea.github.io/2019/09/23/index/"/>
    <id>https://jiawea.github.io/2019/09/23/index/</id>
    <published>2019-09-23T01:47:23.000Z</published>
    <updated>2020-04-27T01:22:11.969Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;2018年毕业于惠州经济职业技术学院，计算机网络专业。喜欢学习新事物，挑战自己。</p><p>&emsp;&emsp;关于写博客是想记录一下自己学习历程，踩过的一些坑，不断地提升自己的知识，做一个Geek。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&amp;emsp;&amp;emsp;2018年毕业于惠州经济职业技术学院，计算机网络专业。喜欢学习新事物，挑战自己。&lt;/p&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;关于写博客是想记录一下自己学习历程，踩过的一些坑，不断地提升自己的知识，做一个Geek。&lt;/p&gt;

      
    
    </summary>
    
    
      <category term="介绍" scheme="https://jiawea.github.io/tags/%E4%BB%8B%E7%BB%8D/"/>
    
  </entry>
  
</feed>
